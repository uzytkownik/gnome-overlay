diff --git a/configure.in b/configure.in
index 65e9caf..237d53b 100644
--- a/configure.in
+++ b/configure.in
@@ -953,6 +953,50 @@ AC_CHECK_FUNCS(_NSGetEnviron)
 AC_FUNC_VSNPRINTF_C99
 AC_FUNC_PRINTF_UNIX98
 
+# Internet address families
+if test $glib_native_win32 = yes; then
+  glib_inet_includes=["
+#include <winsock2.h>
+  "]
+else
+  glib_inet_includes=["
+#include <sys/socket.h>
+  "]
+fi
+
+glib_failed=false
+GLIB_CHECK_VALUE(AF_INET, $glib_inet_includes, glib_failed=true)
+GLIB_CHECK_VALUE(AF_INET6, $glib_inet_includes, glib_failed=true)
+# winsock defines this even though it doesn't support it
+GLIB_CHECK_VALUE(AF_UNIX, $glib_inet_includes, glib_failed=true)
+if $glib_failed ; then
+  AC_MSG_ERROR([Could not determine values for AF_INET* constants])
+fi
+
+# For gio/libasyncns
+if test $glib_native_win32 = no; then
+  AC_CHECK_FUNCS(strndup setresuid setreuid)
+  AC_CHECK_HEADERS(sys/prctl.h arpa/nameser_compat.h)
+  AC_CHECK_FUNC(res_query, ,
+    [AC_CHECK_LIB(resolv, res_query, [ LIBASYNCNS_LIBADD="-lresolv" ],
+      [ save_libs="$LIBS"
+        LIBS="-lresolv $LIBS"
+        AC_MSG_CHECKING([for res_query in -lresolv (alternate version)])
+        AC_LINK_IFELSE(
+          [AC_LANG_PROGRAM([[#include <resolv.h>]], [[res_query(0,0,0,0,0)]])],
+          [ AC_MSG_RESULT(yes)
+  	  LIBASYNCNS_LIBADD="-lresolv" ],
+          [ AC_MSG_RESULT(no)
+            AC_CHECK_LIB(bind, res_query,
+              [ LIBASYNCNS_LIBADD="-lbind" ],
+  	    [ AC_MSG_ERROR(res_query not found) ] ) ] )
+        LIBS="$save_libs"
+      ] )
+    ]
+  )
+  AC_SUBST(LIBASYNCNS_LIBADD)
+fi
+
 dnl
 dnl if statfs() takes 2 arguments (Posix) or 4 (Solaris)
 dnl
@@ -2985,6 +3029,10 @@ _______EOF
  */
 typedef $g_pid_type GPid;
 
+#define GLIB_SYSDEF_AF_UNIX $g_af_unix
+#define GLIB_SYSDEF_AF_INET $g_af_inet
+#define GLIB_SYSDEF_AF_INET6 $g_af_inet6
+
 G_END_DECLS
 
 #endif /* GLIBCONFIG_H */
@@ -3271,6 +3319,10 @@ g_pollhup=$glib_cv_value_POLLHUP
 g_pollerr=$glib_cv_value_POLLERR
 g_pollnval=$glib_cv_value_POLLNVAL
 
+g_af_unix=$glib_cv_value_AF_UNIX
+g_af_inet=$glib_cv_value_AF_INET
+g_af_inet6=$glib_cv_value_AF_INET6
+
 g_stack_grows=$glib_cv_stack_grows
 
 g_have_eilseq=$have_eilseq
@@ -3355,6 +3407,7 @@ gthread/Makefile
 gio/Makefile
 gio/xdgmime/Makefile
 gio/inotify/Makefile
+gio/libasyncns/Makefile
 gio/fen/Makefile
 gio/fam/Makefile
 gio/win32/Makefile
diff --git a/docs/reference/gio/Makefile.am b/docs/reference/gio/Makefile.am
index 43e003f..1cd0cdc 100644
--- a/docs/reference/gio/Makefile.am
+++ b/docs/reference/gio/Makefile.am
@@ -43,11 +43,14 @@ IGNORE_HFILES=				\
 	glocalvfs.h			\
 	gnativevolumemonitor.h		\
 	gpollfilemonitor.h		\
+	gthreadedresolver.h		\
 	gunionvolumemonitor.h		\
 	gunixdrive.h			\
+	gunixresolver.h			\
 	gunixvolume.h			\
 	gvolumeprivate.h		\
 	gwin32appinfo.h			\
+	gwin32resolver.h		\
 	inotify-diag.h			\
 	inotify-helper.h		\
 	inotify-kernel.h		\
@@ -85,7 +88,8 @@ GTKDOC_LIBS = \
 	$(NULL)
 
 # Extra options to supply to gtkdoc-mkdb
-MKDB_OPTIONS = --output-format=xml --sgml-mode --name-space=g
+MKDB_OPTIONS = --output-format=xml --sgml-mode --name-space=g \
+	--ignore-files=libasyncns
 
 # Images to copy into HTML directory
 HTML_IMAGES =			\
diff --git a/docs/reference/gio/gio-docs.xml b/docs/reference/gio/gio-docs.xml
index 46af7fe..0b0208a 100644
--- a/docs/reference/gio/gio-docs.xml
+++ b/docs/reference/gio/gio-docs.xml
@@ -90,6 +90,18 @@
     	<xi:include href="xml/gemblemedicon.xml"/>
     	<xi:include href="xml/gemblem.xml"/>
     </chapter>
+    <chapter id="networking">
+    	<title>Networking</title>
+        <xi:include href="xml/gresolver.xml"/>
+        <xi:include href="xml/ginetaddress.xml"/>
+        <xi:include href="xml/gsocketaddress.xml"/>
+        <xi:include href="xml/ginetsocketaddress.xml"/>
+        <xi:include href="xml/gunixsocketaddress.xml"/>
+        <xi:include href="xml/gsrvtarget.xml"/>
+        <xi:include href="xml/gsocketconnectable.xml"/>
+        <xi:include href="xml/gnetworkaddress.xml"/>
+        <xi:include href="xml/gnetworkservice.xml"/>
+    </chapter>
     <chapter id="utils">   
     	<title>Utilities</title>
         <xi:include href="xml/gfilenamecompleter.xml"/>
diff --git a/docs/reference/gio/gio-sections.txt b/docs/reference/gio/gio-sections.txt
index 391dfaf..8f81a27 100644
--- a/docs/reference/gio/gio-sections.txt
+++ b/docs/reference/gio/gio-sections.txt
@@ -1310,4 +1310,208 @@ g_io_extension_point_set_required_type
 g_io_extension_ref_class
 </SECTION>
 
+<SECTION>
+<FILE>ginetaddress</FILE>
+<TITLE>GInetAddress</TITLE>
+GInetAddress
+g_inet_address_new_from_string
+g_inet_address_new_from_bytes
+g_inet_address_new_any
+g_inet_address_new_loopback
+g_inet_address_to_bytes
+g_inet_address_to_string
+g_inet_address_get_family
+g_inet_address_get_is_any
+g_inet_address_get_is_link_local
+g_inet_address_get_is_loopback
+g_inet_address_get_is_mc_global
+g_inet_address_get_is_mc_link_local
+g_inet_address_get_is_mc_node_local
+g_inet_address_get_is_mc_org_local
+g_inet_address_get_is_mc_site_local
+g_inet_address_get_is_multicast
+g_inet_address_get_is_site_local
+<SUBSECTION Standard>
+GInetAddressClass
+GInetAddressPrivate
+G_INET_ADDRESS
+G_INET_ADDRESS_CLASS
+G_INET_ADDRESS_GET_CLASS
+G_IS_INET_ADDRESS
+G_IS_INET_ADDRESS_CLASS
+G_TYPE_INET_ADDRESS
+<SUBSECTION Private>
+g_inet_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gsocketaddress</FILE>
+<TITLE>GSocketAddress</TITLE>
+GSocketAddress
+GSocketFamily
+g_socket_address_new_from_native
+g_socket_address_get_family
+g_socket_address_to_native
+g_socket_address_get_native_size
+<SUBSECTION Standard>
+GSocketAddressClass
+G_IS_SOCKET_ADDRESS
+G_IS_SOCKET_ADDRESS_CLASS
+G_SOCKET_ADDRESS
+G_SOCKET_ADDRESS_CLASS
+G_SOCKET_ADDRESS_GET_CLASS
+G_TYPE_SOCKET_ADDRESS
+<SUBSECTION Private>
+g_socket_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>ginetsocketaddress</FILE>
+<TITLE>GInetSocketAddress</TITLE>
+GInetSocketAddress
+g_inet_socket_address_new
+g_inet_socket_address_get_address
+g_inet_socket_address_get_port
+<SUBSECTION Standard>
+GInetSocketAddressClass
+GInetSocketAddressPrivate
+G_INET_SOCKET_ADDRESS
+G_INET_SOCKET_ADDRESS_CLASS
+G_INET_SOCKET_ADDRESS_GET_CLASS
+G_IS_INET_SOCKET_ADDRESS
+G_IS_INET_SOCKET_ADDRESS_CLASS
+G_TYPE_INET_SOCKET_ADDRESS
+<SUBSECTION Private>
+g_inet_socket_address_get_type
+</SECTION>
 
+<SECTION>
+<FILE>gunixsocketaddress</FILE>
+<TITLE>GUnixSocketAddress</TITLE>
+GUnixSocketAddress
+g_unix_socket_address_new
+<SUBSECTION Standard>
+GUnixSocketAddressClass
+GUnixSocketAddressPrivate
+G_IS_UNIX_SOCKET_ADDRESS
+G_IS_UNIX_SOCKET_ADDRESS_CLASS
+G_TYPE_UNIX_SOCKET_ADDRESS
+G_UNIX_SOCKET_ADDRESS
+G_UNIX_SOCKET_ADDRESS_CLASS
+G_UNIX_SOCKET_ADDRESS_GET_CLASS
+<SUBSECTION Private>
+g_unix_socket_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gresolver</FILE>
+<TITLE>GResolver</TITLE>
+GResolver
+g_resolver_get_default
+g_resolver_set_default
+g_resolver_lookup_by_name
+g_resolver_lookup_by_name_async
+g_resolver_lookup_by_name_finish
+g_resolver_free_addresses
+g_resolver_lookup_by_address
+g_resolver_lookup_by_address_async
+g_resolver_lookup_by_address_finish
+g_resolver_lookup_service
+g_resolver_lookup_service_async
+g_resolver_lookup_service_finish
+g_resolver_free_targets
+<SUBSECTION>
+G_RESOLVER_ERROR
+GResolverError
+<SUBSECTION Standard>
+GResolverClass
+G_IS_RESOLVER
+G_IS_RESOLVER_CLASS
+G_RESOLVER
+G_RESOLVER_CLASS
+G_RESOLVER_GET_CLASS
+G_TYPE_RESOLVER
+<SUBSECTION Private>
+g_resolver_get_type
+g_resolver_error_quark
+</SECTION>
+
+<SECTION>
+<FILE>gsrvtarget</FILE>
+<TITLE>GSrvTarget</TITLE>
+GSrvTarget
+g_srv_target_new
+g_srv_target_copy
+g_srv_target_free
+g_srv_target_get_hostname
+g_srv_target_get_port
+g_srv_target_get_priority
+g_srv_target_get_weight
+g_srv_target_get_expires
+g_srv_target_array_sort
+<SUBSECTION Standard>
+G_TYPE_SRV_TARGET
+<SUBSECTION Private>
+g_srv_target_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gsocketconnectable</FILE>
+<TITLE>GSocketConnectable</TITLE>
+GSocketConnectable
+GSocketConnectableIface
+g_socket_connectable_get_next
+g_socket_connectable_get_next_async
+g_socket_connectable_get_next_finish
+g_socket_connectable_reset
+<SUBSECTION Standard>
+G_IS_SOCKET_CONNECTABLE
+G_SOCKET_CONNECTABLE
+G_SOCKET_CONNECTABLE_GET_IFACE
+G_TYPE_SOCKET_CONNECTABLE
+<SUBSECTION Private>
+g_socket_connectable_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gnetworkaddress</FILE>
+<TITLE>GNetworkAddress</TITLE>
+GNetworkAddress
+g_network_address_new
+g_network_address_get_hostname
+g_network_address_get_ascii_name
+g_network_address_get_port
+<SUBSECTION Standard>
+GNetworkAddressClass
+GNetworkAddressPrivate
+G_IS_NETWORK_ADDRESS
+G_IS_NETWORK_ADDRESS_CLASS
+G_NETWORK_ADDRESS
+G_NETWORK_ADDRESS_CLASS
+G_NETWORK_ADDRESS_GET_CLASS
+G_TYPE_NETWORK_ADDRESS
+<SUBSECTION Private>
+g_network_address_get_type
+</SECTION>
+
+<SECTION>
+<FILE>gnetworkservice</FILE>
+<TITLE>GNetworkService</TITLE>
+GNetworkService
+g_network_service_new
+g_network_service_get_service
+g_network_service_get_protocol
+g_network_service_get_domain
+g_network_service_get_expires
+<SUBSECTION Standard>
+GNetworkServiceClass
+GNetworkServicePrivate
+G_IS_NETWORK_SERVICE
+G_IS_NETWORK_SERVICE_CLASS
+G_NETWORK_SERVICE
+G_NETWORK_SERVICE_CLASS
+G_NETWORK_SERVICE_GET_CLASS
+G_TYPE_NETWORK_SERVICE
+<SUBSECTION Private>
+g_network_service_get_type
+</SECTION>
diff --git a/docs/reference/gio/gio.types b/docs/reference/gio/gio.types
index c73282a..8fb70f5 100644
--- a/docs/reference/gio/gio.types
+++ b/docs/reference/gio/gio.types
@@ -36,6 +36,8 @@ g_file_type_get_type
 g_filter_input_stream_get_type
 g_filter_output_stream_get_type
 g_icon_get_type
+g_inet_address_get_type
+g_inet_socket_address_get_type
 g_input_stream_get_type
 g_io_error_enum_get_type
 g_io_module_get_type
@@ -50,15 +52,21 @@ g_mount_operation_get_type
 g_mount_operation_result_get_type
 g_mount_unmount_flags_get_type
 g_native_volume_monitor_get_type
+g_network_address_get_type
+g_network_service_get_type
 g_output_stream_get_type
 g_output_stream_splice_flags_get_type
 g_password_save_get_type
+g_resolver_get_type
 g_seekable_get_type
 g_simple_async_result_get_type
+g_socket_address_get_type
+g_socket_connectable_get_type
 g_themed_icon_get_type
 g_unix_input_stream_get_type
 g_unix_mount_monitor_get_type
 g_unix_output_stream_get_type
+g_unix_socket_address_get_type
 g_vfs_get_type
 g_volume_get_type
 g_volume_monitor_get_type
diff --git a/docs/reference/glib/glib-docs.sgml b/docs/reference/glib/glib-docs.sgml
index cef6e8c..4d7c36d 100644
--- a/docs/reference/glib/glib-docs.sgml
+++ b/docs/reference/glib/glib-docs.sgml
@@ -66,6 +66,7 @@
 <!ENTITY glib-Version SYSTEM "xml/version.xml">
 <!ENTITY glib-Uri SYSTEM "xml/gurifuncs.xml">
 <!ENTITY glib-Testing SYSTEM "xml/testing.xml">
+<!ENTITY glib-Hostutils SYSTEM "xml/ghostutils.xml">
 
 <!ENTITY glib-Compiling SYSTEM "compiling.sgml">
 <!ENTITY glib-Building SYSTEM "building.sgml">
@@ -162,6 +163,7 @@ synchronize their operation.
     &glib-Spawn;
     &glib-Fileutils;
     &glib-Uri;
+    &glib-Hostutils;
     &glib-Shell;
     &glib-Option;
     &glib-Pattern-Matching;
diff --git a/docs/reference/glib/glib-sections.txt b/docs/reference/glib/glib-sections.txt
index 6df70cb..4feea78 100644
--- a/docs/reference/glib/glib-sections.txt
+++ b/docs/reference/glib/glib-sections.txt
@@ -2653,3 +2653,16 @@ g_test_log_buffer_push
 g_test_log_buffer_pop
 g_test_log_msg_free
 </SECTION>
+
+
+<SECTION>
+<FILE>ghostutils</FILE>
+<TITLE>Hostname Utilities</TITLE>
+g_hostname_to_ascii
+g_hostname_to_unicode
+<SUBSECTION>
+g_hostname_is_non_ascii
+g_hostname_is_ascii_encoded
+<SUBSECTION>
+g_hostname_is_ip_address
+</SECTION>
diff --git a/docs/reference/glib/tmpl/ghostutils.sgml b/docs/reference/glib/tmpl/ghostutils.sgml
new file mode 100644
index 0000000..b619912
--- /dev/null
+++ b/docs/reference/glib/tmpl/ghostutils.sgml
@@ -0,0 +1,66 @@
+<!-- ##### SECTION Title ##### -->
+Hostname Utilities
+
+<!-- ##### SECTION Short_Description ##### -->
+
+
+<!-- ##### SECTION Long_Description ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### SECTION See_Also ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### SECTION Stability_Level ##### -->
+
+
+<!-- ##### FUNCTION g_hostname_to_ascii ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_to_unicode ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_non_ascii ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_ascii_encoded ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
+<!-- ##### FUNCTION g_hostname_is_ip_address ##### -->
+<para>
+
+</para>
+
+@hostname: 
+@Returns: 
+
+
diff --git a/gio/Makefile.am b/gio/Makefile.am
index be6568f..7e7c2d5 100644
--- a/gio/Makefile.am
+++ b/gio/Makefile.am
@@ -5,7 +5,7 @@ NULL =
 SUBDIRS=
 
 if OS_UNIX
-SUBDIRS += xdgmime
+SUBDIRS += libasyncns xdgmime
 endif
 
 if OS_WIN32_AND_DLL_COMPILATION
@@ -125,13 +125,16 @@ endif
 
 if OS_UNIX
 appinfo_sources += gdesktopappinfo.c gdesktopappinfo.h
-platform_libadd += xdgmime/libxdgmime.la
-platform_deps += xdgmime/libxdgmime.la
+platform_libadd += libasyncns/libasyncns.la xdgmime/libxdgmime.la
+platform_deps += libasyncns/libasyncns.la xdgmime/libxdgmime.la
 unix_sources = \
 	gunixmount.c		\
 	gunixmount.h		\
 	gunixmounts.c 		\
 	gunixmounts.h 		\
+	gunixresolver.c		\
+	gunixresolver.h		\
+	gunixsocketaddress.c	\
 	gunixvolume.c 		\
 	gunixvolume.h 		\
 	gunixvolumemonitor.c 	\
@@ -147,15 +150,18 @@ giounixinclude_HEADERS = \
 	gunixmounts.h 		\
 	gunixinputstream.h 	\
 	gunixoutputstream.h 	\
+	gunixsocketaddress.h	\
 	$(NULL)
 endif
 
 if OS_WIN32
 appinfo_sources += gwin32appinfo.c gwin32appinfo.h
-platform_libadd += -lshlwapi
+platform_libadd += -lshlwapi -lws2_32 -ldnsapi
 win32_sources = \
 	gwin32mount.c \
 	gwin32mount.h \
+	gwin32resolver.c \
+	gwin32resolver.h \
 	gwin32volumemonitor.c \
 	gwin32volumemonitor.h \
 	$(NULL)
@@ -196,6 +202,8 @@ libgio_2_0_la_SOURCES =		\
 	gfilterinputstream.c 	\
 	gfilteroutputstream.c 	\
 	gicon.c 		\
+	ginetaddress.c		\
+	ginetsocketaddress.c	\
 	ginputstream.c 		\
 	gioenums.h		\
 	gioerror.c 		\
@@ -209,12 +217,21 @@ libgio_2_0_la_SOURCES =		\
 	gmountoperation.c 	\
 	gnativevolumemonitor.c 	\
 	gnativevolumemonitor.h 	\
+	gnetworkaddress.c	\
+	gnetworkingprivate.h	\
+	gnetworkservice.c	\
 	goutputstream.c 	\
 	gpollfilemonitor.c 	\
 	gpollfilemonitor.h 	\
+	gresolver.c		\
 	gseekable.c 		\
 	gsimpleasyncresult.c 	\
+	gsocketaddress.c	\
+	gsocketconnectable.c	\
+	gsrvtarget.c		\
 	gthemedicon.c 		\
+	gthreadedresolver.c	\
+	gthreadedresolver.h	\
 	gunionvolumemonitor.c 	\
 	gunionvolumemonitor.h 	\
 	gvfs.c 			\
@@ -299,6 +316,8 @@ gio_headers =			\
 	gfilterinputstream.h 	\
 	gfilteroutputstream.h 	\
 	gicon.h 		\
+	ginetaddress.h		\
+	ginetsocketaddress.h	\
 	ginputstream.h 		\
 	gio.h			\
 	giotypes.h		\
@@ -312,9 +331,15 @@ gio_headers =			\
 	gmemoryoutputstream.h 	\
 	gmountoperation.h 	\
 	gnativevolumemonitor.h 	\
+	gnetworkaddress.h	\
+	gnetworkservice.h	\
 	goutputstream.h 	\
+	gresolver.h		\
 	gseekable.h 		\
 	gsimpleasyncresult.h 	\
+	gsocketaddress.h	\
+	gsocketconnectable.h	\
+	gsrvtarget.h		\
 	gthemedicon.h 		\
 	gvfs.h 			\
 	gvolume.h 		\
diff --git a/gio/ginetaddress.c b/gio/ginetaddress.c
new file mode 100644
index 0000000..aa9d574
--- /dev/null
+++ b/gio/ginetaddress.c
@@ -0,0 +1,718 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+
+#include "ginetaddress.h"
+#include "gioenums.h"
+#include "gioenumtypes.h"
+#include "glibintl.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:ginetaddress
+ * @short_description: An IPv4/IPv6 address
+ *
+ * #GInetAddress represents an IPv4 or IPv6 internet address. Use
+ * g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to
+ * look up the #GInetAddress for a hostname. Use
+ * g_resolver_lookup_by_address() or
+ * g_resolver_lookup_by_address_async() to look up the hostname for a
+ * #GInetAddress.
+ *
+ * To actually connect to a remote host, you will need a
+ * #GInetSocketAddress (which includes a #GInetAddress as well as a
+ * port number).
+ **/
+
+/**
+ * GInetAddress:
+ *
+ * An IPv4 or IPv6 internet address.
+ **/
+
+/* Networking initialization function, called from inside the g_once of
+ * g_inet_address_get_type()
+ */
+static void
+_g_networking_init (void)
+{
+#ifdef G_OS_WIN32
+  WSADATA wsadata;
+  if (WSAStartup (MAKEWORD (2, 0), &wsadata) != 0)
+    g_error ("Windows Sockets could not be initialized");
+#endif
+}
+
+G_DEFINE_TYPE_WITH_CODE (GInetAddress, g_inet_address, G_TYPE_OBJECT,
+			 _g_networking_init ();)
+
+struct _GInetAddressPrivate
+{
+  GSocketFamily family;
+  union {
+    struct in_addr ipv4;
+    struct in6_addr ipv6;
+  } addr;
+};
+
+enum
+{
+  PROP_0,
+  PROP_FAMILY,
+  PROP_BYTES,
+  PROP_IS_ANY,
+  PROP_IS_LOOPBACK,
+  PROP_IS_LINK_LOCAL,
+  PROP_IS_SITE_LOCAL,
+  PROP_IS_MULTICAST,
+  PROP_IS_MC_GLOBAL,
+  PROP_IS_MC_LINK_LOCAL,
+  PROP_IS_MC_NODE_LOCAL,
+  PROP_IS_MC_ORG_LOCAL,
+  PROP_IS_MC_SITE_LOCAL,
+};
+
+static void
+g_inet_address_set_property (GObject      *object,
+			     guint         prop_id,
+			     const GValue *value,
+			     GParamSpec   *pspec)
+{
+  GInetAddress *address = G_INET_ADDRESS (object);
+
+  switch (prop_id) 
+    {
+    case PROP_FAMILY:
+      address->priv->family = g_value_get_enum (value);
+      break;
+
+    case PROP_BYTES:
+      memcpy (&address->priv->addr, g_value_get_pointer (value),
+	      address->priv->family == AF_INET ?
+	      sizeof (address->priv->addr.ipv4) :
+	      sizeof (address->priv->addr.ipv6));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_inet_address_get_property (GObject    *object,
+                             guint       prop_id,
+                             GValue     *value,
+                             GParamSpec *pspec)
+{
+  GInetAddress *address = G_INET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+    case PROP_FAMILY:
+      g_value_set_enum (value, address->priv->family);
+      break;
+
+    case PROP_BYTES:
+      g_value_set_pointer (value, &address->priv->addr);
+      break;
+
+    case PROP_IS_ANY:
+      g_value_set_boolean (value, g_inet_address_get_is_any (address));
+      break;
+
+    case PROP_IS_LOOPBACK:
+      g_value_set_boolean (value, g_inet_address_get_is_loopback (address));
+      break;
+
+    case PROP_IS_LINK_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_link_local (address));
+      break;
+
+    case PROP_IS_SITE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_site_local (address));
+      break;
+
+    case PROP_IS_MULTICAST:
+      g_value_set_boolean (value, g_inet_address_get_is_multicast (address));
+      break;
+
+    case PROP_IS_MC_GLOBAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_global (address));
+      break;
+
+    case PROP_IS_MC_LINK_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_link_local (address));
+      break;
+
+    case PROP_IS_MC_NODE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_node_local (address));
+      break;
+
+    case PROP_IS_MC_ORG_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_org_local (address));
+      break;
+
+    case PROP_IS_MC_SITE_LOCAL:
+      g_value_set_boolean (value, g_inet_address_get_is_mc_site_local (address));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_inet_address_class_init (GInetAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GInetAddressPrivate));
+
+  gobject_class->set_property = g_inet_address_set_property;
+  gobject_class->get_property = g_inet_address_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_FAMILY,
+                                   g_param_spec_enum ("family",
+						      _("Address family"),
+						      _("The address family (IPv4 or IPv6)"),
+						      G_TYPE_SOCKET_FAMILY,
+						      G_SOCKET_FAMILY_INVALID,
+						      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_BYTES,
+                                   g_param_spec_pointer ("bytes",
+							 _("Bytes"),
+							 _("The raw address data"),
+							 G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_ANY,
+                                   g_param_spec_boolean ("is-any",
+                                                         _("Is any"),
+                                                         _("See g_inet_address_get_is_any()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_LINK_LOCAL,
+                                   g_param_spec_boolean ("is-link-local",
+                                                         _("Is link-local"),
+                                                         _("See g_inet_address_get_is_link_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_LOOPBACK,
+                                   g_param_spec_boolean ("is-loopback",
+                                                         _("Is loopback"),
+                                                         _("See g_inet_address_get_is_loopback()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_SITE_LOCAL,
+                                   g_param_spec_boolean ("is-site-local",
+                                                         _("Is site-local"),
+                                                         _("See g_inet_address_get_is_site_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MULTICAST,
+                                   g_param_spec_boolean ("is-multicast",
+                                                         _("Is multicast"),
+                                                         _("See g_inet_address_get_is_multicast()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_GLOBAL,
+                                   g_param_spec_boolean ("is-mc-global",
+                                                         _("Is multicast global"),
+                                                         _("See g_inet_address_get_is_mc_global()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_LINK_LOCAL,
+                                   g_param_spec_boolean ("is-mc-link-local",
+                                                         _("Is multicast link-local"),
+                                                         _("See g_inet_address_get_is_mc_link_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_NODE_LOCAL,
+                                   g_param_spec_boolean ("is-mc-node-local",
+                                                         _("Is multicast node-local"),
+                                                         _("See g_inet_address_get_is_mc_node_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_ORG_LOCAL,
+                                   g_param_spec_boolean ("is-mc-org-local",
+                                                         _("Is multicast org-local"),
+                                                         _("See g_inet_address_get_is_mc_org_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+
+  g_object_class_install_property (gobject_class, PROP_IS_MC_SITE_LOCAL,
+                                   g_param_spec_boolean ("is-mc-site-local",
+                                                         _("Is multicast site-local"),
+                                                         _("See g_inet_address_get_is_mc_site_local()"),
+                                                         FALSE,
+                                                         G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+}
+
+static void
+g_inet_address_init (GInetAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_INET_ADDRESS,
+                                               GInetAddressPrivate);
+}
+
+/**
+ * g_inet_address_new_from_string:
+ * @string: a string representation of an IP address
+ *
+ * Parses @string as an IP address and creates a new #GInetAddress.
+ *
+ * Returns: a new #GInetAddress corresponding to @string, or %NULL if
+ * @string could not be parsed.
+ */
+GInetAddress *
+g_inet_address_new_from_string (const gchar *string)
+{
+#ifdef G_OS_WIN32
+  struct sockaddr_storage sa;
+  struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
+  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&sa;
+  gint len;
+#else /* !G_OS_WIN32 */
+  struct in_addr in_addr;
+  struct in6_addr in6_addr;
+#endif
+
+  /* Make sure _g_networking_init() has been called */
+  (void) g_inet_address_get_type ();
+
+#ifdef G_OS_WIN32
+  memset (&sa, 0, sizeof (sa));
+  len = sizeof (sa);
+  if (WSAStringToAddress ((LPTSTR) string, AF_INET, NULL, (LPSOCKADDR) &sa, &len) == 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&sin->sin_addr, AF_INET);
+  else if (WSAStringToAddress ((LPTSTR) string, AF_INET6, NULL, (LPSOCKADDR) &sa, &len) == 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&sin6->sin6_addr, AF_INET6);
+
+#else /* !G_OS_WIN32 */
+
+  if (inet_pton (AF_INET, string, &in_addr) > 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&in_addr, AF_INET);
+  else if (inet_pton (AF_INET6, string, &in6_addr) > 0)
+    return g_inet_address_new_from_bytes ((guint8 *)&in6_addr, AF_INET6);
+#endif
+
+  return NULL;
+}
+
+#define G_INET_ADDRESS_FAMILY_IS_VALID(family) ((family) == AF_INET || (family) == AF_INET6)
+
+/**
+ * g_inet_address_new_from_bytes:
+ * @bytes: raw address data
+ * @family: the address family of @bytes
+ *
+ * Creates a new #GInetAddress from the given @family and @bytes.
+ * @bytes should be 4 bytes for %G_INET_ADDRESS_IPV4 and 16 bytes for
+ * %G_INET_ADDRESS_IPV6.
+ *
+ * Returns: a new #GInetAddress corresponding to @family and @bytes.
+ */
+GInetAddress *
+g_inet_address_new_from_bytes (const guint8         *bytes,
+			       GSocketFamily  family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  return g_object_new (G_TYPE_INET_ADDRESS,
+		       "family", family,
+		       "bytes", bytes,
+		       NULL);
+}
+
+/**
+ * g_inet_address_new_loopback:
+ * @family: the address family
+ *
+ * Creates a #GInetAddress for the loopback address for @family.
+ *
+ * Returns: a new #GInetAddress corresponding to the loopback address
+ * for @family.
+ */
+GInetAddress *
+g_inet_address_new_loopback (GSocketFamily family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  if (family == AF_INET)
+    {    
+      guint8 addr[4] = {127, 0, 0, 1};
+
+      return g_inet_address_new_from_bytes (addr, family);
+    }
+  else
+    return g_inet_address_new_from_bytes (in6addr_loopback.s6_addr, family);
+}
+
+/**
+ * g_inet_address_new_any:
+ * @family: the address family
+ *
+ * Creates a #GInetAddress for the "any" address (unassigned/"don't
+ * care") for @family.
+ *
+ * Returns: a new #GInetAddress corresponding to the "any" address
+ * for @family.
+ */
+GInetAddress *
+g_inet_address_new_any (GSocketFamily family)
+{
+  g_return_val_if_fail (G_INET_ADDRESS_FAMILY_IS_VALID (family), NULL);
+
+  if (family == AF_INET)
+    {    
+      guint8 addr[4] = {0, 0, 0, 0};
+
+      return g_inet_address_new_from_bytes (addr, family);
+    }
+  else
+    return g_inet_address_new_from_bytes (in6addr_any.s6_addr, family);
+}
+
+
+/**
+ * g_inet_address_to_string:
+ * @address: a #GInetAddress
+ *
+ * Converts @address to string form.
+ *
+ * Returns: a representation of @address as a string, which should be
+ * freed after use.
+ */
+gchar *
+g_inet_address_to_string (GInetAddress *address)
+{
+  gchar buffer[INET6_ADDRSTRLEN];
+#ifdef G_OS_WIN32
+  DWORD buflen = sizeof (buffer), addrlen;
+  struct sockaddr_storage sa;
+  struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
+  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&sa;
+#endif
+
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+#ifdef G_OS_WIN32
+  sa.ss_family = address->priv->family;
+  if (address->priv->family == AF_INET)
+    {
+      addrlen = sizeof (*sin);
+      memcpy (&sin->sin_addr, &address->priv->addr.ipv4,
+	      sizeof (sin->sin_addr));
+      sin->sin_port = 0;
+    }
+  else
+    {
+      addrlen = sizeof (*sin6);
+      memcpy (&sin6->sin6_addr, &address->priv->addr.ipv6,
+	      sizeof (sin6->sin6_addr));
+      sin6->sin6_port = 0;
+    }
+  if (WSAAddressToString ((LPSOCKADDR) &sa, addrlen, NULL, buffer, &buflen) != 0)
+    return NULL;
+
+#else /* !G_OS_WIN32 */
+
+  if (address->priv->family == AF_INET)
+    inet_ntop (AF_INET, &address->priv->addr.ipv4, buffer, sizeof (buffer));
+  else
+    inet_ntop (AF_INET6, &address->priv->addr.ipv6, buffer, sizeof (buffer));
+#endif
+
+  return g_strdup (buffer);
+}
+
+/**
+ * g_inet_address_to_bytes:
+ * @address: a #GInetAddress
+ *
+ * Gets the raw binary address data from @address.
+ *
+ * Returns: a pointer to an internal array of the bytes in @address,
+ * which should not be modified, stored, or freed.
+ */
+const guint8 *
+g_inet_address_to_bytes (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+  return (guint8 *)&address->priv->addr;
+}
+
+/**
+ * g_inet_address_get_family:
+ * @address: a #GInetAddress
+ *
+ * Gets @address's family
+ *
+ * Returns: @address's family
+ */
+GSocketFamily
+g_inet_address_get_family (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  return address->priv->family;
+}
+
+/**
+ * g_inet_address_get_is_any:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is the "any" address for its family.
+ *
+ * Returns: %TRUE if @address is the "any" address for its family.
+ */
+gboolean
+g_inet_address_get_is_any (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      return addr4 == INADDR_ANY;
+    }
+  else
+    return IN6_IS_ADDR_UNSPECIFIED (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_loopback:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is the loopback address for its family.
+ *
+ * Returns: %TRUE if @address is the loopback address for its family.
+ */
+gboolean
+g_inet_address_get_is_loopback (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 127.0.0.0/8 */
+      return ((addr4 & 0xff000000) == 0x7f000000);
+    }
+  else
+    return IN6_IS_ADDR_LOOPBACK (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_link_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a link-local address (that is, if it
+ * identifies a host on a local network that is not connected to the
+ * Internet).
+ *
+ * Returns: %TRUE if @address is a link-local address.
+ */
+gboolean
+g_inet_address_get_is_link_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 169.254.0.0/16 */
+      return ((addr4 & 0xffff0000) == 0xa9fe0000);
+    }
+  else
+    return IN6_IS_ADDR_LINKLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_site_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a site-local address such as 10.0.0.1
+ * (that is, the address identifies a host on a local network that can
+ * not be reached directly from the Internet, but which may have
+ * outgoing Internet connectivity via a NAT or firewall).
+ *
+ * Returns: %TRUE if @address is a site-local address.
+ */
+gboolean
+g_inet_address_get_is_site_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      /* 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 */
+      return ((addr4 & 0xff000000) == 0x0a000000 ||
+	      (addr4 & 0xfff00000) == 0xac100000 ||
+	      (addr4 & 0xffff0000) == 0xc0a80000);
+    }
+  else
+    return IN6_IS_ADDR_SITELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_multicast:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a multicast address.
+ *
+ * Returns: %TRUE if @address is a multicast address.
+ */
+gboolean
+g_inet_address_get_is_multicast (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    {
+      guint32 addr4 = g_ntohl (address->priv->addr.ipv4.s_addr);
+
+      return IN_MULTICAST (addr4);
+    }
+  else
+    return IN6_IS_ADDR_MULTICAST (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_global:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a global multicast address.
+ *
+ * Returns: %TRUE if @address is a global multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_global (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_GLOBAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_link_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a link-local multicast address.
+ *
+ * Returns: %TRUE if @address is a link-local multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_link_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_LINKLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_node_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a node-local multicast address.
+ *
+ * Returns: %TRUE if @address is a node-local multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_node_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_NODELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_org_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is an organization-local multicast address.
+ *
+ * Returns: %TRUE if @address is an organization-local multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_org_local  (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_ORGLOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+/**
+ * g_inet_address_get_is_mc_site_local:
+ * @address: a #GInetAddress
+ *
+ * Tests whether @address is a site-local multicast address.
+ *
+ * Returns: %TRUE if @address is a site-local multicast address.
+ */
+gboolean
+g_inet_address_get_is_mc_site_local (GInetAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), FALSE);
+
+  if (address->priv->family == AF_INET)
+    return FALSE;
+  else
+    return IN6_IS_ADDR_MC_SITELOCAL (&address->priv->addr.ipv6.s6_addr);
+}
+
+#define __G_INET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/ginetaddress.h b/gio/ginetaddress.h
new file mode 100644
index 0000000..2ef8bc0
--- /dev/null
+++ b/gio/ginetaddress.h
@@ -0,0 +1,101 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_INET_ADDRESS_H__
+#define __G_INET_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_INET_ADDRESS         (g_inet_address_get_type ())
+#define G_INET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_ADDRESS, GInetAddress))
+#define G_INET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_ADDRESS, GInetAddressClass))
+#define G_IS_INET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_ADDRESS))
+#define G_IS_INET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_ADDRESS))
+#define G_INET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_ADDRESS, GInetAddressClass))
+
+typedef struct _GInetAddressClass   GInetAddressClass;
+typedef struct _GInetAddressPrivate GInetAddressPrivate;
+
+struct _GInetAddress
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GInetAddressPrivate *priv;
+};
+
+struct _GInetAddressClass
+{
+  GObjectClass parent_class;
+
+  gchar *        (*to_string) (GInetAddress *address);
+  const guint8 * (*to_bytes)  (GInetAddress *address);
+};
+
+GType                 g_inet_address_get_type             (void) G_GNUC_CONST;
+
+GInetAddress *        g_inet_address_new_from_string      (const gchar   *string);
+
+GInetAddress *        g_inet_address_new_from_bytes       (const guint8  *bytes,
+						           GSocketFamily  family);
+
+GInetAddress *        g_inet_address_new_loopback         (GSocketFamily  family);
+
+GInetAddress *        g_inet_address_new_any              (GSocketFamily  family);
+
+gchar *               g_inet_address_to_string            (GInetAddress  *address);
+
+const guint8 *        g_inet_address_to_bytes             (GInetAddress  *address);
+
+GSocketFamily         g_inet_address_get_family           (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_any           (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_loopback      (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_link_local    (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_site_local    (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_multicast     (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_global     (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_link_local (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_node_local (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_org_local  (GInetAddress  *address);
+
+gboolean              g_inet_address_get_is_mc_site_local (GInetAddress  *address);
+
+G_END_DECLS
+
+#endif /* __G_INET_ADDRESS_H__ */
+
diff --git a/gio/ginetsocketaddress.c b/gio/ginetsocketaddress.c
new file mode 100644
index 0000000..f3bfa1d
--- /dev/null
+++ b/gio/ginetsocketaddress.c
@@ -0,0 +1,300 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+#include <string.h>
+
+#include "ginetsocketaddress.h"
+#include "ginetaddress.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:ginetsocketaddress
+ * @short_description: Internet socket addresses
+ *
+ * An IPv4 or IPv6 socket address; that is, the combination of a
+ * #GInetAddress and a port number.
+ **/
+
+/**
+ * GInetSocketAddress:
+ *
+ * An IPv4 or IPv6 socket address, corresponding to a <type>struct
+ * sockaddr_in</type> or <type>struct sockaddr_in6</type>.
+ **/
+G_DEFINE_TYPE (GInetSocketAddress, g_inet_socket_address, G_TYPE_SOCKET_ADDRESS);
+
+enum {
+  PROP_0,
+  PROP_ADDRESS,
+  PROP_PORT
+};
+
+struct _GInetSocketAddressPrivate
+{
+  GInetAddress *address;
+  guint16       port;
+};
+
+static void
+g_inet_socket_address_finalize (GObject *object)
+{
+  GInetSocketAddress *address G_GNUC_UNUSED = G_INET_SOCKET_ADDRESS (object);
+
+  if (G_OBJECT_CLASS (g_inet_socket_address_parent_class)->finalize)
+    (*G_OBJECT_CLASS (g_inet_socket_address_parent_class)->finalize) (object);
+}
+
+static void
+g_inet_socket_address_dispose (GObject *object)
+{
+  GInetSocketAddress *address G_GNUC_UNUSED = G_INET_SOCKET_ADDRESS (object);
+
+  g_object_unref (address->priv->address);
+
+  if (G_OBJECT_CLASS (g_inet_socket_address_parent_class)->dispose)
+    (*G_OBJECT_CLASS (g_inet_socket_address_parent_class)->dispose) (object);
+}
+
+static void
+g_inet_socket_address_get_property (GObject    *object,
+                                    guint       prop_id,
+                                    GValue     *value,
+                                    GParamSpec *pspec)
+{
+  GInetSocketAddress *address = G_INET_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_ADDRESS:
+        g_value_set_object (value, address->priv->address);
+        break;
+
+      case PROP_PORT:
+        g_value_set_uint (value, address->priv->port);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_inet_socket_address_set_property (GObject      *object,
+                                    guint         prop_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
+{
+  GInetSocketAddress *address = G_INET_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_ADDRESS:
+        address->priv->address = g_object_ref (g_value_get_object (value));
+        break;
+
+      case PROP_PORT:
+        address->priv->port = (guint16) g_value_get_uint (value);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static GSocketFamily
+g_inet_socket_address_get_family (GSocketAddress *address)
+{
+  GInetSocketAddress *addr;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+
+  return g_inet_address_get_family (addr->priv->address);
+}
+
+static gssize
+g_inet_socket_address_get_native_size (GSocketAddress *address)
+{
+  GInetSocketAddress *addr;
+  GSocketFamily family;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+  family = g_inet_address_get_family (addr->priv->address);
+
+  if (family == AF_INET)
+    return sizeof (struct sockaddr_in);
+  else if (family == AF_INET6)
+    return sizeof (struct sockaddr_in6);
+  else
+    return -1;
+}
+
+static gboolean
+g_inet_socket_address_to_native (GSocketAddress *address,
+                                 gpointer        dest,
+				 gsize           destlen)
+{
+  GInetSocketAddress *addr;
+  GSocketFamily family;
+
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  addr = G_INET_SOCKET_ADDRESS (address);
+  family = g_inet_address_get_family (addr->priv->address);
+
+  if (family == AF_INET)
+    {
+      struct sockaddr_in *sock = (struct sockaddr_in *) dest;
+
+      if (destlen < sizeof (*sock))
+	return FALSE;
+
+      sock->sin_family = AF_INET;
+      sock->sin_port = g_htons (addr->priv->port);
+      memcpy (&(sock->sin_addr.s_addr), g_inet_address_to_bytes (addr->priv->address), sizeof (sock->sin_addr));
+      memset (sock->sin_zero, 0, sizeof (sock->sin_zero));
+      return TRUE;
+    }
+  else if (family == AF_INET6)
+    {
+      struct sockaddr_in6 *sock = (struct sockaddr_in6 *) dest;
+
+      if (destlen < sizeof (*sock))
+	return FALSE;
+
+      memset (sock, 0, sizeof (sock));
+      sock->sin6_family = AF_INET6;
+      sock->sin6_port = g_htons (addr->priv->port);
+      memcpy (&(sock->sin6_addr.s6_addr), g_inet_address_to_bytes (addr->priv->address), sizeof (sock->sin6_addr));
+      return TRUE;
+    }
+  else
+    return FALSE;
+}
+
+static void
+g_inet_socket_address_class_init (GInetSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GSocketAddressClass *gsocketaddress_class = G_SOCKET_ADDRESS_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GInetSocketAddressPrivate));
+
+  gobject_class->finalize = g_inet_socket_address_finalize;
+  gobject_class->dispose = g_inet_socket_address_dispose;
+  gobject_class->set_property = g_inet_socket_address_set_property;
+  gobject_class->get_property = g_inet_socket_address_get_property;
+
+  gsocketaddress_class->get_family = g_inet_socket_address_get_family;
+  gsocketaddress_class->to_native = g_inet_socket_address_to_native;
+  gsocketaddress_class->get_native_size = g_inet_socket_address_get_native_size;
+
+  g_object_class_install_property (gobject_class, PROP_ADDRESS,
+                                   g_param_spec_object ("address",
+                                                        "address",
+                                                        "address",
+                                                        G_TYPE_INET_ADDRESS,
+                                                        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK));
+
+  g_object_class_install_property (gobject_class, PROP_PORT,
+                                   g_param_spec_uint ("port",
+                                                      "port",
+                                                      "port",
+                                                      0,
+                                                      65535,
+                                                      0,
+                                                      G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK));
+}
+
+static void
+g_inet_socket_address_init (GInetSocketAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_INET_SOCKET_ADDRESS,
+                                               GInetSocketAddressPrivate);
+
+  address->priv->address = NULL;
+  address->priv->port = 0;
+}
+
+/**
+ * g_inet_socket_address_new:
+ * @address: a #GInetAddress
+ * @port: a port number
+ *
+ * Creates a new #GInetSocketAddress for @address and @port.
+ *
+ * Returns: a new #GInetSocketAddress
+ */
+GSocketAddress *
+g_inet_socket_address_new (GInetAddress *address,
+                           guint16       port)
+{
+  return g_object_new (G_TYPE_INET_SOCKET_ADDRESS,
+		       "address", address,
+		       "port", port,
+		       NULL);
+}
+
+/**
+ * g_inet_socket_address_get_address:
+ * @address: a #GInetSocketAddress
+ *
+ * Gets @address's #GInetAddress.
+ *
+ * Returns: the #GInetAddress for @address, which must be
+ * g_object_ref()'d if it will be stored
+ */
+GInetAddress *
+g_inet_socket_address_get_address (GInetSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), NULL);
+
+  return address->priv->address;
+}
+
+/**
+ * g_inet_socket_address_get_port:
+ * @address: a #GInetSocketAddress
+ *
+ * Gets @address's port.
+ *
+ * Returns: the port for @address
+ */
+guint16
+g_inet_socket_address_get_port (GInetSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_INET_SOCKET_ADDRESS (address), 0);
+
+  return address->priv->port;
+}
+
+#define __G_INET_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/ginetsocketaddress.h b/gio/ginetsocketaddress.h
new file mode 100644
index 0000000..b455ac5
--- /dev/null
+++ b/gio/ginetsocketaddress.h
@@ -0,0 +1,69 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_INET_SOCKET_ADDRESS_H__
+#define __G_INET_SOCKET_ADDRESS_H__
+
+#include <gio/gsocketaddress.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_INET_SOCKET_ADDRESS         (g_inet_socket_address_get_type ())
+#define G_INET_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddress))
+#define G_INET_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
+#define G_IS_INET_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_INET_SOCKET_ADDRESS))
+#define G_IS_INET_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_INET_SOCKET_ADDRESS))
+#define G_INET_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass))
+
+typedef struct _GInetSocketAddressClass   GInetSocketAddressClass;
+typedef struct _GInetSocketAddressPrivate GInetSocketAddressPrivate;
+
+struct _GInetSocketAddress
+{
+  GSocketAddress parent_instance;
+
+  /*< private >*/
+  GInetSocketAddressPrivate *priv;
+};
+
+struct _GInetSocketAddressClass
+{
+  GSocketAddressClass parent_class;
+};
+
+GType           g_inet_socket_address_get_type    (void) G_GNUC_CONST;
+
+GSocketAddress *g_inet_socket_address_new         (GInetAddress       *address,
+						   guint16             port);
+
+GInetAddress *  g_inet_socket_address_get_address (GInetSocketAddress *address);
+
+guint16         g_inet_socket_address_get_port    (GInetSocketAddress *address);
+
+G_END_DECLS
+
+#endif /* __G_INET_SOCKET_ADDRESS_H__ */
diff --git a/gio/gio.h b/gio/gio.h
index e3a0b14..e61b8e4 100644
--- a/gio/gio.h
+++ b/gio/gio.h
@@ -49,6 +49,8 @@
 #include <gio/gfilterinputstream.h>
 #include <gio/gfilteroutputstream.h>
 #include <gio/gicon.h>
+#include <gio/ginetaddress.h>
+#include <gio/ginetsocketaddress.h>
 #include <gio/ginputstream.h>
 #include <gio/gioenums.h>
 #include <gio/gioenumtypes.h>
@@ -61,9 +63,15 @@
 #include <gio/gmount.h>
 #include <gio/gmountoperation.h>
 #include <gio/gnativevolumemonitor.h>
+#include <gio/gnetworkaddress.h>
+#include <gio/gnetworkservice.h>
 #include <gio/goutputstream.h>
+#include <gio/gresolver.h>
 #include <gio/gseekable.h>
 #include <gio/gsimpleasyncresult.h>
+#include <gio/gsocketaddress.h>
+#include <gio/gsocketconnectable.h>
+#include <gio/gsrvtarget.h>
 #include <gio/gthemedicon.h>
 #include <gio/gvfs.h>
 #include <gio/gvolume.h>
diff --git a/gio/gio.symbols b/gio/gio.symbols
index f73e9ff..55e111c 100644
--- a/gio/gio.symbols
+++ b/gio/gio.symbols
@@ -831,6 +831,8 @@ g_output_stream_splice_flags_get_type G_GNUC_CONST
 g_ask_password_flags_get_type G_GNUC_CONST
 g_password_save_get_type G_GNUC_CONST
 g_emblem_origin_get_type G_GNUC_CONST
+g_socket_family_get_type G_GNUC_CONST
+g_resolver_error_get_type G_GNUC_CONST
 #endif
 #endif
 
@@ -855,3 +857,136 @@ g_emblem_get_origin
 #endif
 #endif
 
+#if IN_HEADER(__G_INET_ADDRESS_H__)
+#if IN_FILE(__G_INET_ADDRESS_C__)
+g_inet_address_new_from_string
+g_inet_address_new_from_bytes
+g_inet_address_new_any
+g_inet_address_new_loopback
+g_inet_address_get_family
+g_inet_address_get_type G_GNUC_CONST
+g_inet_address_get_is_any
+g_inet_address_get_is_link_local
+g_inet_address_get_is_loopback
+g_inet_address_get_is_mc_global
+g_inet_address_get_is_mc_link_local
+g_inet_address_get_is_mc_node_local
+g_inet_address_get_is_mc_org_local
+g_inet_address_get_is_mc_site_local
+g_inet_address_get_is_multicast
+g_inet_address_get_is_site_local
+g_inet_address_to_bytes
+g_inet_address_to_string
+#endif
+#endif
+
+#if IN_HEADER(__G_INET_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_INET_SOCKET_ADDRESS_C__)
+g_inet_socket_address_get_address
+g_inet_socket_address_get_port
+g_inet_socket_address_get_type G_GNUC_CONST
+g_inet_socket_address_new
+#endif
+#endif
+
+#if IN_HEADER(__G_UNIX_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_UNIX_SOCKET_ADDRESS_C__)
+#ifdef G_OS_UNIX
+g_unix_socket_address_get_type G_GNUC_CONST
+g_unix_socket_address_new
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_SOCKET_ADDRESS_H__)
+#if IN_FILE(__G_SOCKET_ADDRESS_C__)
+g_socket_address_new_from_native
+g_socket_address_get_type G_GNUC_CONST
+g_socket_address_get_family
+g_socket_address_get_native_size
+g_socket_address_to_native
+#endif
+#endif
+
+#if IN_HEADER(__G_RESOLVER_H__)
+#if IN_FILE(__G_RESOLVER_C__)
+g_resolver_error_quark
+g_resolver_get_type G_GNUC_CONST
+g_resolver_get_default
+g_resolver_set_default
+g_resolver_lookup_by_name
+g_resolver_lookup_by_name_async
+g_resolver_lookup_by_name_finish
+g_resolver_lookup_by_address
+g_resolver_lookup_by_address_async
+g_resolver_lookup_by_address_finish
+g_resolver_lookup_service
+g_resolver_lookup_service_async
+g_resolver_lookup_service_finish
+#endif
+#endif
+
+#if IN_HEADER(__G_THREADED_RESOLVER_H__)
+#if IN_FILE(__G_THREADED_RESOLVER_C__)
+g_threaded_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+
+#if IN_HEADER(__G_UNIX_RESOLVER_H__)
+#if IN_FILE(__G_UNIX_RESOLVER_C__)
+#ifdef G_OS_UNIX
+g_unix_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_WIN32_RESOLVER_H__)
+#if IN_FILE(__G_WIN32_RESOLVER_C__)
+#ifdef G_OS_WIN32
+g_win32_resolver_get_type G_GNUC_CONST
+#endif
+#endif
+#endif
+
+#if IN_HEADER(__G_SRV_TARGET_H__)
+#if IN_FILE(__G_SRV_TARGET_C__)
+g_srv_target_get_type G_GNUC_CONST
+g_srv_target_new
+g_srv_target_copy
+g_srv_target_free
+g_srv_target_get_hostname
+g_srv_target_get_port
+g_srv_target_get_priority
+g_srv_target_get_weight
+g_srv_target_get_expires
+g_srv_target_list_sort
+#endif
+#endif
+
+#if IN_HEADER(__G_NETWORK_ADDRESS_H__)
+#if IN_FILE(__G_NETWORK_ADDRESS_C__)
+g_network_address_get_type G_GNUC_CONST
+g_network_address_get_hostname
+g_network_address_get_port
+g_network_address_new
+#endif
+#endif
+
+#if IN_HEADER(__G_NETWORK_SERVICE_H__)
+#if IN_FILE(__G_NETWORK_SERVICE_C__)
+g_network_service_get_type G_GNUC_CONST
+g_network_service_get_service
+g_network_service_get_protocol
+g_network_service_get_domain
+g_network_service_new
+#endif
+#endif
+
+#if IN_HEADER(__G_SOCKET_CONNECTABLE_H__)
+#if IN_FILE(__G_SOCKET_CONNECTABLE_C__)
+g_socket_connectable_get_next
+g_socket_connectable_get_next_async
+g_socket_connectable_get_next_finish
+g_socket_connectable_get_type G_GNUC_CONST
+#endif
+#endif
diff --git a/gio/gioenums.h b/gio/gioenums.h
index 3bb50ff..f06c567 100644
--- a/gio/gioenums.h
+++ b/gio/gioenums.h
@@ -476,6 +476,41 @@ typedef enum  {
   G_EMBLEM_ORIGIN_TAG
 } GEmblemOrigin;
 
+/**
+ * GResolverError:
+ * @G_RESOLVER_ERROR_NOT_FOUND: the requested name/address/service was not found
+ * @G_RESOLVER_ERROR_TEMPORARY_FAILURE: the requested information could not be looked up due to a network error or similar problem
+ * @G_RESOLVER_ERROR_INTERNAL: unknown error
+ *
+ * An error code used with %G_RESOLVER_ERROR in a #GError returned
+ * from a #GResolver routine.
+ */
+typedef enum {
+  G_RESOLVER_ERROR_NOT_FOUND,
+  G_RESOLVER_ERROR_TEMPORARY_FAILURE,
+  G_RESOLVER_ERROR_INTERNAL
+} GResolverError;
+
+/**
+ * GSocketFamily:
+ * @G_SOCKET_FAMILY_INVALID: no address family
+ * @G_SOCKET_FAMILY_IPV4: the IPv4 family
+ * @G_SOCKET_FAMILY_IPV6: the IPv6 family
+ * @G_SOCKET_FAMILY_UNIX: the UNIX domain family
+ *
+ * The protocol family of a #GSocketAddress. (These values are
+ * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
+ * if available.)
+ */
+typedef enum {
+  G_SOCKET_FAMILY_INVALID,
+  G_SOCKET_FAMILY_IPV4	= GLIB_SYSDEF_AF_INET,
+  G_SOCKET_FAMILY_IPV6	= GLIB_SYSDEF_AF_INET6
+#ifdef GLIB_SYSDEF_AF_UNIX
+                                              ,
+  G_SOCKET_FAMILY_UNIX = GLIB_SYSDEF_AF_UNIX
+#endif
+} GSocketFamily;
 
 G_END_DECLS
 
diff --git a/gio/giotypes.h b/gio/giotypes.h
index 981c195..6b08331 100644
--- a/gio/giotypes.h
+++ b/gio/giotypes.h
@@ -75,6 +75,8 @@ typedef struct _GFilenameCompleter            GFilenameCompleter;
 
 
 typedef struct _GIcon                         GIcon; /* Dummy typedef */
+typedef struct _GInetAddress                  GInetAddress;
+typedef struct _GInetSocketAddress            GInetSocketAddress;
 typedef struct _GInputStream                  GInputStream;
 typedef struct _GIOModule                     GIOModule;
 typedef struct _GIOExtensionPoint             GIOExtensionPoint;
@@ -97,9 +99,15 @@ typedef struct _GMemoryOutputStream           GMemoryOutputStream;
  **/
 typedef struct _GMount                        GMount; /* Dummy typedef */
 typedef struct _GMountOperation               GMountOperation;
+typedef struct _GNetworkAddress               GNetworkAddress;
+typedef struct _GNetworkService               GNetworkService;
 typedef struct _GOutputStream                 GOutputStream;
+typedef struct _GResolver                     GResolver;
 typedef struct _GSeekable                     GSeekable;
 typedef struct _GSimpleAsyncResult            GSimpleAsyncResult;
+typedef struct _GSocketAddress                GSocketAddress;
+typedef struct _GSocketConnectable            GSocketConnectable;
+typedef struct _GSrvTarget                    GSrvTarget;
 typedef struct _GThemedIcon                   GThemedIcon;
 typedef struct _GVfs                          GVfs; /* Dummy typedef */
 
diff --git a/gio/gnetworkaddress.c b/gio/gnetworkaddress.c
new file mode 100644
index 0000000..9548df6
--- /dev/null
+++ b/gio/gnetworkaddress.c
@@ -0,0 +1,465 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gnetworkaddress.h"
+#include "gasyncresult.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gresolver.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketconnectable.h"
+
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gnetworkaddress
+ * @short_description: a #GSocketConnectable for resolving hostnames
+ * @include: gio/gio.h
+ *
+ * #GNetworkAddress provides an easy way to resolve a hostname and
+ * then attempt to connect to that host, handling the possibility of
+ * multiple IP addresses and multiple address families.
+ *
+ * |[
+ * MyConnectionType *
+ * connect_to_host (const char    *hostname,
+ *                  guint16        port,
+ *                  GCancellable  *cancellable,
+ *                  GError       **error)
+ * {
+ *   MyConnection *conn = NULL;
+ *   GSocketConnectable *addr;
+ *   GSocketAddress *sockaddr;
+ *   GError *conn_error = NULL;
+ *
+ *   addr = g_network_address_new ("www.gnome.org", 80);
+ *
+ *   /<!-- -->* Try each sockaddr until we succeed. Record the first
+ *    * connection error, but not any further ones (since they'll probably
+ *    * be basically the same as the first).
+ *    *<!-- -->/
+ *   while (!conn && (sockaddr = g_socket_connectable_get_next (addr, cancellable, error))
+ *     {
+ *       conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
+ *       g_object_unref (sockaddr);
+ *     }
+ *   g_object_unref (addr);
+ *
+ *   if (conn)
+ *     {
+ *       if (conn_error)
+ *         {
+ *           /<!-- -->* We couldn't connect to the first address, but we succeeded
+ *            * in connecting to a later address.
+ *            *<!-- -->/
+ *           g_error_free (conn_error);
+ *         }
+ *       return conn;
+ *     }
+ *   else if (error)
+ *     {
+ *       /<!-- -->* Either the initial lookup failed, or else the caller
+ *        * cancelled us.
+ *        *<!-- -->/
+ *       if (conn_error)
+ *         g_error_free (conn_error);
+ *       return NULL;
+ *     }
+ *   else
+ *     {
+ *       g_error_propagate (error, conn_error);
+ *       return NULL;
+ *     }
+ * }
+ * ]|
+ **/
+
+/**
+ * GNetworkAddress:
+ *
+ * A #GSocketConnectable for resolving a hostname and connecting to
+ * that host.
+ **/
+
+struct _GNetworkAddressPrivate {
+  gchar *hostname;
+  guint16 port;
+
+  GList *sockaddrs, *iter;
+};
+
+enum {
+  PROP_0,
+  PROP_HOSTNAME,
+  PROP_PORT,
+};
+
+static void g_network_address_set_property (GObject      *object,
+                                            guint         prop_id,
+                                            const GValue *value,
+                                            GParamSpec   *pspec);
+static void g_network_address_get_property (GObject      *object,
+                                            guint         prop_id,
+                                            GValue       *value,
+                                            GParamSpec   *pspec);
+
+static void            g_network_address_connectable_iface_init      (GSocketConnectableIface *iface);
+static GSocketAddress *g_network_address_connectable_get_next        (GSocketConnectable  *connectable,
+                                                                      GCancellable        *cancellable,
+                                                                      GError             **error);
+static void            g_network_address_connectable_get_next_async  (GSocketConnectable   *connectable,
+                                                                      GCancellable         *cancellable,
+                                                                      GAsyncReadyCallback   callback,
+                                                                      gpointer              user_data);
+static GSocketAddress *g_network_address_connectable_get_next_finish (GSocketConnectable   *connectable,
+                                                                      GAsyncResult         *result,
+                                                                      GError              **error);
+static void            g_network_address_connectable_reset           (GSocketConnectable  *connectable);
+
+G_DEFINE_TYPE_WITH_CODE (GNetworkAddress, g_network_address, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+                                                g_network_address_connectable_iface_init))
+
+static void
+g_network_address_finalize (GObject *object)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  g_free (addr->priv->hostname);
+
+  if (addr->priv->sockaddrs)
+    {
+      GList *a;
+
+      for (a = addr->priv->sockaddrs; a; a = a->next)
+        g_object_unref (a->data);
+      g_list_free (addr->priv->sockaddrs);
+    }
+
+  G_OBJECT_CLASS (g_network_address_parent_class)->finalize (object);
+}
+
+static void
+g_network_address_class_init (GNetworkAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GNetworkAddressPrivate));
+
+  gobject_class->set_property = g_network_address_set_property;
+  gobject_class->get_property = g_network_address_get_property;
+  gobject_class->finalize = g_network_address_finalize;
+
+  g_object_class_install_property (gobject_class, PROP_HOSTNAME,
+                                   g_param_spec_string ("hostname",
+                                                        P_("Hostname"),
+                                                        P_("Hostname to resolver"),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_PORT,
+                                   g_param_spec_uint ("port",
+                                                      P_("Port"),
+                                                      P_("Network port"),
+                                                      0, 65535, 0,
+                                                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+g_network_address_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next        = g_network_address_connectable_get_next;
+  connectable_iface->get_next_async  = g_network_address_connectable_get_next_async;
+  connectable_iface->get_next_finish = g_network_address_connectable_get_next_finish;
+  connectable_iface->reset           = g_network_address_connectable_reset;
+}
+
+static void
+g_network_address_init (GNetworkAddress *addr)
+{
+  addr->priv = G_TYPE_INSTANCE_GET_PRIVATE (addr, G_TYPE_NETWORK_ADDRESS,
+                                            GNetworkAddressPrivate);
+}
+
+static void
+g_network_address_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  switch (prop_id) 
+    {
+    case PROP_HOSTNAME:
+      if (addr->priv->hostname)
+        g_free (addr->priv->hostname);
+      addr->priv->hostname = g_value_dup_string (value);
+      break;
+
+    case PROP_PORT:
+      addr->priv->port = g_value_get_uint (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_address_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (object);
+
+  switch (prop_id)
+    { 
+    case PROP_HOSTNAME:
+      g_value_set_string (value, addr->priv->hostname);
+      break;
+
+    case PROP_PORT:
+      g_value_set_uint (value, addr->priv->port);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_address_set_addresses (GNetworkAddress *addr,
+                                 GList           *addresses)
+{
+  GList *a;
+  GSocketAddress *sockaddr;
+
+  g_return_if_fail (addresses != NULL && addr->priv->sockaddrs == NULL);
+
+  for (a = addresses; a; a = a->next)
+    {
+      sockaddr = g_inet_socket_address_new (a->data, addr->priv->port);
+      addr->priv->sockaddrs = g_list_prepend (addr->priv->sockaddrs, sockaddr);
+      g_object_unref (a->data);
+    }
+  g_list_free (addresses);
+  addr->priv->sockaddrs = g_list_reverse (addr->priv->sockaddrs);
+}
+
+/**
+ * g_network_address_new:
+ * @hostname: the hostname
+ * @port: the port
+ *
+ * Creates a new #GSocketConnectable for connecting to the given
+ * @hostname and @port.
+ *
+ * Return value: the new #GNetworkAddress
+ *
+ * Since: 2.20
+ **/
+GSocketConnectable *
+g_network_address_new (const gchar *hostname,
+                       guint16      port)
+{
+  return g_object_new (G_TYPE_NETWORK_ADDRESS,
+                       "hostname", hostname,
+                       "port", port,
+                       NULL);
+}
+
+/**
+ * g_network_address_get_hostname:
+ * @addr: a #GNetworkAddress
+ *
+ * Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
+ * depending on what @addr was created with.
+ *
+ * Return value: @addr's hostname
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_address_get_hostname (GNetworkAddress *addr)
+{
+  g_return_val_if_fail (G_IS_NETWORK_ADDRESS (addr), NULL);
+
+  return addr->priv->hostname;
+}
+
+/**
+ * g_network_address_get_port:
+ * @addr: a #GNetworkAddress
+ *
+ * Gets @addr's port number
+ *
+ * Return value: @addr's port (which may be %0)
+ *
+ * Since: 2.20
+ **/
+guint16
+g_network_address_get_port (GNetworkAddress *addr)
+{
+  g_return_val_if_fail (G_IS_NETWORK_ADDRESS (addr), 0);
+
+  return addr->priv->port;
+}
+
+static GSocketAddress *
+g_network_address_connectable_get_next (GSocketConnectable  *connectable,
+                                        GCancellable        *cancellable,
+                                        GError             **error)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+  GSocketAddress *sockaddr;
+
+  if (!addr->priv->sockaddrs)
+    {
+      GResolver *resolver = g_resolver_get_default ();
+      GList *addresses;
+
+      addresses = g_resolver_lookup_by_name (resolver,
+                                             addr->priv->hostname,
+                                             cancellable, error);
+      g_object_unref (resolver);
+
+      if (!addresses)
+        return NULL;
+
+      g_network_address_set_addresses (addr, addresses);
+      addr->priv->iter = addr->priv->sockaddrs;
+    }
+
+  if (!addr->priv->iter)
+    return NULL;
+  else
+    {
+      sockaddr = addr->priv->iter->data;
+      addr->priv->iter = addr->priv->iter->next;
+      return g_object_ref (sockaddr);
+    }
+}
+
+static void
+got_addresses (GObject      *source_object,
+               GAsyncResult *result,
+               gpointer      user_data)
+{
+  GResolver *resolver = G_RESOLVER (source_object);
+  GSimpleAsyncResult *simple = user_data;
+  GNetworkAddress *addr;
+  GList *addresses;
+  GError *error = NULL;
+  GSocketAddress *sockaddr;
+
+  addr = (GNetworkAddress *)g_async_result_get_source_object (G_ASYNC_RESULT (simple));
+  /* get_source_object adds a ref */
+  g_object_unref (addr);
+
+  addresses = g_resolver_lookup_by_name_finish (resolver, result, &error);
+  if (error)
+    {
+      g_simple_async_result_set_from_error (simple, error);
+      g_error_free (error);
+    }
+  else
+    {
+      g_network_address_set_addresses (addr, addresses);
+      addr->priv->iter = addr->priv->sockaddrs;
+    }
+
+  sockaddr = g_network_address_connectable_get_next (G_SOCKET_CONNECTABLE (addr), NULL, NULL);
+  if (sockaddr)
+    g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+
+  g_simple_async_result_complete (simple);
+  g_object_unref (simple);
+}
+
+static void
+g_network_address_connectable_get_next_async (GSocketConnectable   *connectable,
+                                              GCancellable         *cancellable,
+                                              GAsyncReadyCallback   callback,
+                                              gpointer              user_data)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+  GSimpleAsyncResult *simple;
+  GSocketAddress *sockaddr;
+
+  simple = g_simple_async_result_new (G_OBJECT (connectable),
+                                      callback, user_data,
+                                      g_network_address_connectable_get_next_async);
+
+  if (!addr->priv->sockaddrs)
+    {
+      GResolver *resolver = g_resolver_get_default ();
+
+      g_resolver_lookup_by_name_async (resolver,
+                                       addr->priv->hostname,
+                                       cancellable,
+                                       got_addresses, simple);
+      g_object_unref (resolver);
+    }
+  else
+    {
+      sockaddr = g_network_address_connectable_get_next (connectable, NULL, NULL);
+      if (sockaddr)
+        g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+
+      g_simple_async_result_complete_in_idle (simple);
+      g_object_unref (simple);
+    }
+}
+
+static GSocketAddress *
+g_network_address_connectable_get_next_finish (GSocketConnectable  *connectable,
+                                               GAsyncResult        *result,
+                                               GError             **error)
+{
+  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+static void
+g_network_address_connectable_reset (GSocketConnectable  *connectable)
+{
+  GNetworkAddress *addr = G_NETWORK_ADDRESS (connectable);
+
+  addr->priv->iter = addr->priv->sockaddrs;
+}
+
+#define __G_NETWORK_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gnetworkaddress.h b/gio/gnetworkaddress.h
new file mode 100644
index 0000000..47dba10
--- /dev/null
+++ b/gio/gnetworkaddress.h
@@ -0,0 +1,65 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_NETWORK_ADDRESS_H__
+#define __G_NETWORK_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_NETWORK_ADDRESS         (g_network_address_get_type ())
+#define G_NETWORK_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddress))
+#define G_NETWORK_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
+#define G_IS_NETWORK_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_ADDRESS))
+#define G_IS_NETWORK_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_ADDRESS))
+#define G_NETWORK_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass))
+
+typedef struct _GNetworkAddressClass   GNetworkAddressClass;
+typedef struct _GNetworkAddressPrivate GNetworkAddressPrivate;
+
+struct _GNetworkAddress
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GNetworkAddressPrivate *priv;
+};
+
+struct _GNetworkAddressClass
+{
+  GObjectClass parent_class;
+
+};
+
+GType               g_network_address_get_type       (void) G_GNUC_CONST;
+
+GSocketConnectable *g_network_address_new            (const gchar      *hostname,
+						      guint16           port);
+const gchar        *g_network_address_get_hostname   (GNetworkAddress  *addr);
+guint16             g_network_address_get_port       (GNetworkAddress  *addr);
+
+G_END_DECLS
+
+#endif /* __G_NETWORK_ADDRESS_H__ */
diff --git a/gio/gnetworkingprivate.h b/gio/gnetworkingprivate.h
new file mode 100644
index 0000000..c41f598
--- /dev/null
+++ b/gio/gnetworkingprivate.h
@@ -0,0 +1,85 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_NETWORKINGPRIVATE_H__
+#define __G_NETWORKINGPRIVATE_H__
+
+#ifdef G_OS_WIN32
+
+#define WINVER 0x0501 // FIXME?
+#include <winsock2.h>
+#undef interface
+#include <ws2tcpip.h>
+#include <windns.h>
+
+#else /* !G_OS_WIN32 */
+
+#define BIND_4_COMPAT
+
+#include <arpa/inet.h>
+#include <arpa/nameser.h>
+/* We're supposed to define _GNU_SOURCE to get EAI_NODATA, but that
+ * won't actually work since <features.h> has already been included at
+ * this point. So we define __USE_GNU instead.
+ */
+#define __USE_GNU
+#include <netdb.h>
+#undef __USE_GNU
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <resolv.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#endif
+
+G_BEGIN_DECLS
+
+extern struct addrinfo _g_resolver_addrinfo_hints;
+
+GList *_g_resolver_addresses_from_addrinfo (const char       *hostname,
+					    struct addrinfo  *res,
+					    gint              gai_retval,
+					    GError          **error);
+
+void   _g_resolver_address_to_sockaddr     (GInetAddress            *address,
+					    struct sockaddr_storage *sa,
+					    gsize                   *sa_len);
+char  *_g_resolver_name_from_nameinfo      (GInetAddress     *address,
+					    const gchar      *name,
+					    gint              gni_retval,
+					    GError          **error);
+
+#if defined(G_OS_UNIX)
+GList *_g_resolver_targets_from_res_query  (const gchar      *rrname,
+					    guchar           *answer,
+					    gint              len,
+					    gint              herr,
+					    GError          **error);
+#elif defined(G_OS_WIN32)
+GList *_g_resolver_targets_from_DnsQuery   (const gchar      *rrname,
+					    DNS_STATUS        status,
+					    DNS_RECORD       *results,
+					    GError          **error);
+#endif
+
+G_END_DECLS
+
+#endif /* __G_NETWORKINGPRIVATE_H__ */
diff --git a/gio/gnetworkservice.c b/gio/gnetworkservice.c
new file mode 100644
index 0000000..b23619b
--- /dev/null
+++ b/gio/gnetworkservice.c
@@ -0,0 +1,610 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gnetworkservice.h"
+#include "gcancellable.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gresolver.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketconnectable.h"
+#include "gsrvtarget.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gnetworkservice
+ * @short_description: a #GSocketConnectable for resolving SRV records
+ * @include: gio/gio.h
+ *
+ * Like #GNetworkAddress does with hostnames, #GNetworkService
+ * provides an easy way to resolve a SRV record, and then attempt to
+ * connect to one of the hosts that implements that service, handling
+ * service priority/weighting, multiple IP addresses, and multiple
+ * address families.
+ *
+ * See #GSrvTarget for more information about SRV records.
+ **/
+
+/**
+ * GNetworkService:
+ *
+ * A #GSocketConnectable for resolving a SRV record and connecting to
+ * that service.
+ **/
+
+struct _GNetworkServicePrivate
+{
+  gchar *service, *protocol, *domain;
+
+  GResolver *resolver;
+  GList *targets, *target_iter;
+  GList *addrs, *addr_iter;
+
+  GSimpleAsyncResult *next_result;
+  GCancellable *cancellable;
+  GError *iter_error;
+};
+
+enum {
+  PROP_0,
+  PROP_SERVICE,
+  PROP_PROTOCOL,
+  PROP_DOMAIN,
+};
+
+static void g_network_service_set_property (GObject      *object,
+                                            guint         prop_id,
+                                            const GValue *value,
+                                            GParamSpec   *pspec);
+static void g_network_service_get_property (GObject      *object,
+                                            guint         prop_id,
+                                            GValue       *value,
+                                            GParamSpec   *pspec);
+
+static void            g_network_service_connectable_iface_init      (GSocketConnectableIface *iface);
+static GSocketAddress *g_network_service_connectable_get_next        (GSocketConnectable  *connectable,
+                                                                      GCancellable        *cancellable,
+                                                                      GError             **error);
+static void            g_network_service_connectable_get_next_async  (GSocketConnectable   *connectable,
+                                                                      GCancellable         *cancellable,
+                                                                      GAsyncReadyCallback   callback,
+                                                                      gpointer              user_data);
+static GSocketAddress *g_network_service_connectable_get_next_finish (GSocketConnectable   *connectable,
+                                                                      GAsyncResult         *result,
+                                                                      GError              **error);
+static void            g_network_service_connectable_reset           (GSocketConnectable  *connectable);
+
+G_DEFINE_TYPE_WITH_CODE (GNetworkService, g_network_service, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+                                                g_network_service_connectable_iface_init))
+
+static void
+g_network_service_finalize (GObject *object)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  g_free (srv->priv->service);
+  g_free (srv->priv->protocol);
+  g_free (srv->priv->domain);
+
+  if (srv->priv->targets)
+    g_resolver_free_targets (srv->priv->targets);
+
+  g_object_unref (srv->priv->resolver);
+  g_network_service_connectable_reset ((GSocketConnectable *)srv);
+
+  G_OBJECT_CLASS (g_network_service_parent_class)->finalize (object);
+}
+
+static void
+g_network_service_class_init (GNetworkServiceClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GNetworkServicePrivate));
+
+  gobject_class->set_property = g_network_service_set_property;
+  gobject_class->get_property = g_network_service_get_property;
+  gobject_class->finalize = g_network_service_finalize;
+
+  g_object_class_install_property (gobject_class, PROP_SERVICE,
+                                   g_param_spec_string ("service",
+                                                        P_("Service"),
+                                                        P_("Service name, eg \"ldap\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_PROTOCOL,
+                                   g_param_spec_string ("protocol",
+                                                        P_("Protocol"),
+                                                        P_("Network protocol, eg \"tcp\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+  g_object_class_install_property (gobject_class, PROP_DOMAIN,
+                                   g_param_spec_string ("domain",
+                                                        P_("domain"),
+                                                        P_("Network domain, eg, \"example.com\""),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+g_network_service_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next        = g_network_service_connectable_get_next;
+  connectable_iface->get_next_async  = g_network_service_connectable_get_next_async;
+  connectable_iface->get_next_finish = g_network_service_connectable_get_next_finish;
+  connectable_iface->reset           = g_network_service_connectable_reset;
+}
+
+static void
+g_network_service_init (GNetworkService *srv)
+{
+  srv->priv = G_TYPE_INSTANCE_GET_PRIVATE (srv, G_TYPE_NETWORK_SERVICE,
+                                           GNetworkServicePrivate);
+  srv->priv->resolver = g_resolver_get_default ();
+}
+
+static void
+g_network_service_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  switch (prop_id) 
+    {
+    case PROP_SERVICE:
+      srv->priv->service = g_value_dup_string (value);
+      break;
+
+    case PROP_PROTOCOL:
+      srv->priv->protocol = g_value_dup_string (value);
+      break;
+
+    case PROP_DOMAIN:
+      srv->priv->domain = g_value_dup_string (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+static void
+g_network_service_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (object);
+
+  switch (prop_id)
+    { 
+    case PROP_SERVICE:
+      g_value_set_string (value, g_network_service_get_service (srv));
+      break;
+
+    case PROP_PROTOCOL:
+      g_value_set_string (value, g_network_service_get_protocol (srv));
+      break;
+
+    case PROP_DOMAIN:
+      g_value_set_string (value, g_network_service_get_domain (srv));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+
+}
+
+/**
+ * g_network_service_new:
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ *
+ * Creates a new #GNetworkService representing the given @service,
+ * @protocol, and @domain. This will initially be unresolved; use the
+ * #GSocketConnectable interface to resolve it.
+ *
+ * Return value: a new #GNetworkService
+ *
+ * Since: 2.20
+ **/
+GSocketConnectable *
+g_network_service_new (const gchar *service,
+                       const gchar *protocol,
+                       const gchar *domain)
+{
+  return g_object_new (G_TYPE_NETWORK_SERVICE,
+                       "service", service,
+                       "protocol", protocol,
+                       "domain", domain,
+                       NULL);
+}
+
+/**
+ * g_network_service_get_service:
+ * @srv: a #GNetworkService
+ *
+ * Gets @srv's service name (eg, "ldap").
+ *
+ * Return value: @srv's service name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_service (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->service;
+}
+
+/**
+ * g_network_service_get_protocol:
+ * @srv: a #GNetworkService
+ *
+ * Gets @srv's protocol name (eg, "tcp").
+ *
+ * Return value: @srv's protocol name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_protocol (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->protocol;
+}
+
+/**
+ * g_network_service_get_domain:
+ * @srv: a #GNetworkService
+ *
+ * Gets the domain that @srv serves. This might be either UTF-8 or
+ * ASCII-encoded, depending on what @srv was created with.
+ *
+ * Return value: @srv's domain name
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_network_service_get_domain (GNetworkService *srv)
+{
+  g_return_val_if_fail (G_IS_NETWORK_SERVICE (srv), NULL);
+
+  return srv->priv->domain;
+}
+
+static GSocketAddress *
+g_network_service_connectable_get_next (GSocketConnectable  *connectable,
+                                        GCancellable        *cancellable,
+                                        GError             **error)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+  GSrvTarget *target;
+  GSocketAddress *sockaddr;
+
+  /* If we haven't yet resolved srv, do that */
+  if (!srv->priv->targets)
+    {
+      GList *targets;
+
+      targets = g_resolver_lookup_service (srv->priv->resolver,
+                                           srv->priv->service,
+                                           srv->priv->protocol,
+                                           srv->priv->domain,
+                                           cancellable, error);
+      if (!targets)
+        return NULL;
+
+      srv->priv->targets = targets;
+      srv->priv->target_iter = srv->priv->targets;
+    }
+
+  /* Make sure we have a set of resolved addresses for the current
+   * target. When resolving the first target, we save the GError, if
+   * any. If any later target succeeds, we'll free the earlier error,
+   * but if we get to the last target without any of them resolving,
+   * we return that initial error.
+   */
+  do
+    {
+      /* Return if we're out of targets. */
+      if (!srv->priv->target_iter)
+        {
+          if (srv->priv->iter_error)
+            {
+              g_propagate_error (error, srv->priv->iter_error);
+              srv->priv->iter_error = NULL;
+            }
+          return NULL;
+        }
+      target = srv->priv->target_iter->data;
+
+      /* If we haven't resolved the addrs for the current target, do that */
+      if (!srv->priv->addrs)
+        {
+          GError **error_p;
+
+          if (srv->priv->target_iter == srv->priv->targets)
+            error_p = &srv->priv->iter_error;
+          else
+            error_p = NULL;
+          srv->priv->addrs = g_resolver_lookup_by_name (srv->priv->resolver,
+                                                        g_srv_target_get_hostname (target),
+                                                        cancellable, error_p);
+          if (g_cancellable_set_error_if_cancelled (cancellable, error))
+            return NULL;
+
+          if (srv->priv->addrs)
+            {
+              srv->priv->addr_iter = srv->priv->addrs;
+              if (srv->priv->iter_error)
+                {
+                  g_error_free (srv->priv->iter_error);
+                  srv->priv->iter_error = NULL;
+                }
+            }
+          else
+            {
+              /* Try the next target */
+              srv->priv->target_iter = srv->priv->target_iter->next;
+            }
+        }
+    }
+  while (!srv->priv->addrs);
+
+  /* Return the next address for this target. If it's the last one,
+   * advance the target counter.
+   */
+  sockaddr = g_inet_socket_address_new (srv->priv->addr_iter->data,
+                                        g_srv_target_get_port (target));
+  srv->priv->addr_iter = srv->priv->addr_iter->next;
+
+  if (!srv->priv->addr_iter)
+    {
+      g_resolver_free_addresses (srv->priv->addrs);
+      srv->priv->addrs = NULL;
+      srv->priv->target_iter = srv->priv->target_iter->next;
+    }
+
+  return sockaddr;
+}
+
+static void get_next_async_resolved_targets   (GObject         *source_object,
+                                               GAsyncResult    *result,
+                                               gpointer         user_data);
+static void get_next_async_have_targets       (GNetworkService *srv);
+static void get_next_async_resolved_addresses (GObject         *source_object,
+                                               GAsyncResult    *result,
+                                               gpointer         user_data);
+static void get_next_async_have_addresses     (GNetworkService *srv);
+
+/* The async version is basically the same as the sync, except we have
+ * to split it into multiple functions.
+ */
+static void
+g_network_service_connectable_get_next_async (GSocketConnectable  *connectable,
+                                              GCancellable        *cancellable,
+                                              GAsyncReadyCallback  callback,
+                                              gpointer             user_data)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+
+  g_return_if_fail (srv->priv->next_result == NULL);
+
+  srv->priv->next_result = g_simple_async_result_new (G_OBJECT (connectable),
+                                                      callback, user_data,
+                                                      g_network_service_connectable_get_next_async);
+  srv->priv->cancellable = cancellable;
+
+  /* If we haven't yet resolved srv, do that */
+  if (!srv->priv->targets)
+    {
+      g_resolver_lookup_service_async (srv->priv->resolver,
+                                       srv->priv->service,
+                                       srv->priv->protocol,
+                                       srv->priv->domain,
+                                       cancellable,
+                                       get_next_async_resolved_targets,
+                                       srv);
+    }
+  else
+    get_next_async_have_targets (srv);
+}
+
+static void
+get_next_async_resolved_targets (GObject      *source_object,
+                                 GAsyncResult *result,
+                                 gpointer      user_data)
+{
+  GNetworkService *srv = user_data;
+  GError *error = NULL;
+
+  srv->priv->targets = g_resolver_lookup_service_finish (srv->priv->resolver,
+                                                         result, &error);
+  if (error)
+    {
+      GSimpleAsyncResult *simple = srv->priv->next_result;
+
+      srv->priv->next_result = NULL;
+      g_simple_async_result_set_from_error (simple, error);
+      g_error_free (error);
+      g_simple_async_result_complete (simple);
+      g_object_unref (simple);
+      return;
+    }
+
+  srv->priv->target_iter = srv->priv->targets;
+  get_next_async_have_targets (srv);
+}
+
+static void
+get_next_async_have_targets (GNetworkService *srv)
+{
+  GSrvTarget *target;
+
+  /* Get the current target, check if we're already done. */
+  if (!srv->priv->target_iter)
+    {
+      if (srv->priv->iter_error)
+        {
+          g_simple_async_result_set_from_error (srv->priv->next_result, srv->priv->iter_error);
+          g_error_free (srv->priv->iter_error);
+          srv->priv->iter_error = NULL;
+        }
+      g_simple_async_result_complete_in_idle (srv->priv->next_result);
+      g_object_unref (srv->priv->next_result);
+      srv->priv->next_result = NULL;
+      return;
+    }
+  target = srv->priv->target_iter->data;
+
+  /* If we haven't resolved the addrs for the current target, do that */
+  if (!srv->priv->addrs)
+    {
+      g_resolver_lookup_by_name_async (srv->priv->resolver,
+                                       g_srv_target_get_hostname (target),
+                                       srv->priv->cancellable,
+                                       get_next_async_resolved_addresses,
+                                       srv);
+    }
+  else
+    get_next_async_have_addresses (srv);
+}
+
+static void
+get_next_async_resolved_addresses (GObject      *source_object,
+                                   GAsyncResult *result,
+                                   gpointer      user_data)
+{
+  GNetworkService *srv = user_data;
+  GError *error = NULL;
+
+  srv->priv->addrs = g_resolver_lookup_by_name_finish (srv->priv->resolver, result, &error);
+  if (srv->priv->addrs)
+    {
+      srv->priv->addr_iter = srv->priv->addrs;
+      if (srv->priv->iter_error)
+        {
+          g_error_free (srv->priv->iter_error);
+          srv->priv->iter_error = NULL;
+        }
+      get_next_async_have_addresses (srv);
+    }
+  else
+    {
+      if (g_cancellable_is_cancelled (srv->priv->cancellable))
+        {
+          GSimpleAsyncResult *simple = srv->priv->next_result;
+
+          srv->priv->next_result = NULL;
+          g_simple_async_result_set_from_error (srv->priv->next_result, error);
+          g_error_free (error);
+          g_simple_async_result_complete (simple);
+          g_object_unref (simple);
+        }
+      else
+        {
+          if (srv->priv->target_iter == srv->priv->targets)
+            srv->priv->iter_error = error;
+          else
+            g_error_free (error);
+
+          /* Try the next target */
+          srv->priv->target_iter = srv->priv->target_iter->next;
+          get_next_async_have_targets (srv);
+        }
+    }
+}
+
+static void
+get_next_async_have_addresses (GNetworkService *srv)
+{
+  GSocketAddress *sockaddr;
+  GSimpleAsyncResult *simple = srv->priv->next_result;
+
+  /* Return the next address for this target. If it's the last one,
+   * advance the target counter.
+   */
+  sockaddr = g_inet_socket_address_new (srv->priv->addr_iter->data,
+                                        g_srv_target_get_port (srv->priv->target_iter->data));
+
+  srv->priv->addr_iter = srv->priv->addr_iter->next;
+  if (!srv->priv->addr_iter)
+    {
+      g_resolver_free_addresses (srv->priv->addrs);
+      srv->priv->addrs = NULL;
+      srv->priv->target_iter = srv->priv->target_iter->next;
+    }
+
+  srv->priv->next_result = NULL;
+  g_simple_async_result_set_op_res_gpointer (simple, sockaddr, g_object_unref);
+  g_simple_async_result_complete_in_idle (simple);
+  g_object_unref (simple);
+}
+
+static GSocketAddress *
+g_network_service_connectable_get_next_finish (GSocketConnectable  *connectable,
+                                               GAsyncResult        *result,
+                                               GError             **error)
+{
+  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+static void
+g_network_service_connectable_reset (GSocketConnectable  *connectable)
+{
+  GNetworkService *srv = G_NETWORK_SERVICE (connectable);
+
+  g_resolver_free_addresses (srv->priv->addrs);
+  srv->priv->addrs = NULL;
+  srv->priv->target_iter = srv->priv->targets;
+  if (srv->priv->iter_error)
+    {
+      g_error_free (srv->priv->iter_error);
+      srv->priv->iter_error = NULL;
+    }
+}
+
+#define __G_NETWORK_SERVICE_C__
+#include "gioaliasdef.c"
diff --git a/gio/gnetworkservice.h b/gio/gnetworkservice.h
new file mode 100644
index 0000000..b1a754b
--- /dev/null
+++ b/gio/gnetworkservice.h
@@ -0,0 +1,69 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_NETWORK_SERVICE_H__
+#define __G_NETWORK_SERVICE_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_NETWORK_SERVICE         (g_network_service_get_type ())
+#define G_NETWORK_SERVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_NETWORK_SERVICE, GNetworkService))
+#define G_NETWORK_SERVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
+#define G_IS_NETWORK_SERVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_NETWORK_SERVICE))
+#define G_IS_NETWORK_SERVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_NETWORK_SERVICE))
+#define G_NETWORK_SERVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_NETWORK_SERVICE, GNetworkServiceClass))
+
+typedef struct _GNetworkServiceClass   GNetworkServiceClass;
+typedef struct _GNetworkServicePrivate GNetworkServicePrivate;
+
+struct _GNetworkService
+{
+  GObject parent_instance;
+
+  /*< private >*/
+  GNetworkServicePrivate *priv;
+};
+
+struct _GNetworkServiceClass
+{
+  GObjectClass parent_class;
+
+};
+
+GType                g_network_service_get_type      (void) G_GNUC_CONST;
+
+GSocketConnectable  *g_network_service_new           (const gchar     *service,
+						      const gchar     *protocol,
+						      const gchar     *domain);
+
+const gchar         *g_network_service_get_service   (GNetworkService *srv);
+const gchar         *g_network_service_get_protocol  (GNetworkService *srv);
+const gchar         *g_network_service_get_domain    (GNetworkService *srv);
+
+G_END_DECLS
+
+#endif /* __G_NETWORK_SERVICE_H__ */
+
diff --git a/gio/gresolver.c b/gio/gresolver.c
new file mode 100644
index 0000000..ef046bc
--- /dev/null
+++ b/gio/gresolver.c
@@ -0,0 +1,865 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gresolver.h"
+#include "gnetworkingprivate.h"
+#include "gasyncresult.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gsimpleasyncresult.h"
+#include "gsrvtarget.h"
+
+#ifdef G_OS_UNIX
+#include "gunixresolver.h"
+#endif
+#ifdef G_OS_WIN32
+#include "gwin32resolver.h"
+#endif
+
+#include <stdlib.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gresolver
+ * @short_description: Asynchronous and cancellable DNS resolver
+ * @include: gio/gio.h
+ *
+ * #GResolver provides cancellable synchronous and asynchronous DNS
+ * resolution, for hostnames (g_resolver_lookup_by_address(),
+ * g_resolver_lookup_by_name() and their async variants) and SRV
+ * (service) records (g_resolver_lookup_service()).
+ *
+ * #GNetworkAddress and #GNetworkService provide wrappers around
+ * #GResolver functionality that also implement #GSocketConnectable,
+ * making it easy to connect to a remote host/service.
+ **/
+
+/**
+ * GResolver:
+ *
+ * The object that handles DNS resolution. Use g_resolver_get_default()
+ * to get the default resolver.
+ */
+G_DEFINE_TYPE (GResolver, g_resolver, G_TYPE_OBJECT)
+
+static void
+g_resolver_class_init (GResolverClass *resolver_class)
+{
+  /* Make sure _g_networking_init() has been called */
+  (void) g_inet_address_get_type ();
+
+  /* Initialize _g_resolver_addrinfo_hints */
+#ifdef AI_ADDRCONFIG
+  _g_resolver_addrinfo_hints.ai_flags |= AI_ADDRCONFIG;
+#endif
+  /* These two don't actually matter, they just get copied into the
+   * returned addrinfo structures (and then we ignore them). But if
+   * we leave them unset, we'll get back duplicate answers.
+   */
+  _g_resolver_addrinfo_hints.ai_socktype = SOCK_STREAM;
+  _g_resolver_addrinfo_hints.ai_protocol = IPPROTO_TCP;
+}
+
+static void
+g_resolver_init (GResolver *resolver)
+{
+  ;
+}
+
+static GResolver *default_resolver;
+
+/**
+ * g_resolver_get_default:
+ *
+ * Gets the default #GResolver. You should unref it when you are done
+ * with it. #GResolver may use its reference count as a hint about how
+ * many threads/processes, etc it should allocate for concurrent DNS
+ * resolutions.
+ *
+ * Return value: the #GResolver.
+ *
+ * Since: 2.20
+ **/
+GResolver *
+g_resolver_get_default (void)
+{
+  if (!default_resolver)
+    {
+      if (g_thread_supported ())
+        default_resolver = g_object_new (G_TYPE_THREADED_RESOLVER, NULL);
+      else
+        {
+#if defined(G_OS_UNIX)
+          default_resolver = g_object_new (G_TYPE_UNIX_RESOLVER, NULL);
+#elif defined(G_OS_WIN32)
+          default_resolver = g_object_new (G_TYPE_WIN32_RESOLVER, NULL);
+#endif
+        }
+    }
+
+  return g_object_ref (default_resolver);
+}
+
+/**
+ * g_resolver_set_default:
+ * @resolver: the new default #GResolver
+ *
+ * Sets @resolver to be the application's default resolver (reffing
+ * @resolver, and unreffing the previous default resolver, if any).
+ * Future calls to g_resolver_get_default() will return this resolver.
+ *
+ * This can be used if an applications wants to perform any sort of
+ * DNS caching or "pinning"; it can implement its own #GResolver that
+ * calls the original default resolver for DNS operations, and
+ * implements its own cache policies on top of that, and then set
+ * itself as the default resolver for all later code to use.
+ **/
+void
+g_resolver_set_default (GResolver *resolver)
+{
+  if (default_resolver)
+    g_object_unref (default_resolver);
+  default_resolver = g_object_ref (resolver);
+}
+
+
+/**
+ * g_resolver_lookup_by_name:
+ * @resolver: a #GResolver
+ * @hostname: the hostname to look up
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously resolves @hostname to determine its associated IP
+ * address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
+ * the textual form of an IP address (in which case this just becomes
+ * a wrapper around g_inet_address_new_from_string()).
+ *
+ * On success, g_resolver_lookup_by_name() will return a #GList of
+ * #GInetAddress, sorted in order of preference. (That is, you should
+ * attempt to connect to the first address first, then the second if
+ * the first fails, etc.) You must unref each address and free the
+ * list when you are done with it.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to a
+ * value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * If you are planning to connect to a socket on the resolved IP
+ * address, it may be easier to create a #GNetworkAddress and use its
+ * #GSocketConnectable interface.
+ *
+ * Return value: a #GList of #GInetAddress, or %NULL on error. You
+ * must unref each of the addresses and free the list when you are
+ * done with it. (You can use g_resolver_free_addresses() to do this.)
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_by_name (GResolver     *resolver,
+                           const gchar   *hostname,
+                           GCancellable  *cancellable,
+                           GError       **error)
+{
+  GInetAddress *addr;
+  GList *addrs;
+  gchar *ascii_hostname = NULL;
+
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (hostname != NULL, NULL);
+
+  /* Check if @hostname is just an IP address */
+  addr = g_inet_address_new_from_string (hostname);
+  if (addr)
+    return g_list_append (NULL, addr);
+
+  if (g_hostname_is_non_ascii (hostname))
+    hostname = ascii_hostname = g_hostname_to_ascii (hostname);
+
+  addrs = G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name (resolver, hostname, cancellable, error);
+
+  g_free (ascii_hostname);
+  return addrs;
+}
+
+/**
+ * g_resolver_lookup_by_name_async:
+ * @resolver: a #GResolver
+ * @hostname: the hostname to look up the address of
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously resolving @hostname to determine its
+ * associated IP address(es), and eventually calls @callback, which
+ * must call g_resolver_lookup_by_name_finish() to get the result. See
+ * g_resolver_lookup_by_name() for more details.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_by_name_async (GResolver           *resolver,
+                                 const gchar         *hostname,
+                                 GCancellable        *cancellable,
+                                 GAsyncReadyCallback  callback,
+                                 gpointer             user_data)
+{
+  GInetAddress *addr;
+  gchar *ascii_hostname = NULL;
+
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (hostname != NULL);
+
+  /* Check if @hostname is just an IP address */
+  addr = g_inet_address_new_from_string (hostname);
+  if (addr)
+    {
+      GSimpleAsyncResult *simple;
+      GList *addrs;
+
+      simple = g_simple_async_result_new (G_OBJECT (resolver),
+                                          callback, user_data,
+                                          g_resolver_lookup_by_name_async);
+
+      addrs = g_list_append (NULL, addr);
+      g_simple_async_result_set_op_res_gpointer (simple, addrs, (GDestroyNotify)g_resolver_free_addresses);
+      g_simple_async_result_complete_in_idle (simple);
+      g_object_unref (simple);
+      return;
+    }
+
+  if (g_hostname_is_non_ascii (hostname))
+    hostname = ascii_hostname = g_hostname_to_ascii (hostname);
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name_async (resolver, hostname, cancellable, callback, user_data);
+
+  g_free (ascii_hostname);
+}
+
+/**
+ * g_resolver_lookup_by_name_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a call to
+ * g_resolver_lookup_by_name_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a #GList of #GInetAddress, or %NULL on error. See
+ * g_resolver_lookup_by_name() for more details.
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_by_name_finish (GResolver     *resolver,
+                                  GAsyncResult  *result,
+                                  GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+
+      /* Handle the stringified-IP-addr case */
+      if (g_simple_async_result_get_source_tag (simple) == g_resolver_lookup_by_name_async)
+        {
+          GList *addrs;
+
+          addrs = g_simple_async_result_get_op_res_gpointer (simple);
+          g_simple_async_result_set_op_res_gpointer (simple, NULL, NULL);
+          return addrs;
+        }
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_name_finish (resolver, result, error);
+}
+
+/**
+ * g_resolver_free_addresses:
+ * @addresses: a #GList of #GInetAddress
+ *
+ * Frees @addresses (which should be the return value from
+ * g_resolver_lookup_by_name() or g_resolver_lookup_by_name_finish()).
+ * (This is a convenience method; you can also simply free the results
+ * by hand.)
+ **/
+void
+g_resolver_free_addresses (GList *addresses)
+{
+  GList *a;
+
+  for (a = addresses; a; a = a->next)
+    g_object_unref (a->data);
+  g_list_free (addresses);
+}
+
+/**
+ * g_resolver_lookup_by_address:
+ * @resolver: a #GResolver
+ * @address: the address to reverse-resolve
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously reverse-resolves @address to determine its
+ * associated hostname.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to
+ * a value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a hostname (either ASCII-only, or in ASCII-encoded
+ * form), or %NULL on error.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_resolver_lookup_by_address (GResolver     *resolver,
+                              GInetAddress  *address,
+                              GCancellable  *cancellable,
+                              GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (G_IS_INET_ADDRESS (address), NULL);
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address (resolver, address, cancellable, error);
+}
+
+/**
+ * g_resolver_lookup_by_address_async:
+ * @resolver: a #GResolver
+ * @address: the address to reverse-resolve
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously reverse-resolving @address to determine its
+ * associated hostname, and eventually calls @callback, which must
+ * call g_resolver_lookup_by_address_finish() to get the final result.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_by_address_async (GResolver           *resolver,
+                                    GInetAddress        *address,
+                                    GCancellable        *cancellable,
+                                    GAsyncReadyCallback  callback,
+                                    gpointer             user_data)
+{
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (G_IS_INET_ADDRESS (address));
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address_async (resolver, address, cancellable, callback, user_data);
+}
+
+/**
+ * g_resolver_lookup_by_address_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a previous call to
+ * g_resolver_lookup_by_address_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a hostname (either ASCII-only, or in ASCII-encoded
+ * form), or %NULL on error.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_resolver_lookup_by_address_finish (GResolver     *resolver,
+                                     GAsyncResult  *result,
+                                     GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_by_address_finish (resolver, result, error);
+}
+
+static gchar *
+g_resolver_get_service_rrname (const char *service,
+                               const char *protocol,
+                               const char *domain)
+{
+  gchar *rrname, *ascii_domain = NULL;
+
+  if (g_hostname_is_non_ascii (domain))
+    domain = ascii_domain = g_hostname_to_ascii (domain);
+
+  rrname = g_strdup_printf ("_%s._%s.%s", service, protocol, domain);
+
+  g_free (ascii_domain);
+  return rrname;
+}
+
+/**
+ * g_resolver_lookup_service:
+ * @resolver: a #GResolver
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ * @cancellable: a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Synchronously performs a DNS SRV lookup for the given @service and
+ * @protocol in the given @domain and returns an array of #GSrvTarget.
+ * @domain may be an ASCII-only or UTF-8 hostname. Note also that the
+ * @service and @protocol arguments DO NOT include the leading
+ * underscore that appears in the actual DNS entry.
+ *
+ * On success, g_resolver_lookup_service() will return a #GList of
+ * #GSrvTarget, sorted in order of preference. (That is, you should
+ * attempt to connect to the first target first, then the second if
+ * the first fails, etc.) You must free each target and the list when
+ * you are done with it.
+ *
+ * If the DNS resolution fails, @error (if non-%NULL) will be set to
+ * a value from #GResolverError.
+ *
+ * If @cancellable is non-%NULL, it can be used to cancel the
+ * operation, in which case @error (if non-%NULL) will be set to
+ * %G_IO_ERROR_CANCELLED.
+ *
+ * If you are planning to connect to the service, it is usually easier
+ * to create a #GNetworkService and use its #GSocketConnectable
+ * interface.
+ *
+ * Return value: a #GList of #GSrvTarget, or %NULL on error. You must
+ * free each of the targets and the list when you are done with it.
+ * (You can use g_resolver_free_targets() to do this.)
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_service (GResolver     *resolver,
+                           const gchar   *service,
+                           const gchar   *protocol,
+                           const gchar   *domain,
+                           GCancellable  *cancellable,
+                           GError       **error)
+{
+  GList *targets;
+  gchar *rrname;
+
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+  g_return_val_if_fail (service != NULL, NULL);
+  g_return_val_if_fail (protocol != NULL, NULL);
+  g_return_val_if_fail (domain != NULL, NULL);
+
+  rrname = g_resolver_get_service_rrname (service, protocol, domain);
+
+  targets = G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service (resolver, rrname, cancellable, error);
+
+  g_free (rrname);
+  return targets;
+}
+
+/**
+ * g_resolver_lookup_service_async:
+ * @resolver: a #GResolver
+ * @service: the service type to look up (eg, "ldap")
+ * @protocol: the networking protocol to use for @service (eg, "tcp")
+ * @domain: the DNS domain to look up the service in
+ * @cancellable: a #GCancellable, or %NULL
+ * @callback: callback to call after resolution completes
+ * @user_data: data for @callback
+ *
+ * Begins asynchronously performing a DNS SRV lookup for the given
+ * @service and @protocol in the given @domain, and eventually calls
+ * @callback, which must call g_resolver_lookup_service_finish() to
+ * get the final result. See g_resolver_lookup_service() for more
+ * details.
+ *
+ * Since: 2.20
+ **/
+void
+g_resolver_lookup_service_async (GResolver           *resolver,
+                                 const gchar         *service,
+                                 const gchar         *protocol,
+                                 const gchar         *domain,
+                                 GCancellable        *cancellable,
+                                 GAsyncReadyCallback  callback,
+                                 gpointer             user_data)
+{
+  gchar *rrname;
+
+  g_return_if_fail (G_IS_RESOLVER (resolver));
+  g_return_if_fail (service != NULL);
+  g_return_if_fail (protocol != NULL);
+  g_return_if_fail (domain != NULL);
+
+  rrname = g_resolver_get_service_rrname (service, protocol, domain);
+
+  G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service_async (resolver, rrname, cancellable, callback, user_data);
+
+  g_free (rrname);
+}
+
+/**
+ * g_resolver_lookup_service_finish:
+ * @resolver: a #GResolver
+ * @result: the result passed to your #GAsyncReadyCallback
+ * @error: return location for a #GError, or %NULL
+ *
+ * Retrieves the result of a previous call to
+ * g_resolver_lookup_service_async().
+ *
+ * If the DNS resolution failed, @error (if non-%NULL) will be set to
+ * a value from #GResolverError. If the operation was cancelled,
+ * @error will be set to %G_IO_ERROR_CANCELLED.
+ *
+ * Return value: a #GList of #GSrvTarget, or %NULL on error. See
+ * g_resolver_lookup_service() for more details.
+ *
+ * Since: 2.20
+ **/
+GList *
+g_resolver_lookup_service_finish (GResolver     *resolver,
+                                  GAsyncResult  *result,
+                                  GError       **error)
+{
+  g_return_val_if_fail (G_IS_RESOLVER (resolver), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+        return NULL;
+    }
+
+  return G_RESOLVER_GET_CLASS (resolver)->
+    lookup_service_finish (resolver, result, error);
+}
+
+/**
+ * g_resolver_free_targets:
+ * @targets: a #GList of #GSrvTarget
+ *
+ * Frees @targets (which should be the return value from
+ * g_resolver_lookup_service() or g_resolver_lookup_service_finish()).
+ * (This is a convenience method; you can also simply free the
+ * results by hand.)
+ **/
+void
+g_resolver_free_targets (GList *targets)
+{
+  GList *t;
+
+  for (t = targets; t; t = t->next)
+    g_srv_target_free (t->data);
+  g_list_free (targets);
+}
+
+/**
+ * g_resolver_error_quark:
+ * 
+ * Gets the #GResolver Error Quark.
+ *
+ * Return value: a #GQuark.
+ *
+ * Since: 2.20
+ **/
+GQuark
+g_resolver_error_quark (void)
+{
+  return g_quark_from_static_string ("g-resolver-error-quark");
+}
+
+
+static GResolverError
+g_resolver_error_from_addrinfo_error (gint err)
+{
+  switch (err)
+    {
+    case EAI_FAIL:
+    case EAI_NODATA:
+    case EAI_NONAME:
+      return G_RESOLVER_ERROR_NOT_FOUND;
+
+    case EAI_AGAIN:
+      return G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+
+    default:
+      return G_RESOLVER_ERROR_INTERNAL;
+    }
+}
+
+struct addrinfo _g_resolver_addrinfo_hints;
+
+/* Private method to process a getaddrinfo() response. */
+GList *
+_g_resolver_addresses_from_addrinfo (const char       *hostname,
+                                     struct addrinfo  *res,
+                                     gint              gai_retval,
+                                     GError          **error)
+{
+  struct addrinfo *ai;
+  GSocketAddress *sockaddr;
+  GInetAddress *addr;
+  GList *addrs;
+
+  if (gai_retval != 0)
+    {
+      g_set_error (error, G_RESOLVER_ERROR,
+		   g_resolver_error_from_addrinfo_error (gai_retval),
+		   _("Error resolving '%s': %s"),
+		   hostname, gai_strerror (gai_retval));
+      return NULL;
+    }
+
+  g_return_val_if_fail (res != NULL, NULL);
+
+  addrs = NULL;
+  for (ai = res; ai; ai = ai->ai_next)
+    {
+      sockaddr = g_socket_address_new_from_native (ai->ai_addr, ai->ai_addrlen);
+      if (!sockaddr || !G_IS_INET_SOCKET_ADDRESS (sockaddr))
+        continue;
+
+      addr = g_object_ref (g_inet_socket_address_get_address ((GInetSocketAddress *)sockaddr));
+      addrs = g_list_prepend (addrs, addr);
+      g_object_unref (sockaddr);
+    }
+
+  return g_list_reverse (addrs);
+}
+
+/* Private method to set up a getnameinfo() request */
+void
+_g_resolver_address_to_sockaddr (GInetAddress            *address,
+                                 struct sockaddr_storage *sa,
+                                 gsize                   *sa_len)
+{
+  GSocketAddress *sockaddr;
+
+  sockaddr = g_inet_socket_address_new (address, 0);
+  g_socket_address_to_native (sockaddr, (struct sockaddr *)sa, sizeof (*sa));
+  *sa_len = g_socket_address_get_native_size (sockaddr);
+  g_object_unref (sockaddr);
+}
+
+/* Private method to process a getnameinfo() response. */
+char *
+_g_resolver_name_from_nameinfo (GInetAddress  *address,
+                                const gchar   *name,
+                                gint           gni_retval,
+                                GError       **error)
+{
+  if (gni_retval != 0)
+    {
+      gchar *phys;
+
+      phys = g_inet_address_to_string (address);
+      g_set_error (error, G_RESOLVER_ERROR,
+                   g_resolver_error_from_addrinfo_error (gni_retval),
+                   _("Error reverse-resolving '%s': %s"),
+                   phys ? phys : "(unknown)", gai_strerror (gni_retval));
+      g_free (phys);
+      return NULL;
+    }
+
+  return g_strdup (name);
+}
+
+#if defined(G_OS_UNIX)
+/* Private method to process a res_query response into GSrvTargets */
+GList *
+_g_resolver_targets_from_res_query (const gchar      *rrname,
+                                    guchar           *answer,
+                                    gint              len,
+                                    gint              herr,
+                                    GError          **error)
+{
+  gint count;
+  gchar namebuf[1024];
+  guchar *end, *p;
+  guint16 type, qclass, rdlength, priority, weight, port;
+  guint32 ttl;
+  HEADER *header;
+  time_t now = time (NULL);
+  GSrvTarget *target;
+  GList *targets;
+
+  if (len < 0)
+    {
+      GResolverError errnum;
+      const gchar *format;
+
+      if (herr == HOST_NOT_FOUND || herr == NO_DATA)
+        {
+          errnum = G_RESOLVER_ERROR_NOT_FOUND;
+          format = _("No service record for '%s'");
+        }
+      else if (herr == TRY_AGAIN)
+        {
+          errnum = G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+          format = _("Temporarily unable to resolve '%s'");
+        }
+      else
+        {
+          errnum = G_RESOLVER_ERROR_INTERNAL;
+          format = _("Error resolving '%s'");
+        }
+
+      g_set_error (error, G_RESOLVER_ERROR, errnum, format, rrname);
+      return NULL;
+    }
+
+  targets = NULL;
+
+  header = (HEADER *)answer;
+  p = answer + sizeof (HEADER);
+  end = answer + len;
+
+  /* Skip query */
+  count = ntohs (header->qdcount);
+  while (count-- && p < end)
+    {
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+      p += 4;
+    }
+
+  /* Read answers */
+  count = ntohs (header->ancount);
+  while (count-- && p < end)
+    {
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+      GETSHORT (type, p);
+      GETSHORT (qclass, p);
+      GETLONG  (ttl, p);
+      GETSHORT (rdlength, p);
+
+      if (type != T_SRV || qclass != C_IN)
+        {
+          p += rdlength;
+          continue;
+        }
+
+      GETSHORT (priority, p);
+      GETSHORT (weight, p);
+      GETSHORT (port, p);
+      p += dn_expand (answer, end, p, namebuf, sizeof (namebuf));
+
+      target = g_srv_target_new (namebuf, port, priority, weight, now + ttl);
+      targets = g_list_prepend (targets, target);
+    }
+
+  return g_srv_target_list_sort (targets);
+}
+#elif defined(G_OS_WIN32)
+/* Private method to process a DnsQuery response into GSrvTargets */
+GList *
+_g_resolver_targets_from_DnsQuery (const gchar  *rrname,
+                                   DNS_STATUS    status,
+                                   DNS_RECORD   *results,
+                                   GError      **error)
+{
+  DNS_RECORD *rec;
+  GSrvTarget *target;
+  GList *targets;
+  time_t now = time (NULL);
+
+  if (status != ERROR_SUCCESS)
+    {
+      GResolverError errnum;
+      const gchar *format;
+
+      if (status == DNS_ERROR_RCODE_NAME_ERROR)
+        {
+          errnum = G_RESOLVER_ERROR_NOT_FOUND;
+          format = _("No service record for '%s'");
+        }
+      else if (status == DNS_ERROR_RCODE_SERVER_FAILURE)
+        {
+          errnum = G_RESOLVER_ERROR_TEMPORARY_FAILURE;
+          format = _("Temporarily unable to resolve '%s'");
+        }
+      else
+        {
+          errnum = G_RESOLVER_ERROR_INTERNAL;
+          format = _("Error resolving '%s'");
+        }
+
+      g_set_error (error, G_RESOLVER_ERROR, errnum, format, rrname);
+      return NULL;
+    }
+
+  targets = NULL;
+  for (rec = results; rec; rec = rec->pNext)
+    {
+      if (rec->wType != DNS_TYPE_SRV)
+        continue;
+
+      target = g_srv_target_new (rec->Data.SRV.pNameTarget,
+                                 rec->Data.SRV.wPort,
+                                 rec->Data.SRV.wPriority,
+                                 rec->Data.SRV.wWeight,
+                                 now + rec->dwTtl);
+      targets = g_list_prepend (targets, target);
+    }
+
+  return g_srv_target_list_sort (targets);
+}
+
+#endif
+
+#define __G_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gresolver.h b/gio/gresolver.h
new file mode 100644
index 0000000..788851e
--- /dev/null
+++ b/gio/gresolver.h
@@ -0,0 +1,159 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_RESOLVER_H__
+#define __G_RESOLVER_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_RESOLVER         (g_resolver_get_type ())
+#define G_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_RESOLVER, GResolver))
+#define G_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_RESOLVER, GResolverClass))
+#define G_IS_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_RESOLVER))
+#define G_IS_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_RESOLVER))
+#define G_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_RESOLVER, GResolverClass))
+
+struct _GResolver {
+  GObject parent_instance;
+
+};
+
+typedef struct {
+  GObjectClass parent_class;
+
+  GList * ( *lookup_by_name)           (GResolver            *resolver,
+					const gchar          *hostname,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_by_name_async)     (GResolver            *resolver,
+					const gchar          *hostname,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  GList * ( *lookup_by_name_finish)    (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  gchar * ( *lookup_by_address)        (GResolver            *resolver,
+					GInetAddress         *address,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_by_address_async)  (GResolver            *resolver,
+					GInetAddress         *address,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  gchar * ( *lookup_by_address_finish) (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  GList * ( *lookup_service)           (GResolver            *resolver,
+					const gchar          *rrname,
+					GCancellable         *cancellable,
+					GError              **error);
+  void    ( *lookup_service_async)     (GResolver            *resolver,
+					const gchar          *rrname,
+					GCancellable         *cancellable,
+					GAsyncReadyCallback   callback,
+					gpointer              user_data);
+  GList * ( *lookup_service_finish)    (GResolver            *resolver,
+					GAsyncResult         *result,
+					GError              **error);
+
+  /* Padding for future expansion */
+  void (*_g_reserved1) (void);
+  void (*_g_reserved2) (void);
+  void (*_g_reserved3) (void);
+  void (*_g_reserved4) (void);
+  void (*_g_reserved5) (void);
+  void (*_g_reserved6) (void);
+
+} GResolverClass;
+
+GType      g_resolver_get_type                  (void) G_GNUC_CONST;
+GResolver *g_resolver_get_default               (void);
+void       g_resolver_set_default               (GResolver            *resolver);
+
+GList     *g_resolver_lookup_by_name            (GResolver            *resolver,
+						 const gchar          *hostname,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_by_name_async      (GResolver            *resolver,
+						 const gchar          *hostname,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+GList     *g_resolver_lookup_by_name_finish     (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+void       g_resolver_free_addresses            (GList                *addresses);
+
+gchar     *g_resolver_lookup_by_address         (GResolver            *resolver,
+						 GInetAddress         *address,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_by_address_async   (GResolver            *resolver,
+						 GInetAddress         *address,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+gchar     *g_resolver_lookup_by_address_finish  (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+GList     *g_resolver_lookup_service            (GResolver            *resolver,
+						 const gchar          *service,
+						 const gchar          *protocol,
+						 const gchar          *domain,
+						 GCancellable         *cancellable,
+						 GError              **error);
+void       g_resolver_lookup_service_async      (GResolver            *resolver,
+						 const gchar          *service,
+						 const gchar          *protocol,
+						 const gchar          *domain,
+						 GCancellable         *cancellable,
+						 GAsyncReadyCallback   callback,
+						 gpointer              user_data);
+GList     *g_resolver_lookup_service_finish     (GResolver            *resolver,
+						 GAsyncResult         *result,
+						 GError              **error);
+
+void       g_resolver_free_targets              (GList                *targets);
+
+/**
+ * G_RESOLVER_ERROR:
+ *
+ * Error domain for #GResolver. Errors in this domain will be from the
+ * #GResolverError enumeration. See #GError for more information on
+ * error domains.
+ **/
+#define G_RESOLVER_ERROR (g_resolver_error_quark ())
+GQuark g_resolver_error_quark (void);
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gsocketaddress.c b/gio/gsocketaddress.c
new file mode 100644
index 0000000..a7e7cfb
--- /dev/null
+++ b/gio/gsocketaddress.c
@@ -0,0 +1,268 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+
+#include "gsocketaddress.h"
+#include "ginetaddress.h"
+#include "ginetsocketaddress.h"
+#include "gnetworkingprivate.h"
+#include "gsocketconnectable.h"
+#include "glibintl.h"
+#include "gioenumtypes.h"
+
+#ifdef G_OS_UNIX
+#include "gunixsocketaddress.h"
+#endif
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsocketaddress
+ * @short_description: Abstract base class representing endpoints for
+ * socket communication
+ *
+ * #GSocketAddress is the equivalent of <type>struct sockaddr</type>
+ * in the BSD sockets API. This is an abstract class; use
+ * #GInetSocketAddress for internet sockets, or #GUnixSocketAddress
+ * for UNIX domain sockets.
+ **/
+
+/**
+ * GSocketAddress:
+ *
+ * A socket endpoint address, corresponding to <type>struct sockaddr</type>
+ * or one of its subtypes.
+ **/
+
+enum
+{
+  PROP_NONE,
+  PROP_FAMILY
+};
+
+static void            g_socket_address_connectable_iface_init (GSocketConnectableIface *iface);
+static GSocketAddress *g_socket_address_connectable_get_next   (GSocketConnectable  *connectable,
+								GCancellable        *cancellable,
+								GError             **error);
+static void            g_socket_address_connectable_reset      (GSocketConnectable  *connectable);
+
+G_DEFINE_ABSTRACT_TYPE_WITH_CODE (GSocketAddress, g_socket_address, G_TYPE_OBJECT,
+				  G_IMPLEMENT_INTERFACE (G_TYPE_SOCKET_CONNECTABLE,
+							 g_socket_address_connectable_iface_init))
+
+/**
+ * g_socket_address_get_family:
+ * @address: a #GSocketAddress
+ *
+ * Gets the socket family type of @address.
+ *
+ * Returns: the socket family type of @address.
+ */
+GSocketFamily
+g_socket_address_get_family (GSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), 0);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->get_family (address);
+}
+
+static void
+g_socket_address_get_property (GObject *object, guint prop_id,
+			       GValue *value, GParamSpec *pspec)
+{
+  GSocketAddress *address = G_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+     case PROP_FAMILY:
+      g_value_set_enum (value, g_socket_address_get_family (address));
+      break;
+
+     default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_socket_address_class_init (GSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  gobject_class->get_property = g_socket_address_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_FAMILY,
+                                   g_param_spec_enum ("family",
+						      _("Address family"),
+						      _("The family of the socket address"),
+						      G_TYPE_SOCKET_FAMILY,
+						      G_SOCKET_FAMILY_INVALID,
+						      G_PARAM_READABLE | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NAME));
+}
+
+static void
+g_socket_address_connectable_iface_init (GSocketConnectableIface *connectable_iface)
+{
+  connectable_iface->get_next = g_socket_address_connectable_get_next;
+  connectable_iface->reset    = g_socket_address_connectable_reset;
+}
+
+static void
+g_socket_address_init (GSocketAddress *address)
+{
+
+}
+
+/**
+ * g_socket_address_get_native_size:
+ * @address: a #GSocketAddress
+ *
+ * Gets the size of @address's native <type>struct sockaddr</type>.
+ * You can use this to allocate memory to pass to
+ * g_socket_address_to_native().
+ *
+ * Returns: the size of the native <type>struct sockaddr</type> that
+ * @address represents
+ */
+gssize
+g_socket_address_get_native_size (GSocketAddress *address)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), -1);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->get_native_size (address);
+}
+
+/**
+ * g_socket_address_to_native:
+ * @address: a #GSocketAddress
+ * @dest: a pointer to a memory location that will contain the native
+ * <type>struct sockaddr</type>.
+ * @destlen: the size of @dest. Must be at least as large as
+ * g_socket_address_get_native_size().
+ *
+ * Converts a #GSocketAddress to a native <type>struct
+ * sockaddr</type>, which can be passed to low-level functions like
+ * connect() or bind().
+ *
+ * Returns: %TRUE if @dest was filled in, %FALSE if @address is invalid
+ * or @destlen is too small.
+ */
+gboolean
+g_socket_address_to_native (GSocketAddress *address,
+			    gpointer        dest,
+			    gsize           destlen)
+{
+  g_return_val_if_fail (G_IS_SOCKET_ADDRESS (address), FALSE);
+
+  return G_SOCKET_ADDRESS_GET_CLASS (address)->to_native (address, dest, destlen);
+}
+
+/**
+ * g_socket_address_new_from_native:
+ * @native: a pointer to a <type>struct sockaddr</type>
+ * @len: the size of the memory location pointed to by @native
+ *
+ * Creates a #GSocketAddress subclass corresponding to the native
+ * <type>struct sockaddr</type> @native.
+ *
+ * Returns: a new #GSocketAddress if @native could successfully be converted,
+ * otherwise %NULL.
+ */
+GSocketAddress *
+g_socket_address_new_from_native (gpointer native,
+				  gsize    len)
+{
+  gshort family;
+
+  if (len < sizeof (gshort))
+    return NULL;
+
+  family = ((struct sockaddr *) native)->sa_family;
+
+  if (family == AF_UNSPEC)
+    return NULL;
+
+  if (family == AF_INET)
+    {
+      struct sockaddr_in *addr = (struct sockaddr_in *) native;
+      GInetAddress *iaddr = g_inet_address_new_from_bytes ((guint8 *) &(addr->sin_addr), AF_INET);
+      GSocketAddress *sockaddr;
+
+      sockaddr = g_inet_socket_address_new (iaddr, g_ntohs (addr->sin_port));
+      g_object_unref (iaddr);
+      return sockaddr;
+    }
+
+  if (family == AF_INET6)
+    {
+      struct sockaddr_in6 *addr = (struct sockaddr_in6 *) native;
+      GInetAddress *iaddr = g_inet_address_new_from_bytes ((guint8 *) &(addr->sin6_addr), AF_INET6);
+      GSocketAddress *sockaddr;
+
+      sockaddr = g_inet_socket_address_new (iaddr, g_ntohs (addr->sin6_port));
+      g_object_unref (iaddr);
+      return sockaddr;
+    }
+
+#ifdef G_OS_UNIX
+  if (family == AF_UNIX)
+    {
+      struct sockaddr_un *addr = (struct sockaddr_un *) native;
+
+      return g_unix_socket_address_new (addr->sun_path);
+    }
+#endif
+
+  return NULL;
+}
+
+static GSocketAddress *
+g_socket_address_connectable_get_next (GSocketConnectable  *connectable,
+				       GCancellable        *cancellable,
+				       GError             **error)
+{
+  /* Rather than creating a GSocketAddressPrivate for just 1 bit of
+   * data, we cheat and use GObject data.
+   */
+  if (g_object_get_data (G_OBJECT (connectable), "GSocketConnectable-iterated"))
+    return NULL;
+  else
+    {
+      g_object_set_data (G_OBJECT (connectable),
+			 "GSocketConnectable-iterated",
+			 GINT_TO_POINTER (TRUE));
+      return g_object_ref (connectable);
+    }
+}
+
+static void
+g_socket_address_connectable_reset (GSocketConnectable  *connectable)
+{
+  g_object_set_data (G_OBJECT (connectable),
+		     "GSocketConnectable-iterated",
+		     NULL);
+}
+
+#define __G_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsocketaddress.h b/gio/gsocketaddress.h
new file mode 100644
index 0000000..1649ba6
--- /dev/null
+++ b/gio/gsocketaddress.h
@@ -0,0 +1,77 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SOCKET_ADDRESS_H__
+#define __G_SOCKET_ADDRESS_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_SOCKET_ADDRESS         (g_socket_address_get_type ())
+#define G_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddress))
+#define G_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
+#define G_IS_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_SOCKET_ADDRESS))
+#define G_IS_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_SOCKET_ADDRESS))
+#define G_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_SOCKET_ADDRESS, GSocketAddressClass))
+
+typedef struct _GSocketAddressClass   GSocketAddressClass;
+
+struct _GSocketAddress
+{
+  GObject parent_instance;
+};
+
+struct _GSocketAddressClass
+{
+  GObjectClass parent_class;
+
+  GSocketFamily  (*get_family)      (GSocketAddress *address);
+
+  gssize         (*get_native_size) (GSocketAddress *address);
+
+  gboolean       (*to_native)       (GSocketAddress *address,
+                                     gpointer        dest,
+                                     gsize           destlen);
+};
+
+GType                 g_socket_address_get_type        (void) G_GNUC_CONST;
+
+GSocketFamily         g_socket_address_get_family      (GSocketAddress *address);
+
+GSocketAddress *      g_socket_address_new_from_native (gpointer        native,
+                                                        gsize           len);
+
+gboolean              g_socket_address_to_native       (GSocketAddress *address,
+                                                        gpointer        dest,
+                                                        gsize           destlen);
+
+gssize                g_socket_address_get_native_size (GSocketAddress *address);
+
+G_END_DECLS
+
+#endif /* __G_SOCKET_ADDRESS_H__ */
diff --git a/gio/gsocketconnectable.c b/gio/gsocketconnectable.c
new file mode 100644
index 0000000..c72dd7c
--- /dev/null
+++ b/gio/gsocketconnectable.c
@@ -0,0 +1,269 @@
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include "gsocketconnectable.h"
+#include "gsimpleasyncresult.h"
+#include "glibintl.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsocketconnectable
+ * @short_description: Interface for potential socket endpoints.
+ *
+ * Objects that describe one or more potential socket endpoints
+ * implement #GSocketConnectable. The caller can then use
+ * g_socket_connectable_get_next() or
+ * g_socket_connectable_get_next_async() to try out each
+ * #GSocketAddress in turn until it suceeds in connecting to one of
+ * them.
+ **/
+
+static void g_socket_connectable_base_init  (gpointer g_class);
+static void g_socket_connectable_class_init (gpointer g_class,
+					     gpointer class_data);
+
+static void            g_socket_connectable_real_get_next_async  (GSocketConnectable   *connectable,
+								  GCancellable         *cancellable,
+								  GAsyncReadyCallback   callback,
+								  gpointer              user_data);
+static GSocketAddress *g_socket_connectable_real_get_next_finish (GSocketConnectable   *connectable,
+								  GAsyncResult         *result,
+								  GError              **error);
+
+GType
+g_socket_connectable_get_type (void)
+{
+  static volatile gsize g_define_type_id__volatile = 0;
+
+  if (g_once_init_enter (&g_define_type_id__volatile))
+    {
+      const GTypeInfo connectable_info =
+      {
+        sizeof (GSocketConnectableIface), /* class_size */
+	g_socket_connectable_base_init,		/* base_init */
+	NULL,		/* base_finalize */
+	g_socket_connectable_class_init,
+	NULL,		/* class_finalize */
+	NULL,		/* class_data */
+	0,
+	0,              /* n_preallocs */
+	NULL
+      };
+      GType g_define_type_id =
+	g_type_register_static (G_TYPE_INTERFACE, I_("GSocketConnectable"),
+				&connectable_info, 0);
+
+      g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_OBJECT);
+
+      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
+    }
+
+  return g_define_type_id__volatile;
+}
+
+static void
+g_socket_connectable_class_init (gpointer g_class,
+				 gpointer class_data)
+{
+  GSocketConnectableIface *iface = g_class;
+
+  iface->get_next_async = g_socket_connectable_real_get_next_async;
+  iface->get_next_finish = g_socket_connectable_real_get_next_finish;
+}
+
+static void
+g_socket_connectable_base_init (gpointer g_class)
+{
+}
+
+/**
+ * g_socket_connectable_get_next:
+ * @connectable: a #GSocketConnectable
+ * @cancellable: optional #GCancellable object, %NULL to ignore.
+ * @error: a #GError.
+ *
+ * Retrieves the next #GSocketAddress from @connectable. Note that
+ * this may block for some amount of time. (Eg, @connectable may need
+ * to do a DNS lookup before it can return an address.) Use
+ * g_socket_connectable_get_next_async() if you need to avoid
+ * blocking.
+ *
+ * If @connectable is unable to yield any addresses (eg, because of a
+ * DNS error), then the first call to g_socket_connectable_get_next()
+ * will return an appropriate error in *@error. However, if the first
+ * call to g_socket_connectable_get_next() succeeds, then any further
+ * internal errors (other than @cancellable being triggered) will be
+ * ignored.
+ *
+ * Return value: a #GSocketAddress (owned by the caller), or %NULL on
+ * error (in which case *@error will be set) or if there are no more
+ * addresses.
+ **/
+GSocketAddress *
+g_socket_connectable_get_next (GSocketConnectable  *connectable,
+			       GCancellable        *cancellable,
+			       GError             **error)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_val_if_fail (G_IS_SOCKET_CONNECTABLE (connectable), NULL);
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  return (* iface->get_next) (connectable, cancellable, error);
+}
+
+/* Default implementation of get_next_async just calls the synchronous
+ * method; this can be used if the implementation already knows all of
+ * its addresses, and so the synchronous method will never block.
+ */
+static void
+g_socket_connectable_real_get_next_async (GSocketConnectable  *connectable,
+					  GCancellable        *cancellable,
+					  GAsyncReadyCallback  callback,
+					  gpointer             user_data)
+{
+  GSimpleAsyncResult *result;
+  GSocketAddress *address;
+  GError *error = NULL;
+
+  result = g_simple_async_result_new (G_OBJECT (connectable),
+				      callback, user_data,
+				      g_socket_connectable_real_get_next_async);
+  address = g_socket_connectable_get_next (connectable, cancellable, &error);
+  if (address)
+    g_simple_async_result_set_op_res_gpointer (result, address, g_object_unref);
+  else if (error)
+    {
+      g_simple_async_result_set_from_error (result, error);
+      g_error_free (error);
+    }
+  g_simple_async_result_complete_in_idle (result);
+  g_object_unref (result);
+}
+
+/**
+ * g_socket_connectable_get_next_async:
+ * @connectable: a #GSocketConnectable
+ * @cancellable: optional #GCancellable object, %NULL to ignore.
+ * @callback: a #GAsyncReadyCallback to call when the request is satisfied
+ * @user_data: the data to pass to callback function
+ *
+ * Asynchronously retrieves the next #GSocketAddress from @connectable
+ * and then calls @callback, which must call
+ * g_socket_connectable_get_next_finish() to get the result.
+ **/
+void
+g_socket_connectable_get_next_async (GSocketConnectable  *connectable,
+				     GCancellable        *cancellable,
+				     GAsyncReadyCallback  callback,
+				     gpointer             user_data)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_if_fail (G_IS_SOCKET_CONNECTABLE (connectable));
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  (* iface->get_next_async) (connectable, cancellable, callback, user_data);
+}
+
+static GSocketAddress *
+g_socket_connectable_real_get_next_finish (GSocketConnectable  *connectable,
+					   GAsyncResult        *result,
+					   GError             **error)
+{
+  GSimpleAsyncResult *simple;
+  GSocketAddress *sockaddr;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (connectable), g_socket_connectable_real_get_next_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  sockaddr = g_simple_async_result_get_op_res_gpointer (simple);
+  return sockaddr ? g_object_ref (sockaddr) : NULL;
+}
+
+/**
+ * g_socket_connectable_get_next_finish:
+ * @connectable: a #GSocketConnectable
+ * @result: a #GAsyncResult.
+ * @error: a #GError.
+ *
+ * Retrieves the result of a completed call to
+ * g_socket_connectable_get_next_async(). See
+ * g_socket_connectable_get_next() for more information about
+ * error handling.
+ *
+ * Return value: a #GSocketAddress (owned by the caller), or %NULL on
+ * error (in which case *@error will be set) or if there are no more
+ * addresses.
+ **/
+GSocketAddress *
+g_socket_connectable_get_next_finish (GSocketConnectable  *connectable,
+				      GAsyncResult        *result,
+				      GError             **error)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_val_if_fail (G_IS_SOCKET_CONNECTABLE (connectable), NULL);
+
+  if (G_IS_SIMPLE_ASYNC_RESULT (result))
+    {
+      GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (result);
+
+      if (g_simple_async_result_propagate_error (simple, error))
+	return NULL;
+    }
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  return (* iface->get_next_finish) (connectable, result, error);
+}
+
+/**
+ * g_socket_connectable_reset:
+ * @connectable: a #GSocketConnectable
+ *
+ * Resets @connectable's iterator state, so that the next call to
+ * g_socket_connectable_get_next() or
+ * g_socket_connectable_get_next_async() will return the first
+ * available #GSocketAddress again.
+ *
+ * You can only call this after successfully enumerating all
+ * addresses. Resetting a connectable at any other time may not
+ * necessarily work correctly.
+ **/
+void
+g_socket_connectable_reset (GSocketConnectable *connectable)
+{
+  GSocketConnectableIface *iface;
+
+  g_return_if_fail (G_IS_SOCKET_CONNECTABLE (connectable));
+
+  iface = G_SOCKET_CONNECTABLE_GET_IFACE (connectable);
+
+  if (iface->reset)
+    (* iface->reset) (connectable);
+}
+
+#define __G_SOCKET_CONNECTABLE_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsocketconnectable.h b/gio/gsocketconnectable.h
new file mode 100644
index 0000000..115d6e3
--- /dev/null
+++ b/gio/gsocketconnectable.h
@@ -0,0 +1,94 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SOCKET_CONNECTABLE_H__
+#define __G_SOCKET_CONNECTABLE_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_SOCKET_CONNECTABLE            (g_socket_connectable_get_type ())
+#define G_SOCKET_CONNECTABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectable))
+#define G_IS_SOCKET_CONNECTABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_SOCKET_CONNECTABLE))
+#define G_SOCKET_CONNECTABLE_GET_IFACE(obj)  (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_SOCKET_CONNECTABLE, GSocketConnectableIface))
+
+/**
+ * GSocketConnectable:
+ *
+ * Interface for objects that enumerate #GSocketAddress<!-- -->es.
+ **/
+typedef struct _GSocketConnectableIface GSocketConnectableIface;
+
+/**
+ * GSocketConnectableIface:
+ * @g_iface: The parent interface.
+ * @get_next: Synchronously gets the next #GSocketAddress
+ * @get_next_async: Begins asynchronously getting the next #GSocketAddress
+ * @get_next_finish: Finishes asynchronously getting a #GSocketAddress
+ * @reset: Resets the enumerator
+ *
+ * Provides an interface for enumerating #GSocketAddress<!-- -->es.
+ **/
+struct _GSocketConnectableIface
+{
+  GTypeInterface g_iface;
+
+  /* Virtual Table */
+
+  GSocketAddress * (* get_next)        (GSocketConnectable   *connectable,
+		  			GCancellable         *cancellable,
+		  			GError              **error);
+
+  void             (* get_next_async)  (GSocketConnectable   *connectable,
+		  			GCancellable         *cancellable,
+		  			GAsyncReadyCallback   callback,
+		  			gpointer              user_data);
+  GSocketAddress * (* get_next_finish) (GSocketConnectable   *connectable,
+					GAsyncResult         *result,
+					GError              **error);
+
+  void             (* reset)           (GSocketConnectable   *connectable);
+};
+
+GType           g_socket_connectable_get_type        (void) G_GNUC_CONST;
+
+GSocketAddress *g_socket_connectable_get_next        (GSocketConnectable   *connectable,
+						      GCancellable         *cancellable,
+						      GError              **error);
+
+void            g_socket_connectable_get_next_async  (GSocketConnectable   *connectable,
+						      GCancellable         *cancellable,
+						      GAsyncReadyCallback   callback,
+						      gpointer              user_data);
+GSocketAddress *g_socket_connectable_get_next_finish (GSocketConnectable   *connectable,
+						      GAsyncResult         *result,
+						      GError              **error);
+
+void            g_socket_connectable_reset           (GSocketConnectable   *connectable);
+
+G_END_DECLS
+
+
+#endif /* __G_SOCKET_CONNECTABLE_H__ */
diff --git a/gio/gsrvtarget.c b/gio/gsrvtarget.c
new file mode 100644
index 0000000..6e2cb55
--- /dev/null
+++ b/gio/gsrvtarget.c
@@ -0,0 +1,353 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include "gsrvtarget.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gsrvtarget
+ * @short_description: DNS SRV record target
+ * @include: gio/gio.h
+ *
+ * SRV (service) records are used by some network protocols to provide
+ * service-specific aliasing and load-balancing. For example, XMPP
+ * (Jabber) uses SRV records to locate the XMPP server for a domain;
+ * rather than connecting directly to "example.com" or assuming a
+ * specific server hostname like "xmpp.example.com", an XMPP client
+ * would look up the "xmpp-client" SRV record for "example.com", and
+ * then connect to whatever host was pointed to by that record.
+ *
+ * Use g_resolver_lookup_service() or
+ * g_resolver_lookup_service_async() to find the #GSrvTarget<!-- -->s
+ * for a given service.
+ **/
+
+struct _GSrvTarget {
+  gchar   *hostname;
+  guint16  port;
+
+  guint16  priority;
+  guint16  weight;
+  time_t   expires;
+};
+
+/**
+ * GSrvTarget:
+ *
+ * A single target host/port that a network service is running on.
+ */
+
+GType
+g_srv_target_get_type (void)
+{
+  static volatile gsize type_volatile = 0;
+
+  if (g_once_init_enter (&type_volatile))
+    {
+      GType type = g_boxed_type_register_static (
+                        g_intern_static_string ("GSrvTarget"),
+			(GBoxedCopyFunc) g_srv_target_copy,
+			(GBoxedFreeFunc) g_srv_target_free);
+      g_once_init_leave (&type_volatile, type);
+    }
+  return type_volatile;
+}
+
+/**
+ * g_srv_target_new:
+ * @hostname: the host that the service is running on
+ * @port: the port that the service is running on
+ * @priority: the target's priority
+ * @weight: the target's weight
+ * @expires: the target's expiration time
+ *
+ * Creates a new #GSrvTarget with the given parameters.
+ *
+ * You should not need to use this; normally #GSrvTarget<!-- -->s are
+ * created by #GResolver.
+ *
+ * Return value: a new #GSrvTarget.
+ *
+ * Since: 2.20
+ **/
+GSrvTarget *
+g_srv_target_new (const gchar *hostname,
+                  guint16      port,
+                  guint16      priority,
+                  guint16      weight,
+                  time_t       expires)
+{
+  GSrvTarget *target = g_slice_new0 (GSrvTarget);
+
+  target->hostname = g_strdup (hostname);
+  target->port = port;
+  target->priority = priority;
+  target->weight = weight;
+  target->expires = expires;
+
+  return target;
+}
+
+/**
+ * g_srv_target_copy:
+ * @target: a #GSrvTarget
+ *
+ * Copies @target
+ *
+ * Return value: a copy of @target
+ *
+ * Since: 2.20
+ **/
+GSrvTarget *
+g_srv_target_copy (GSrvTarget *target)
+{
+  return g_srv_target_new (target->hostname, target->port,
+                           target->priority, target->weight,
+                           target->expires);
+}
+
+/**
+ * g_srv_target_free:
+ * @target: a #GSrvTarget
+ *
+ * Frees @target
+ *
+ * Since: 2.20
+ **/
+void
+g_srv_target_free (GSrvTarget *target)
+{
+  g_free (target->hostname);
+  g_slice_free (GSrvTarget, target);
+}
+
+/**
+ * g_srv_target_get_hostname:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's hostname (in ASCII form; if you are going to present
+ * this to the user, you should use g_hostname_is_ascii_encoded() to
+ * check if it contains encoded Unicode segments, and use
+ * g_hostname_to_unicode() to convert it if it does.)
+ *
+ * Return value: @target's hostname
+ *
+ * Since: 2.20
+ **/
+const gchar *
+g_srv_target_get_hostname (GSrvTarget *target)
+{
+  return target->hostname;
+}
+
+/**
+ * g_srv_target_get_port:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's port
+ *
+ * Return value: @target's port
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_port (GSrvTarget *target)
+{
+  return target->port;
+}
+
+/**
+ * g_srv_target_get_priority:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's priority. You should not need to look at this;
+ * #GResolver already sorts the targets according to the algorithm in
+ * RFC 2782.
+ *
+ * Return value: @target's priority
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_priority (GSrvTarget *target)
+{
+  return target->priority;
+}
+
+/**
+ * g_srv_target_get_weight:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's weight. You should not need to look at this;
+ * #GResolver already sorts the targets according to the algorithm in
+ * RFC 2782.
+ *
+ * Return value: @target's weight
+ *
+ * Since: 2.20
+ **/
+guint16
+g_srv_target_get_weight (GSrvTarget *target)
+{
+  return target->weight;
+}
+
+/**
+ * g_srv_target_get_expires:
+ * @target: a #GSrvTarget
+ *
+ * Gets @target's expiration time.
+ *
+ * Return value: @target's expiration time
+ *
+ * Since: 2.20
+ **/
+time_t
+g_srv_target_get_expires (GSrvTarget *target)
+{
+  return target->expires;
+}
+
+gint
+compare_target (gconstpointer a, gconstpointer b)
+{
+  GSrvTarget *ta = (GSrvTarget *)a;
+  GSrvTarget *tb = (GSrvTarget *)b;
+
+  if (ta->priority == tb->priority)
+    {
+      /* Arrange targets of the same priority "in any order, except
+       * that all those with weight 0 are placed at the beginning of
+       * the list"
+       */
+      if (ta->weight == 0)
+        return -1;
+      else if (tb->weight == 0)
+        return 1;
+      else
+        return g_random_int_range (-1, 1);
+    }
+  else
+    return ta->priority - tb->priority;
+}
+
+/**
+ * g_srv_target_list_sort:
+ * @targets: a #GList of #GSrvTarget
+ *
+ * Sorts @targets in place according to the algorithm in RFC 2782.
+ *
+ * Return value: the head of the sorted list.
+ **/ 
+GList *
+g_srv_target_list_sort (GList *targets)
+{
+  gint sum, val, priority, weight;
+  GList *first, *last, *n;
+  GSrvTarget *target;
+  gpointer tmp;
+
+  if (!targets)
+    return NULL;
+
+  if (!targets->next)
+    {
+      target = targets->data;
+      if (!strcmp (target->hostname, "."))
+        {
+          /* 'A Target of "." means that the service is decidedly not
+           * available at this domain.'
+           */
+          g_srv_target_free (target);
+          g_list_free (targets);
+          return NULL;
+        }
+    }
+
+  /* Sort by priority, and partly by weight */
+  targets = g_list_sort (targets, compare_target);
+
+  /* For each group of targets with the same priority, rebalance them
+   * according to weight.
+   */
+  for (first = targets; first; first = last->next)
+    {
+      /* Skip @first to a non-0-weight target. */
+      while (first && ((GSrvTarget *)first->data)->weight == 0)
+        first = first->next;
+      if (!first)
+        break;
+
+      /* Skip @last to the last target of the same priority. */
+      priority = ((GSrvTarget *)first->data)->priority;
+      last = first;
+      while (last->next &&
+             ((GSrvTarget *)last->next->data)->priority == priority)
+        last = last->next;
+
+      /* If there's only one non-0 weight target at this priority,
+       * we can move on to the next priority level.
+       */
+      if (last == first)
+        continue;
+
+      /* Randomly reorder the non-0 weight targets, giving precedence
+       * to the ones with higher weight. RFC 2782 describes this in
+       * terms of assigning a running sum to each target and building
+       * a new list. We do things slightly differently, but should get
+       * the same result.
+       */
+      for (n = first, sum = 0; n != last->next; n = n->next)
+        sum += ((GSrvTarget *)n->data)->weight;
+      while (first != last)
+        {
+          val = g_random_int_range (0, sum);
+          for (n = first; n != last; n = n->next)
+            {
+              weight = ((GSrvTarget *)n->data)->weight;
+              if (val < weight)
+                break;
+              val -= weight;
+            }
+
+          tmp = first->data;
+          first->data = n->data;
+          n->data = tmp;
+
+          sum -= weight;
+          first = first->next;
+        }
+    }
+
+  return targets;
+}
+
+#define __G_SRV_TARGET_C__
+#include "gioaliasdef.c"
diff --git a/gio/gsrvtarget.h b/gio/gsrvtarget.h
new file mode 100644
index 0000000..995b09a
--- /dev/null
+++ b/gio/gsrvtarget.h
@@ -0,0 +1,54 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GIO_GIO_H_INSIDE__) && !defined (GIO_COMPILATION)
+#error "Only <gio/gio.h> can be included directly."
+#endif
+
+#ifndef __G_SRV_TARGET_H__
+#define __G_SRV_TARGET_H__
+
+#include <gio/giotypes.h>
+
+G_BEGIN_DECLS
+
+GType g_srv_target_get_type (void) G_GNUC_CONST;
+#define G_TYPE_SRV_TARGET (g_srv_target_get_type ())
+
+GSrvTarget  *g_srv_target_new          (const gchar *hostname,
+				        guint16      port,
+				        guint16      priority,
+				        guint16      weight,
+				        time_t       expires);
+GSrvTarget  *g_srv_target_copy         (GSrvTarget  *target);
+void         g_srv_target_free         (GSrvTarget  *target);
+
+const gchar *g_srv_target_get_hostname (GSrvTarget  *target);
+guint16      g_srv_target_get_port     (GSrvTarget  *target);
+guint16      g_srv_target_get_priority (GSrvTarget  *target);
+guint16      g_srv_target_get_weight   (GSrvTarget  *target);
+time_t       g_srv_target_get_expires  (GSrvTarget  *target);
+
+GList       *g_srv_target_list_sort    (GList       *targets);
+
+G_END_DECLS
+
+#endif /* __G_SRV_TARGET_H__ */
+
diff --git a/gio/gthreadedresolver.c b/gio/gthreadedresolver.c
new file mode 100644
index 0000000..0440a3d
--- /dev/null
+++ b/gio/gthreadedresolver.c
@@ -0,0 +1,617 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include "gthreadedresolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GThreadedResolver, g_threaded_resolver, G_TYPE_RESOLVER)
+
+static void threaded_resolver_thread (gpointer thread_data, gpointer pool_data);
+
+static void
+g_threaded_resolver_init (GThreadedResolver *gtr)
+{
+  if (g_thread_supported ())
+    {
+      gtr->thread_pool = g_thread_pool_new (threaded_resolver_thread, gtr,
+					    -1, FALSE, NULL);
+    }
+}
+
+static void
+finalize (GObject *object)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (object);
+
+  g_thread_pool_free (gtr->thread_pool, FALSE, FALSE);
+
+  G_OBJECT_CLASS (g_threaded_resolver_parent_class)->finalize (object);
+}
+
+/* A GThreadedResolverRequest represents a request in progress
+ * (usually, but see case 1). It is refcounted, to make sure that it
+ * doesn't get freed too soon. In particular, it can't be freed until
+ * (a) the resolver thread has finished resolving, (b) the calling
+ * thread has received an answer, and (c) no other thread could be in
+ * the process of trying to cancel it.
+ *
+ * The possibilities:
+ *
+ * 1. Synchronous non-cancellable request: in this case, the request
+ *    is simply done in the calling thread, without using
+ *    GThreadedResolverRequest at all.
+ *
+ * 2. Synchronous cancellable request: A req is created with a GCond,
+ *    and 3 refs (for the resolution thread, the calling thread, and
+ *    the cancellation signal handler).
+ *
+ *      a. If the resolution completes successfully, the thread pool
+ *         function (threaded_resolver_thread()) will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the "cancelled" signal handler (dropping one ref on req)
+ *         and signal the GCond, and then unref the req. The calling
+ *         thread receives the signal from the GCond, processes the
+ *         response, and unrefs the req, causing it to be freed.
+ *
+ *      b. If the resolution is cancelled before completing,
+ *         request_cancelled() will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the signal handler (as above, unreffing the req), set
+ *         req->error to indicate that it was cancelled, and signal
+ *         the GCond. The calling thread receives the signal from the
+ *         GCond, processes the response, and unrefs the req.
+ *         Eventually, the resolver thread finishes resolving (or
+ *         times out in the resolver) and calls
+ *         g_threaded_resolver_request_complete() again, but
+ *         _request_complete() does nothing this time since the
+ *         request is already complete. The thread pool func then
+ *         unrefs the req, causing it to be freed.
+ *
+ * 3. Asynchronous request: A req is created with a GSimpleAsyncResult
+ *    (and no GCond). The calling thread's ref on req is set up to be
+ *    automatically dropped when the async_result is freed. Two
+ *    sub-possibilities:
+ *
+ *      a. If the resolution completes, the thread pool function
+ *         (threaded_resolver_thread()) will call
+ *         g_threaded_resolver_request_complete(), which will detach
+ *         the "cancelled" signal handler (if it was present)
+ *         (unreffing the req), queue the async_result to complete in
+ *         an idle handler, unref the async_result (which is still
+ *         reffed by the idle handler though), and then unref the req.
+ *         The main thread then invokes the async_result's callback
+ *         and processes the response. When it finishes, the
+ *         async_result drops the ref that was taken by
+ *         g_simple_async_result_complete_in_idle(), which causes the
+ *         async_result to be freed, which causes req to be unreffed
+ *         and freed.
+ *
+ *      b. If the resolution is cancelled, request_cancelled() will
+ *         call g_threaded_resolver_request_complete(), which will
+ *         detach the signal handler (as above, unreffing the req) set
+ *         req->error to indicate that it was cancelled, and queue and
+ *         unref the async_result. The main thread completes the
+ *         async_request and unrefs it and the req, as above.
+ *         Eventually, the resolver thread finishes resolving (or
+ *         times out in the resolver) and calls
+ *         g_threaded_resolver_request_complete() again, but
+ *         _request_complete() does nothing this time since the
+ *         request is already complete. The thread pool func then
+ *         unrefs the req, causing it to be freed.
+ *
+ * g_threaded_resolver_request_complete() ensures that if the request
+ * completes and cancels "at the same time" that only one of the two
+ * conditions gets processed.
+ */
+
+typedef struct _GThreadedResolverRequest GThreadedResolverRequest;
+typedef void (*GThreadedResolverResolveFunc) (GThreadedResolverRequest *, GError **);
+typedef void (*GThreadedResolverFreeFunc) (GThreadedResolverRequest *);
+
+struct _GThreadedResolverRequest {
+  GThreadedResolverResolveFunc resolve_func;
+  GThreadedResolverFreeFunc free_func;
+
+  union {
+    struct {
+      gchar *hostname;
+      GList *addresses;
+    } name;
+    struct {
+      GInetAddress *address;
+      gchar *name;
+    } address;
+    struct {
+      gchar *rrname;
+      GList *targets;
+    } service;
+  } u;
+
+  GCancellable *cancellable;
+  GError *error;
+
+  GMutex *mutex;
+  guint ref_count;
+
+  GCond *cond;
+  GSimpleAsyncResult *async_result;
+  gboolean complete;
+
+};
+
+static void g_threaded_resolver_request_unref (GThreadedResolverRequest *req);
+static void request_cancelled (GCancellable *cancellable, gpointer req);
+static void request_cancelled_disconnect_notify (gpointer req, GClosure *closure);
+
+static GThreadedResolverRequest *
+g_threaded_resolver_request_new (GThreadedResolverResolveFunc  resolve_func,
+                                 GThreadedResolverFreeFunc     free_func,
+				 GCancellable                 *cancellable)
+{
+  GThreadedResolverRequest *req;
+
+  req = g_slice_new0 (GThreadedResolverRequest);
+  req->resolve_func = resolve_func;
+  req->free_func = free_func;
+
+  /* Initial refcount is 2; one for the caller and one for resolve_func */
+  req->ref_count = 2;
+
+  if (g_thread_supported ())
+    req->mutex = g_mutex_new ();
+  /* Initially locked; caller must unlock */
+  g_mutex_lock (req->mutex);
+
+  if (cancellable)
+    {
+      req->ref_count++;
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect_data (cancellable, "cancelled",
+			     G_CALLBACK (request_cancelled), req,
+			     request_cancelled_disconnect_notify, 0);
+    }
+
+  return req;
+}
+
+static void
+g_threaded_resolver_request_unref (GThreadedResolverRequest *req)
+{
+  guint ref_count;
+
+  g_mutex_lock (req->mutex);
+  ref_count = --req->ref_count;
+  g_mutex_unlock (req->mutex);
+  if (ref_count > 0)
+    return;
+
+  g_mutex_free (req->mutex);
+
+  if (req->cond)
+    g_cond_free (req->cond);
+
+  if (req->error)
+    g_error_free (req->error);
+
+  if (req->free_func)
+    req->free_func (req);
+
+  /* We don't have to free req->cancellable or req->async_result,
+   * since (if set), they must already have been freed by
+   * request_complete() in order to get here.
+   */
+
+  g_slice_free (GThreadedResolverRequest, req);
+}
+
+static void
+g_threaded_resolver_request_complete (GThreadedResolverRequest *req,
+				      gboolean                  cancelled)
+{
+  g_mutex_lock (req->mutex);
+  if (req->complete)
+    {
+      /* The req was cancelled, and now it has finished resolving as
+       * well. But we have nowhere to send the result, so just return.
+       */
+      g_mutex_unlock (req->mutex);
+      return;
+    }
+
+  req->complete = TRUE;
+  g_mutex_unlock (req->mutex);
+
+  if (req->cancellable)
+    {
+      /* Possibly propagate a cancellation error */
+      if (cancelled && !req->error)
+        g_cancellable_set_error_if_cancelled (req->cancellable, &req->error);
+
+      /* Drop the signal handler's ref on @req */
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  if (req->cond)
+    g_cond_signal (req->cond);
+  else if (req->async_result)
+    {
+      if (req->error)
+        g_simple_async_result_set_from_error (req->async_result, req->error);
+      g_simple_async_result_complete_in_idle (req->async_result);
+
+      /* Drop our ref on the async_result, which will eventually cause
+       * it to drop its ref on req.
+       */
+      g_object_unref (req->async_result);
+      req->async_result = NULL;
+    }
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GThreadedResolverRequest *req = user_data;
+
+  g_threaded_resolver_request_complete (req, TRUE);
+
+  /* We can't actually cancel the resolver thread; it will eventually
+   * complete on its own and call request_complete() again, which will
+   * do nothing the second time.
+   */
+}
+
+static void
+request_cancelled_disconnect_notify (gpointer  req,
+                                     GClosure *closure)
+{
+  g_threaded_resolver_request_unref (req);
+}
+
+static void
+threaded_resolver_thread (gpointer thread_data,
+                          gpointer pool_data)
+{
+  GThreadedResolverRequest *req = thread_data;
+
+  req->resolve_func (req, &req->error);
+  g_threaded_resolver_request_complete (req, FALSE);
+  g_threaded_resolver_request_unref (req);
+}  
+
+static void
+resolve_sync (GThreadedResolver         *gtr,
+              GThreadedResolverRequest  *req,
+              GError                   **error)
+{
+  if (!req->cancellable || !gtr->thread_pool)
+    {
+      req->resolve_func (req, error);
+      return;
+    }
+
+  req->cond = g_cond_new ();
+  g_thread_pool_push (gtr->thread_pool, req, NULL);
+  g_cond_wait (req->cond, req->mutex);
+  g_mutex_unlock (req->mutex);
+
+  if (req->error)
+    {
+      g_propagate_error (error, req->error);
+      req->error = NULL;
+    }
+}
+
+static void
+resolve_async (GThreadedResolver        *gtr,
+               GThreadedResolverRequest *req,
+               GAsyncReadyCallback       callback,
+               gpointer                  user_data,
+               gpointer                  tag)
+{
+  req->async_result = g_simple_async_result_new (G_OBJECT (gtr),
+                                                 callback, user_data, tag);
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, NULL);
+  g_thread_pool_push (gtr->thread_pool, req, NULL);
+  g_mutex_unlock (req->mutex);
+}
+
+static GThreadedResolverRequest *
+resolve_finish (GResolver     *resolver,
+                GAsyncResult  *result,
+		gpointer       tag,
+                GError       **error)
+{
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), tag), NULL);
+
+  return g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (result));
+}
+
+static void
+do_lookup_by_name (GThreadedResolverRequest  *req,
+                   GError                   **error)
+{
+  struct addrinfo *res = NULL;
+  gint retval;
+
+  retval = getaddrinfo (req->u.name.hostname, NULL,
+                        &_g_resolver_addrinfo_hints, &res);
+  req->u.name.addresses =
+    _g_resolver_addresses_from_addrinfo (req->u.name.hostname, res, retval, error);
+  if (res)
+    freeaddrinfo (res);
+}
+
+static GList *
+lookup_by_name (GResolver     *resolver,
+                const gchar   *hostname,
+                GCancellable  *cancellable,
+                GError       **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  GList *addresses;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_name, NULL, cancellable);
+  req->u.name.hostname = (gchar *)hostname;
+  resolve_sync (gtr, req, error);
+
+  addresses = req->u.name.addresses;
+  g_threaded_resolver_request_unref (req);
+  return addresses;
+}
+
+static void
+free_lookup_by_name (GThreadedResolverRequest *req)
+{
+  g_free (req->u.name.hostname);
+  if (req->u.name.addresses)
+    g_resolver_free_addresses (req->u.name.addresses);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_name, free_lookup_by_name,
+                                         cancellable);
+  req->u.name.hostname = g_strdup (hostname);
+  resolve_async (gtr, req, callback, user_data, lookup_by_name_async);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GThreadedResolverRequest *req;
+  GList *addresses;
+
+  req = resolve_finish (resolver, result, lookup_by_name_async, error);
+  addresses = req->u.name.addresses;
+  req->u.name.addresses = NULL;
+  return addresses;
+}
+
+
+static void
+do_lookup_by_address (GThreadedResolverRequest  *req,
+                      GError                   **error)
+{
+  struct sockaddr_storage sockaddr;
+  gsize sockaddr_size;
+  gchar name[NI_MAXHOST];
+  gint retval;
+
+  _g_resolver_address_to_sockaddr (req->u.address.address,
+                                   &sockaddr, &sockaddr_size);
+
+  retval = getnameinfo ((struct sockaddr *)&sockaddr, sockaddr_size,
+                        name, sizeof (name), NULL, 0, NI_NAMEREQD);
+  req->u.address.name = _g_resolver_name_from_nameinfo (req->u.address.address,
+                                                        name, retval, error);
+}
+
+static gchar *
+lookup_by_address (GResolver        *resolver,
+                   GInetAddress     *address,
+                   GCancellable     *cancellable,
+                   GError          **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  gchar *name;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_address, NULL, cancellable);
+  req->u.address.address = address;
+  resolve_sync (gtr, req, error);
+
+  name = req->u.address.name;
+  g_threaded_resolver_request_unref (req);
+  return name;
+}
+
+static void
+free_lookup_by_address (GThreadedResolverRequest *req)
+{
+  g_object_unref (req->u.address.address);
+  if (req->u.address.name)
+    g_free (req->u.address.name);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_by_address,
+                                         free_lookup_by_address,
+                                         cancellable);
+  req->u.address.address = g_object_ref (address);
+  resolve_async (gtr, req, callback, user_data, lookup_by_address_async);
+}
+
+static gchar *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GThreadedResolverRequest *req;
+  gchar *name;
+
+  req = resolve_finish (resolver, result, lookup_by_address_async, error);
+  name = req->u.address.name;
+  req->u.address.name = NULL;
+  return name;
+}
+
+
+static void
+do_lookup_service (GThreadedResolverRequest *req,
+                   GError   **error)
+{
+#if defined(G_OS_UNIX)
+  gint len, herr;
+  guchar answer[1024];
+#elif defined(G_OS_WIN32)
+  DNS_STATUS status;
+  DNS_RECORD *results;
+#endif
+
+#if defined(G_OS_UNIX)
+  len = res_query (req->u.service.rrname, C_IN, T_SRV, answer, sizeof (answer));
+  herr = h_errno;
+  req->u.service.targets = _g_resolver_targets_from_res_query (req->u.service.rrname, answer, len, herr, error);
+#elif defined(G_OS_WIN32)
+  status = DnsQuery_A (req->u.service.rrname, DNS_TYPE_SRV,
+                       DNS_QUERY_STANDARD, NULL, &results, NULL);
+  req->u.service.targets = _g_resolver_targets_from_DnsQuery (req->u.service.rrname, status, results, error);
+  DnsRecordListFree (results, DnsFreeRecordList);
+#endif
+}
+
+static GList *
+lookup_service (GResolver        *resolver,
+                const gchar      *rrname,
+		GCancellable     *cancellable,
+                GError          **error)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+  GList *targets;
+
+  req = g_threaded_resolver_request_new (do_lookup_service, NULL, cancellable);
+  req->u.service.rrname = (char *)rrname;
+  resolve_sync (gtr, req, error);
+
+  targets = req->u.service.targets;
+  g_threaded_resolver_request_unref (req);
+  return targets;
+}
+
+static void
+free_lookup_service (GThreadedResolverRequest *req)
+{
+  g_free (req->u.service.rrname);
+  if (req->u.service.targets)
+    g_resolver_free_targets (req->u.service.targets);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GThreadedResolver *gtr = G_THREADED_RESOLVER (resolver);
+  GThreadedResolverRequest *req;
+
+  req = g_threaded_resolver_request_new (do_lookup_service,
+                                         free_lookup_service,
+                                         cancellable);
+  req->u.service.rrname = g_strdup (rrname);
+  resolve_async (gtr, req, callback, user_data, lookup_service_async);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GThreadedResolverRequest *req;
+  GList *targets;
+
+  req = resolve_finish (resolver, result, lookup_service_async, error);
+  targets = req->u.service.targets;
+  req->u.service.targets = NULL;
+  return targets;
+}
+
+
+static void
+g_threaded_resolver_class_init (GThreadedResolverClass *threaded_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (threaded_class);
+  GObjectClass *object_class = G_OBJECT_CLASS (threaded_class);
+
+  resolver_class->lookup_by_name           = lookup_by_name;
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address        = lookup_by_address;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service           = lookup_service;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+
+  object_class->finalize = finalize;
+}
+
+#define __G_THREADED_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gthreadedresolver.h b/gio/gthreadedresolver.h
new file mode 100644
index 0000000..79d3327
--- /dev/null
+++ b/gio/gthreadedresolver.h
@@ -0,0 +1,50 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_THREADED_RESOLVER_H__
+#define __G_THREADED_RESOLVER_H__
+
+#include <gio/gresolver.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_THREADED_RESOLVER         (g_threaded_resolver_get_type ())
+#define G_THREADED_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_THREADED_RESOLVER, GThreadedResolver))
+#define G_THREADED_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_THREADED_RESOLVER, GThreadedResolverClass))
+#define G_IS_THREADED_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_THREADED_RESOLVER))
+#define G_IS_THREADED_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_THREADED_RESOLVER))
+#define G_THREADED_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_THREADED_RESOLVER, GThreadedResolverClass))
+
+typedef struct {
+  GResolver parent_instance;
+
+  GThreadPool *thread_pool;
+} GThreadedResolver;
+
+typedef struct {
+  GResolverClass parent_class;
+
+} GThreadedResolverClass;
+
+GType g_threaded_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gunixresolver.c b/gio/gunixresolver.c
new file mode 100644
index 0000000..36bb046
--- /dev/null
+++ b/gio/gunixresolver.c
@@ -0,0 +1,433 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <resolv.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "gunixresolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GUnixResolver, g_unix_resolver, G_TYPE_THREADED_RESOLVER)
+
+static gboolean g_unix_resolver_watch (GIOChannel   *iochannel,
+                                       GIOCondition  condition,
+                                       gpointer      user_data);
+
+static void
+g_unix_resolver_init (GUnixResolver *gur)
+{
+  gint fd;
+  GIOChannel *io;
+
+  /* FIXME: how many workers? */
+  gur->asyncns = _g_asyncns_new (2);
+
+  fd = _g_asyncns_fd (gur->asyncns);
+  io = g_io_channel_unix_new (fd);
+  gur->watch = g_io_add_watch (io, G_IO_IN | G_IO_HUP | G_IO_ERR,
+                               g_unix_resolver_watch, gur);
+  g_io_channel_unref (io);
+}
+
+static void
+g_unix_resolver_finalize (GObject *object)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (object);
+
+  if (gur->watch)
+    g_source_remove (gur->watch);
+  _g_asyncns_free (gur->asyncns);
+
+  G_OBJECT_CLASS (g_unix_resolver_parent_class)->finalize (object);
+}
+
+/* The various request possibilities:
+ *
+ * 1. Synchronous: handed off to the base class (GThreadedResolver);
+ *    since it's never possible to cancel a synchronous request in a
+ *    single-threaded program, the request is done in the calling
+ *    thread.
+ *
+ * 2. Asynchronous: An appropriate _g_asyncns_query_t is created, and
+ *    then a GUnixResolverRequest is created with that query and a
+ *    GSimpleAsyncResult. Two sub-possibilities:
+ *
+ *      a. The resolution completes: g_unix_resolver_watch() sees that
+ *         the request has completed, and calls
+ *         g_unix_resolver_request_complete(), which detaches the
+ *         "cancelled" signal handler (if it was present) and then
+ *         immediately completes the async_result (since
+ *         g_unix_resolver_watch() is already run from main-loop
+ *         time.) After completing the async_result, it unrefs it,
+ *         causing the req to be freed as well.
+ *
+ *      b. The resolution is cancelled: request_cancelled() calls
+ *         _g_asyncns_cancel() to cancel the resolution. Then it calls
+ *         g_unix_resolver_request_complete(), which detaches the
+ *         signal handler, and queues async_result to complete in an
+ *         idle handler. It then unrefs the async_result to ensure
+ *         that after its callback runs, it will be destroyed, in turn
+ *         causing the req to be freed. Because the asyncns resolution
+ *         was cancelled, g_unix_resolver_watch() will never be
+ *         triggered for this req.
+ *
+ *    Since there's only a single thread, it's not possible for the
+ *    request to both complete and be cancelled "at the same time",
+ *    and each of the two possibilities takes steps to block the other
+ *    from being able to happen later, so it's always safe to free req
+ *    after the async_result completes.
+ */
+
+typedef struct _GUnixResolverRequest GUnixResolverRequest;
+typedef void (*GUnixResolverFreeFunc) (GUnixResolverRequest *);
+
+struct _GUnixResolverRequest {
+  GUnixResolver *gur;
+
+  _g_asyncns_query_t *qy;
+  union {
+    gchar *hostname;
+    GInetAddress *address;
+    gchar *service;
+  } u;
+  GUnixResolverFreeFunc free_func;
+
+  GCancellable *cancellable;
+  GSimpleAsyncResult *async_result;
+
+};
+
+static void g_unix_resolver_request_free (GUnixResolverRequest *req);
+static void request_cancelled (GCancellable *cancellable,
+                               gpointer      user_data);
+
+static GUnixResolverRequest *
+g_unix_resolver_request_new (GUnixResolver         *gur,
+                             _g_asyncns_query_t    *qy,
+                             GUnixResolverFreeFunc  free_func,
+                             GCancellable          *cancellable,
+                             GSimpleAsyncResult    *async_result)
+{
+  GUnixResolverRequest *req;
+
+  req = g_slice_new0 (GUnixResolverRequest);
+  req->gur = g_object_ref (gur);
+  req->qy = qy;
+  req->free_func = free_func;
+
+  if (cancellable)
+    {
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect (cancellable, "cancelled",
+                        G_CALLBACK (request_cancelled), req);
+    }
+
+  req->async_result = g_object_ref (async_result);
+
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, (GDestroyNotify)g_unix_resolver_request_free);
+
+  return req;
+}
+
+static void
+g_unix_resolver_request_free (GUnixResolverRequest *req)
+{
+  /* If the user didn't call _finish the qy will still be around. */
+  if (req->qy)
+    _g_asyncns_cancel (req->gur->asyncns, req->qy);
+
+  /* We don't have to free req->cancellable and req->async_result,
+   * since they must already have been freed if we're here.
+   */
+
+  g_slice_free (GUnixResolverRequest, req);
+}
+
+static void
+g_unix_resolver_request_complete (GUnixResolverRequest *req,
+                                  gboolean              need_idle)
+{
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  if (need_idle)
+    g_simple_async_result_complete_in_idle (req->async_result);
+  else
+    g_simple_async_result_complete (req->async_result);
+
+  /* If we completed_in_idle, that will have taken an extra ref on
+   * req->async_result; if not, then we're already done. Either way we
+   * need to unref the async_result to make sure it eventually is
+   * destroyed, causing req to be freed.
+   */
+  g_object_unref (req->async_result);
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GUnixResolverRequest *req = user_data;
+  GError *error = NULL;
+
+  _g_asyncns_cancel (req->gur->asyncns, req->qy);
+  req->qy = NULL;
+
+  g_cancellable_set_error_if_cancelled (cancellable, &error);
+  g_simple_async_result_set_from_error (req->async_result, error);
+  g_error_free (error);
+
+  g_unix_resolver_request_complete (req, TRUE);
+}
+
+static gboolean
+g_unix_resolver_watch (GIOChannel   *iochannel,
+                       GIOCondition  condition,
+                       gpointer      user_data)
+{
+  GUnixResolver *gur = user_data;
+  _g_asyncns_query_t *qy;
+  GUnixResolverRequest *req;
+
+  if (condition & (G_IO_HUP | G_IO_ERR))
+    {
+      /* Shouldn't happen. Should we create a new asyncns? FIXME */
+      g_warning ("asyncns died");
+      gur->watch = 0;
+      return FALSE;
+    }
+
+  while (_g_asyncns_wait (gur->asyncns, FALSE) == 0 &&
+         (qy = _g_asyncns_getnext (gur->asyncns)) != NULL)
+    {
+      req = _g_asyncns_getuserdata (gur->asyncns, qy);
+      g_unix_resolver_request_complete (req, FALSE);
+    }
+
+  return TRUE;
+}
+
+static GUnixResolverRequest *
+resolve_async (GUnixResolver         *gur,
+               _g_asyncns_query_t    *qy,
+               GUnixResolverFreeFunc  free_func,
+               GCancellable          *cancellable,
+               GAsyncReadyCallback    callback,
+               gpointer               user_data,
+               gpointer               tag)
+{
+  GSimpleAsyncResult *result;
+  GUnixResolverRequest *req;
+
+  result = g_simple_async_result_new (G_OBJECT (gur), callback, user_data, tag);
+  req = g_unix_resolver_request_new (gur, qy, free_func, cancellable, result);
+  g_object_unref (result);
+  _g_asyncns_setuserdata (gur->asyncns, qy, req);
+
+  return req;
+}
+
+static void
+lookup_by_name_free (GUnixResolverRequest *req)
+{
+  g_free (req->u.hostname);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+
+  qy = _g_asyncns_getaddrinfo (gur->asyncns, hostname, NULL,
+                               &_g_resolver_addrinfo_hints);
+  req = resolve_async (gur, qy, lookup_by_name_free, cancellable,
+                       callback, user_data, lookup_by_name_async);
+  req->u.hostname = g_strdup (hostname);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  struct addrinfo *res;
+  gint retval;
+  GList *addresses;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_name_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  retval = _g_asyncns_getaddrinfo_done (req->gur->asyncns, req->qy, &res);
+  req->qy = NULL;
+  addresses = _g_resolver_addresses_from_addrinfo (req->u.hostname, res, retval, error);
+  if (res)
+    freeaddrinfo (res);
+
+  return addresses;
+}
+
+
+static void
+lookup_by_address_free (GUnixResolverRequest *req)
+{
+  g_object_unref (req->u.address);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+  struct sockaddr_storage sockaddr;
+  gsize sockaddr_size;
+
+  _g_resolver_address_to_sockaddr (address, &sockaddr, &sockaddr_size);
+  qy = _g_asyncns_getnameinfo (gur->asyncns,
+                               (struct sockaddr *)&sockaddr, sockaddr_size,
+                               NI_NAMEREQD, TRUE, FALSE);
+  req = resolve_async (gur, qy, lookup_by_address_free, cancellable,
+                       callback, user_data, lookup_by_address_async);
+  req->u.address = g_object_ref (address);
+}
+
+static gchar *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  gchar host[NI_MAXHOST], *name;
+  gint retval;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_address_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  retval = _g_asyncns_getnameinfo_done (req->gur->asyncns, req->qy,
+                                        host, sizeof (host), NULL, 0);
+  req->qy = NULL;
+  name = _g_resolver_name_from_nameinfo (req->u.address, host, retval, error);
+
+  return name;
+}
+
+
+static void
+lookup_service_free (GUnixResolverRequest *req)
+{
+  g_free (req->u.service);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GUnixResolver *gur = G_UNIX_RESOLVER (resolver);
+  GUnixResolverRequest *req;
+  _g_asyncns_query_t *qy;
+
+  qy = _g_asyncns_res_query (gur->asyncns, rrname, C_IN, T_SRV);
+  req = resolve_async (gur, qy, lookup_service_free, cancellable,
+                       callback, user_data, lookup_service_async);
+  req->u.service = g_strdup (rrname);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GUnixResolverRequest *req;
+  guchar *answer;
+  gint len, herr;
+  GList *targets;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_service_async), FALSE);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  len = _g_asyncns_res_done (req->gur->asyncns, req->qy, &answer);
+  req->qy = NULL;
+  if (len < 0)
+    herr = h_errno;
+  else
+    herr = 0;
+
+  targets = _g_resolver_targets_from_res_query (req->u.service, answer, len, herr, error);
+  _g_asyncns_freeanswer (answer);
+
+  return targets;
+}
+
+
+static void
+g_unix_resolver_class_init (GUnixResolverClass *unix_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (unix_class);
+  GObjectClass *object_class = G_OBJECT_CLASS (unix_class);
+
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+
+  object_class->finalize = g_unix_resolver_finalize;
+}
+
+#define __G_UNIX_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gunixresolver.h b/gio/gunixresolver.h
new file mode 100644
index 0000000..cf7765b
--- /dev/null
+++ b/gio/gunixresolver.h
@@ -0,0 +1,53 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_UNIX_RESOLVER_H__
+#define __G_UNIX_RESOLVER_H__
+
+#include <gio/gthreadedresolver.h>
+#include "libasyncns/asyncns.h"
+
+G_BEGIN_DECLS
+
+#define G_TYPE_UNIX_RESOLVER         (g_unix_resolver_get_type ())
+#define G_UNIX_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_RESOLVER, GUnixResolver))
+#define G_UNIX_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_RESOLVER, GUnixResolverClass))
+#define G_IS_UNIX_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_RESOLVER))
+#define G_IS_UNIX_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_RESOLVER))
+#define G_UNIX_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_RESOLVER, GUnixResolverClass))
+
+typedef struct {
+  GThreadedResolver parent_instance;
+
+  _g_asyncns_t *asyncns;
+  guint watch;
+
+} GUnixResolver;
+
+typedef struct {
+  GThreadedResolverClass parent_class;
+
+} GUnixResolverClass;
+
+GType g_unix_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/gunixsocketaddress.c b/gio/gunixsocketaddress.c
new file mode 100644
index 0000000..0bc293f
--- /dev/null
+++ b/gio/gunixsocketaddress.c
@@ -0,0 +1,204 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#include <config.h>
+#include <glib.h>
+#include <string.h>
+
+#include "gunixsocketaddress.h"
+#include "glibintl.h"
+#include "gnetworkingprivate.h"
+
+#include "gioalias.h"
+
+/**
+ * SECTION:gunixsocketaddress
+ * @short_description: Unix socket addresses
+ *
+ * Support for UNIX-domain (aka local) sockets.
+ **/
+
+/**
+ * GUnixSocketAddress:
+ *
+ * A UNIX-domain (local) socket address, corresponding to a
+ * <type>struct sockaddr_un</type>.
+ **/
+G_DEFINE_TYPE (GUnixSocketAddress, g_unix_socket_address, G_TYPE_SOCKET_ADDRESS);
+
+enum
+{
+  PROP_0,
+  PROP_PATH,
+};
+
+struct _GUnixSocketAddressPrivate
+{
+  char *path;
+};
+
+static void
+g_unix_socket_address_finalize (GObject *object)
+{
+  GUnixSocketAddress *address G_GNUC_UNUSED = G_UNIX_SOCKET_ADDRESS (object);
+
+  g_free (address->priv->path);
+
+  if (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->finalize)
+    (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->finalize) (object);
+}
+
+static void
+g_unix_socket_address_dispose (GObject *object)
+{
+  GUnixSocketAddress *address G_GNUC_UNUSED = G_UNIX_SOCKET_ADDRESS (object);
+
+  if (G_OBJECT_CLASS (g_unix_socket_address_parent_class)->dispose)
+    (*G_OBJECT_CLASS (g_unix_socket_address_parent_class)->dispose) (object);
+}
+
+static void
+g_unix_socket_address_get_property (GObject    *object,
+                                    guint       prop_id,
+                                    GValue     *value,
+                                    GParamSpec *pspec)
+{
+  GUnixSocketAddress *address = G_UNIX_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_PATH:
+        g_value_set_string (value, address->priv->path);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static GSocketFamily
+g_unix_socket_address_get_family (GSocketAddress *address)
+{
+  g_assert (PF_UNIX == G_SOCKET_FAMILY_UNIX);
+
+  return G_SOCKET_FAMILY_UNIX;
+}
+
+static void
+g_unix_socket_address_set_property (GObject      *object,
+                                    guint         prop_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
+{
+  GUnixSocketAddress *address = G_UNIX_SOCKET_ADDRESS (object);
+
+  switch (prop_id)
+    {
+      case PROP_PATH:
+        g_free (address->priv->path);
+        address->priv->path = g_value_dup_string (value);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static gssize
+g_unix_socket_address_get_native_size (GSocketAddress *address)
+{
+  return sizeof (struct sockaddr_un);
+}
+
+static gboolean
+g_unix_socket_address_to_native (GSocketAddress *address,
+				 gpointer        dest,
+				 gsize           destlen)
+{
+  GUnixSocketAddress *addr = G_UNIX_SOCKET_ADDRESS (address);
+  struct sockaddr_un *sock;
+
+  if (destlen < sizeof (*sock))
+    return FALSE;
+
+  sock = (struct sockaddr_un *) dest;
+  sock->sun_family = AF_UNIX;
+  g_strlcpy (sock->sun_path, addr->priv->path, sizeof (sock->sun_path));
+
+  return TRUE;
+}
+
+static void
+g_unix_socket_address_class_init (GUnixSocketAddressClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GSocketAddressClass *gsocketaddress_class = G_SOCKET_ADDRESS_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (GUnixSocketAddressPrivate));
+
+  gobject_class->finalize = g_unix_socket_address_finalize;
+  gobject_class->dispose = g_unix_socket_address_dispose;
+  gobject_class->set_property = g_unix_socket_address_set_property;
+  gobject_class->get_property = g_unix_socket_address_get_property;
+
+  gsocketaddress_class->get_family = g_unix_socket_address_get_family;
+  gsocketaddress_class->to_native = g_unix_socket_address_to_native;
+  gsocketaddress_class->get_native_size = g_unix_socket_address_get_native_size;
+
+  g_object_class_install_property (gobject_class,
+                                   PROP_PATH,
+                                   g_param_spec_string ("path",
+                                                        _("Path"),
+                                                        _("UNIX socket path"),
+                                                        NULL,
+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB));
+}
+
+static void
+g_unix_socket_address_init (GUnixSocketAddress *address)
+{
+  address->priv = G_TYPE_INSTANCE_GET_PRIVATE (address,
+                                               G_TYPE_UNIX_SOCKET_ADDRESS,
+                                               GUnixSocketAddressPrivate);
+
+  address->priv->path = NULL;
+}
+
+/**
+ * g_unix_socket_address_new:
+ * @path: the socket path
+ *
+ * Creates a new #GUnixSocketAddress for @path.
+ *
+ * Returns: a new #GUnixSocketAddress
+ */
+GSocketAddress *
+g_unix_socket_address_new (const gchar *path)
+{
+  return g_object_new (G_TYPE_UNIX_SOCKET_ADDRESS,
+		       "path", path,
+		       NULL);
+}
+
+#define __G_UNIX_SOCKET_ADDRESS_C__
+#include "gioaliasdef.c"
diff --git a/gio/gunixsocketaddress.h b/gio/gunixsocketaddress.h
new file mode 100644
index 0000000..527937f
--- /dev/null
+++ b/gio/gunixsocketaddress.h
@@ -0,0 +1,61 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ */
+
+#ifndef __G_UNIX_SOCKET_ADDRESS_H__
+#define __G_UNIX_SOCKET_ADDRESS_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_UNIX_SOCKET_ADDRESS         (g_unix_socket_address_get_type ())
+#define G_UNIX_SOCKET_ADDRESS(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddress))
+#define G_UNIX_SOCKET_ADDRESS_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
+#define G_IS_UNIX_SOCKET_ADDRESS(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_UNIX_SOCKET_ADDRESS))
+#define G_IS_UNIX_SOCKET_ADDRESS_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_UNIX_SOCKET_ADDRESS))
+#define G_UNIX_SOCKET_ADDRESS_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass))
+
+typedef struct _GUnixSocketAddress        GUnixSocketAddress;
+typedef struct _GUnixSocketAddressClass   GUnixSocketAddressClass;
+typedef struct _GUnixSocketAddressPrivate GUnixSocketAddressPrivate;
+
+struct _GUnixSocketAddress
+{
+  GSocketAddress parent_instance;
+
+  /*< private >*/
+  GUnixSocketAddressPrivate *priv;
+};
+
+struct _GUnixSocketAddressClass
+{
+  GSocketAddressClass parent_class;
+};
+
+GType           g_unix_socket_address_get_type    (void) G_GNUC_CONST;
+
+GSocketAddress *g_unix_socket_address_new         (const gchar *path);
+
+G_END_DECLS
+
+#endif /* __G_UNIX_SOCKET_ADDRESS_H__ */
diff --git a/gio/gwin32resolver.c b/gio/gwin32resolver.c
new file mode 100644
index 0000000..cab45cc
--- /dev/null
+++ b/gio/gwin32resolver.c
@@ -0,0 +1,481 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include "gwin32resolver.h"
+#include "gnetworkingprivate.h"
+
+#include "gcancellable.h"
+#include "gsimpleasyncresult.h"
+#include "gsocketaddress.h"
+
+#include "gioalias.h"
+
+G_DEFINE_TYPE (GWin32Resolver, g_win32_resolver, G_TYPE_THREADED_RESOLVER)
+
+static void
+g_win32_resolver_init (GWin32Resolver *gwr)
+{
+}
+
+/* This is simpler than GThreadedResolver since we don't have to worry
+ * about multiple application-level threads, but more complicated than
+ * GUnixResolver, since we do have to deal with multiple threads of
+ * our own.
+ *
+ * The various request possibilities:
+ *
+ * 1. Synchronous: handed off to the base class (GThreadedResolver);
+ *    since it's never possible to cancel a synchronous request in a
+ *    single-threaded program, the request is done in the calling
+ *    thread.
+ *
+ * 2. Asynchronous: A GWin32ResolverRequest is created with
+ *    appropriate query-specific information, a Windows event handle,
+ *    and a GSimpleAsyncResult. This is then handed to the
+ *    Windows-internal thread pool, which does the raw DNS query part
+ *    of the operation (being careful to not call any glib methods
+ *    that might fail when called from another thread when
+ *    g_thread_init() has not been called). The main thread sets up a
+ *    GSource to asynchronously poll the event handle. There are two
+ *    sub-possibilities:
+ *
+ *      a. The resolution completes: the threadpool function calls
+ *         SetEvent() on the event handle and then returns.
+ *
+ *      b. The resolution is cancelled: request_cancelled()
+ *         disconnects the "cancelled" signal handler, and queues an
+ *         idle handler to complete the async_result.
+ *
+ *    Since we can't free the request from the threadpool thread
+ *    (because of glib locking issues), we *always* have to have it
+ *    call SetEvent and trigger the callback to indicate that it is
+ *    done. But this means that it's possible for the request to be
+ *    cancelled (queuing an idle handler to return that result) and
+ *    then have the resolution thread complete before the idle handler
+ *    runs. So the event callback and the idle handler need to both
+ *    watch out for this, making sure we don't complete the same
+ *    result twice.
+ */
+
+typedef struct GWin32ResolverRequest GWin32ResolverRequest;
+typedef void (*GWin32ResolverRequestFreeFunc) (GWin32ResolverRequest *);
+
+struct GWin32ResolverRequest {
+  GWin32ResolverRequestFreeFunc free_func;
+
+  GCancellable *cancellable;
+  GError *error;
+
+  HANDLE *event;
+  GSimpleAsyncResult *async_result;
+  gboolean complete;
+  guint cancelled_idle;
+
+  union {
+    struct {
+      gchar *name;
+      gint retval;
+      struct addrinfo *res;
+    } name;
+
+    struct {
+      GInetAddress *iaddr;
+      struct sockaddr_storage addr;
+      gsize addrlen;
+      gint retval;
+      gchar *namebuf;
+    } address;
+
+    struct {
+      gchar *rrname;
+      DNS_STATUS retval;
+      DNS_RECORD *results;
+    } service;
+  } u;
+
+};
+
+static GSource *g_win32_handle_source_add (HANDLE      handle,
+                                           GSourceFunc callback,
+                                           gpointer    user_data);
+
+static gboolean request_completed (gpointer      user_data);
+static void     request_cancelled (GCancellable *cancellable,
+                                   gpointer      user_data);
+
+GWin32ResolverRequest *
+g_win32_resolver_request_new (GResolver                     *resolver,
+                              GWin32ResolverRequestFreeFunc  free_func,
+                              GCancellable                  *cancellable,
+                              GAsyncReadyCallback            callback,
+                              gpointer                       user_data,
+                              gpointer                       tag)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_slice_new0 (GWin32ResolverRequest);
+  req->free_func = free_func;
+
+  req->async_result = g_simple_async_result_new (G_OBJECT (resolver), callback,
+                                                 user_data, tag);
+  g_simple_async_result_set_op_res_gpointer (req->async_result, req, NULL);
+
+  req->event = CreateEvent (NULL, FALSE, FALSE, NULL);
+  g_win32_handle_source_add (req->event, request_completed, req);  
+
+  if (cancellable)
+    {
+      req->cancellable = g_object_ref (cancellable);
+      g_signal_connect (cancellable, "cancelled",
+                        G_CALLBACK (request_cancelled), req);
+    }
+
+  return req;
+}
+
+static gboolean
+request_completed (gpointer user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+
+  /* Clean up cancellation-related stuff first */
+  if (req->cancelled_idle)
+    {
+      g_source_remove (req->cancelled_idle);
+      req->cancelled_idle = 0;
+    }
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+    }
+
+  /* Now complete the result (assuming it wasn't already completed) */
+  if (req->async_result)
+    {
+      g_simple_async_result_complete (req->async_result);
+      g_object_unref (req->async_result);
+    }
+
+  /* And free req */
+  CloseHandle (req->event);
+  req->free_func (req);
+  g_slice_free (GWin32ResolverRequest, req);
+
+  return FALSE;
+}
+
+static gboolean
+request_cancelled_idle (gpointer user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+  GError *error = NULL;
+
+  req->cancelled_idle = 0;
+
+  g_cancellable_set_error_if_cancelled (req->cancellable, &error);
+  g_simple_async_result_set_from_error (req->async_result, error);
+  g_simple_async_result_complete (req->async_result);
+
+  g_object_unref (req->async_result);
+  req->async_result = NULL;
+
+  /* request_completed will eventually be called to free req */
+
+  return FALSE;
+}
+
+static void
+request_cancelled (GCancellable *cancellable,
+                   gpointer      user_data)
+{
+  GWin32ResolverRequest *req = user_data;
+
+  if (req->cancellable)
+    {
+      g_signal_handlers_disconnect_by_func (req->cancellable, request_cancelled, req);
+      g_object_unref (req->cancellable);
+      req->cancellable = NULL;
+    }
+
+  /* We need to wait until main-loop-time to actually complete the
+   * result; we don't use _complete_in_idle() here because we need to
+   * keep track of the source id.
+   */
+  req->cancelled_idle = g_idle_add (request_cancelled_idle, req);
+}
+
+static DWORD WINAPI
+lookup_by_name_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.name.retval = getaddrinfo (req->u.name.name, NULL,
+                                    &_g_resolver_addrinfo_hints,
+                                    &req->u.name.res);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_by_name (GWin32ResolverRequest *req)
+{
+  g_free (req->u.name.name);
+  if (req->u.name.res)
+    freeaddrinfo (req->u.name.res);
+}
+
+static void
+lookup_by_name_async (GResolver           *resolver,
+                      const gchar         *hostname,
+                      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+                      gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_by_name,
+                                      cancellable, callback, user_data,
+                                      lookup_by_name_async);
+  req->u.name.name = g_strdup (hostname);
+
+  QueueUserWorkItem (lookup_by_name_in_thread, req, 0);
+}
+
+static GList *
+lookup_by_name_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+                       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_name_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_addresses_from_addrinfo (req->u.name.name, req->u.name.res,
+                                              req->u.name.retval, error);
+}
+
+
+static DWORD WINAPI
+lookup_by_addresses_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.address.retval =
+    getnameinfo ((struct sockaddr *)&req->u.address.addr,
+                 req->u.address.addrlen,
+                 req->u.address.namebuf, NI_MAXHOST, NULL, 0, NI_NAMEREQD);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_by_address (GWin32ResolverRequest *req)
+{
+  g_object_unref (req->u.address.iaddr);
+  g_free (req->u.address.namebuf);
+}
+
+static void
+lookup_by_address_async (GResolver           *resolver,
+                         GInetAddress        *address,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_by_address,
+                                      cancellable, callback, user_data,
+                                      lookup_by_address_async);
+
+  req->u.address.iaddr = g_object_ref (address);
+  _g_resolver_address_to_sockaddr (address, &req->u.address.addr,
+                                   &req->u.address.addrlen);
+  req->u.address.namebuf = g_malloc (NI_MAXHOST);
+
+  QueueUserWorkItem (lookup_by_addresses_in_thread, req, 0);
+}
+
+static char *
+lookup_by_address_finish (GResolver     *resolver,
+                          GAsyncResult  *result,
+                          GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_by_address_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_name_from_nameinfo (req->u.address.iaddr,
+                                         req->u.address.namebuf,
+                                         req->u.address.retval, error);
+}
+
+
+static DWORD WINAPI
+lookup_service_in_thread (LPVOID data)
+{
+  GWin32ResolverRequest *req = data;
+
+  req->u.service.retval =
+    DnsQuery_A (req->u.service.rrname, DNS_TYPE_SRV, DNS_QUERY_STANDARD,
+                NULL, &req->u.service.results, NULL);
+  SetEvent (req->event);
+  return 0;
+}
+
+static void
+free_lookup_service (GWin32ResolverRequest *req)
+{
+  g_free (req->u.service.rrname);
+  if (req->u.service.results)
+    DnsRecordListFree (req->u.service.results, DnsFreeRecordList);
+}
+
+static void
+lookup_service_async (GResolver           *resolver,
+                      const char          *rrname,
+		      GCancellable        *cancellable,
+                      GAsyncReadyCallback  callback,
+		      gpointer             user_data)
+{
+  GWin32ResolverRequest *req;
+
+  req = g_win32_resolver_request_new (resolver, free_lookup_service,
+                                      cancellable, callback, user_data,
+                                      lookup_service_async);
+  req->u.service.rrname = g_strdup (rrname);
+
+  QueueUserWorkItem (lookup_service_in_thread, req, 0);
+}
+
+static GList *
+lookup_service_finish (GResolver     *resolver,
+                       GAsyncResult  *result,
+		       GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  GWin32ResolverRequest *req;
+
+  g_return_val_if_fail (g_simple_async_result_is_valid (result, G_OBJECT (resolver), lookup_service_async), NULL);
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  req = g_simple_async_result_get_op_res_gpointer (simple);
+  return _g_resolver_targets_from_DnsQuery (req->u.service.rrname,
+                                            req->u.service.retval,
+                                            req->u.service.results, error);
+}
+
+
+static void
+g_win32_resolver_class_init (GWin32ResolverClass *win32_class)
+{
+  GResolverClass *resolver_class = G_RESOLVER_CLASS (win32_class);
+
+  resolver_class->lookup_by_name_async     = lookup_by_name_async;
+  resolver_class->lookup_by_name_finish    = lookup_by_name_finish;
+  resolver_class->lookup_by_address_async  = lookup_by_address_async;
+  resolver_class->lookup_by_address_finish = lookup_by_address_finish;
+  resolver_class->lookup_service_async     = lookup_service_async;
+  resolver_class->lookup_service_finish    = lookup_service_finish;
+}
+
+
+/* Windows HANDLE GSource */
+
+typedef struct {
+  GSource source;
+  GPollFD pollfd;
+} GWin32HandleSource;
+
+static gboolean
+g_win32_handle_source_prepare (GSource *source,
+                               gint    *timeout)
+{
+  *timeout = -1;
+  return FALSE;
+}
+
+static gboolean
+g_win32_handle_source_check (GSource *source)
+{
+  GWin32HandleSource *hsource = (GWin32HandleSource *)source;
+
+  return hsource->pollfd.revents;
+}
+
+static gboolean
+g_win32_handle_source_dispatch (GSource     *source,
+                                GSourceFunc  callback,
+                                gpointer     user_data)
+{
+  return (*callback) (user_data);
+}
+
+static void
+g_win32_handle_source_finalize (GSource *source)
+{
+  ;
+}
+
+GSourceFuncs g_win32_handle_source_funcs = {
+  g_win32_handle_source_prepare,
+  g_win32_handle_source_check,
+  g_win32_handle_source_dispatch,
+  g_win32_handle_source_finalize
+};
+
+static GSource *
+g_win32_handle_source_add (HANDLE      handle,
+                           GSourceFunc callback,
+                           gpointer    user_data)
+{
+  GWin32HandleSource *hsource;
+  GSource *source;
+
+  source = g_source_new (&g_win32_handle_source_funcs, sizeof (GWin32HandleSource));
+  hsource = (GWin32HandleSource *)source;
+  hsource->pollfd.fd = (gint)handle;
+  hsource->pollfd.events = G_IO_IN;
+  hsource->pollfd.revents = 0;
+  g_source_add_poll (source, &hsource->pollfd);
+
+  g_source_set_callback (source, callback, user_data, NULL);
+  g_source_attach (source, NULL);
+  return source;
+}
+
+#define __G_WIN32_RESOLVER_C__
+#include "gioaliasdef.c"
diff --git a/gio/gwin32resolver.h b/gio/gwin32resolver.h
new file mode 100644
index 0000000..5cc6a2c
--- /dev/null
+++ b/gio/gwin32resolver.h
@@ -0,0 +1,49 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __G_WIN32_RESOLVER_H__
+#define __G_WIN32_RESOLVER_H__
+
+#include <gio/gthreadedresolver.h>
+
+G_BEGIN_DECLS
+
+#define G_TYPE_WIN32_RESOLVER         (g_win32_resolver_get_type ())
+#define G_WIN32_RESOLVER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_WIN32_RESOLVER, GWin32Resolver))
+#define G_WIN32_RESOLVER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_WIN32_RESOLVER, GWin32ResolverClass))
+#define G_IS_WIN32_RESOLVER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_WIN32_RESOLVER))
+#define G_IS_WIN32_RESOLVER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_WIN32_RESOLVER))
+#define G_WIN32_RESOLVER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_WIN32_RESOLVER, GWin32ResolverClass))
+
+typedef struct {
+  GThreadedResolver parent_instance;
+
+} GWin32Resolver;
+
+typedef struct {
+  GThreadedResolverClass parent_class;
+
+} GWin32ResolverClass;
+
+GType g_win32_resolver_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __G_RESOLVER_H__ */
diff --git a/gio/libasyncns/Makefile.am b/gio/libasyncns/Makefile.am
new file mode 100644
index 0000000..80b20a2
--- /dev/null
+++ b/gio/libasyncns/Makefile.am
@@ -0,0 +1,15 @@
+## Process this file with automake to produce Makefile.in
+include $(top_srcdir)/Makefile.decl
+
+INCLUDES = -I$(top_srcdir)
+
+noinst_LTLIBRARIES = libasyncns.la
+
+libasyncns_la_SOURCES = \
+	asyncns.c \
+	asyncns.h \
+	g-asyncns.h
+
+libasyncns_la_LIBADD = $(LIBASYNCNS_LIBADD)
+
+EXTRA_DIST += README update.sh
diff --git a/gio/libasyncns/README b/gio/libasyncns/README
new file mode 100644
index 0000000..b926291
--- /dev/null
+++ b/gio/libasyncns/README
@@ -0,0 +1,7 @@
+The sources are derived from Lennart Poettering's libasyncns library:
+
+ http://0pointer.de/lennart/projects/libasyncns/
+
+The 'update.sh' script in this directory, when pointed at
+the original sources updates the files in this directory
+to the new version
diff --git a/gio/libasyncns/asyncns.c b/gio/libasyncns/asyncns.c
new file mode 100644
index 0000000..3c4db73
--- /dev/null
+++ b/gio/libasyncns/asyncns.c
@@ -0,0 +1,1498 @@
+/***
+  This file is part of libasyncns.
+
+  Copyright 2005-2008 Lennart Poettering
+
+  libasyncns is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation, either version 2.1 of the
+  License, or (at your option) any later version.
+
+  libasyncns is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with libasyncns. If not, see
+  <http://www.gnu.org/licenses/>.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include "g-asyncns.h"
+#endif
+
+/* #undef HAVE_PTHREAD */
+
+#include <assert.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/select.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <netinet/in.h>
+#include <arpa/nameser.h>
+#include <resolv.h>
+#include <dirent.h>
+
+#if HAVE_ARPA_NAMESER_COMPAT_H
+#include <arpa/nameser_compat.h>
+#endif
+
+#ifdef HAVE_SYS_PRCTL_H
+#include <sys/prctl.h>
+#endif
+
+#if HAVE_PTHREAD
+#include <pthread.h>
+#endif
+
+#include "asyncns.h"
+
+#ifndef MSG_NOSIGNAL
+#define MSG_NOSIGNAL 0
+#endif
+
+#define MAX_WORKERS 16
+#define MAX_QUERIES 256
+#define BUFSIZE (10240)
+
+typedef enum {
+    REQUEST_ADDRINFO,
+    RESPONSE_ADDRINFO,
+    REQUEST_NAMEINFO,
+    RESPONSE_NAMEINFO,
+    REQUEST_RES_QUERY,
+    REQUEST_RES_SEARCH,
+    RESPONSE_RES,
+    REQUEST_TERMINATE,
+    RESPONSE_DIED
+} query_type_t;
+
+enum {
+    REQUEST_RECV_FD = 0,
+    REQUEST_SEND_FD = 1,
+    RESPONSE_RECV_FD = 2,
+    RESPONSE_SEND_FD = 3,
+    MESSAGE_FD_MAX = 4
+};
+
+struct asyncns {
+    int fds[4];
+
+#ifndef HAVE_PTHREAD
+    pid_t workers[MAX_WORKERS];
+#else
+    pthread_t workers[MAX_WORKERS];
+#endif
+    unsigned valid_workers;
+
+    unsigned current_id, current_index;
+    _g_asyncns_query_t* queries[MAX_QUERIES];
+
+    _g_asyncns_query_t *done_head, *done_tail;
+
+    int n_queries;
+    int dead;
+};
+
+struct _g_asyncns_query {
+    _g_asyncns_t *asyncns;
+    int done;
+    unsigned id;
+    query_type_t type;
+    _g_asyncns_query_t *done_next, *done_prev;
+    int ret;
+    int _errno;
+    int _h_errno;
+    struct addrinfo *addrinfo;
+    char *serv, *host;
+    void *userdata;
+};
+
+typedef struct rheader {
+    query_type_t type;
+    unsigned id;
+    size_t length;
+} rheader_t;
+
+typedef struct addrinfo_request {
+    struct rheader header;
+    int hints_is_null;
+    int ai_flags;
+    int ai_family;
+    int ai_socktype;
+    int ai_protocol;
+    size_t node_len, service_len;
+} addrinfo_request_t;
+
+typedef struct addrinfo_response {
+    struct rheader header;
+    int ret;
+    int _errno;
+    int _h_errno;
+    /* followed by addrinfo_serialization[] */
+} addrinfo_response_t;
+
+typedef struct addrinfo_serialization {
+    int ai_flags;
+    int ai_family;
+    int ai_socktype;
+    int ai_protocol;
+    size_t ai_addrlen;
+    size_t canonname_len;
+    /* Followed by ai_addr amd ai_canonname with variable lengths */
+} addrinfo_serialization_t;
+
+typedef struct nameinfo_request {
+    struct rheader header;
+    int flags;
+    socklen_t sockaddr_len;
+    int gethost, getserv;
+} nameinfo_request_t;
+
+typedef struct nameinfo_response {
+    struct rheader header;
+    size_t hostlen, servlen;
+    int ret;
+    int _errno;
+    int _h_errno;
+} nameinfo_response_t;
+
+typedef struct res_query_request {
+    struct rheader header;
+    int class;
+    int type;
+    size_t dname_len;
+} res_request_t;
+
+typedef struct res_query_response {
+    struct rheader header;
+    int ret;
+    int _errno;
+    int _h_errno;
+} res_response_t;
+
+#ifndef HAVE_STRNDUP
+
+static char *strndup(const char *s, size_t l) {
+    size_t a;
+    char *n;
+
+    a = strlen(s);
+    if (a > l)
+        a = l;
+
+    if (!(n = malloc(a+1)))
+        return NULL;
+
+    memcpy(n, s, a);
+    n[a] = 0;
+
+    return n;
+}
+
+#endif
+
+#ifndef HAVE_PTHREAD
+
+static int close_allv(const int except_fds[]) {
+    struct rlimit rl;
+    int fd;
+
+#ifdef __linux__
+
+    DIR *d;
+
+    assert(except_fds);
+
+    if ((d = opendir("/proc/self/fd"))) {
+
+        struct dirent *de;
+
+        while ((de = readdir(d))) {
+            int found;
+            long l;
+            char *e = NULL;
+            int i;
+
+            if (de->d_name[0] == '.')
+                continue;
+
+            errno = 0;
+            l = strtol(de->d_name, &e, 10);
+            if (errno != 0 || !e || *e) {
+                closedir(d);
+                errno = EINVAL;
+                return -1;
+            }
+
+            fd = (int) l;
+
+            if ((long) fd != l) {
+                closedir(d);
+                errno = EINVAL;
+                return -1;
+            }
+
+            if (fd < 3)
+                continue;
+
+            if (fd == dirfd(d))
+                continue;
+
+            found = 0;
+            for (i = 0; except_fds[i] >= 0; i++)
+                if (except_fds[i] == fd) {
+                    found = 1;
+                    break;
+                }
+
+            if (found)
+                continue;
+
+            if (close(fd) < 0) {
+                int saved_errno;
+
+                saved_errno = errno;
+                closedir(d);
+                errno = saved_errno;
+
+                return -1;
+            }
+        }
+
+        closedir(d);
+        return 0;
+    }
+
+#endif
+
+    if (getrlimit(RLIMIT_NOFILE, &rl) < 0)
+        return -1;
+
+    for (fd = 0; fd < (int) rl.rlim_max; fd++) {
+        int i;
+
+        if (fd <= 3)
+            continue;
+
+        for (i = 0; except_fds[i] >= 0; i++)
+            if (except_fds[i] == fd)
+                continue;
+
+        if (close(fd) < 0 && errno != EBADF)
+            return -1;
+    }
+
+    return 0;
+}
+
+static int reset_sigsv(const int except[]) {
+    int sig;
+    assert(except);
+
+    for (sig = 1; sig < NSIG; sig++) {
+        int reset = 1;
+
+        switch (sig) {
+            case SIGKILL:
+            case SIGSTOP:
+                reset = 0;
+                break;
+
+            default: {
+                int i;
+
+                for (i = 0; except[i] > 0; i++) {
+                    if (sig == except[i]) {
+                        reset = 0;
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (reset) {
+            struct sigaction sa;
+
+            memset(&sa, 0, sizeof(sa));
+            sa.sa_handler = SIG_DFL;
+
+            /* On Linux the first two RT signals are reserved by
+             * glibc, and sigaction() will return EINVAL for them. */
+            if ((sigaction(sig, &sa, NULL) < 0))
+                if (errno != EINVAL)
+                    return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int ignore_sigsv(const int ignore[]) {
+    int i;
+    assert(ignore);
+
+    for (i = 0; ignore[i] > 0; i++) {
+        struct sigaction sa;
+
+        memset(&sa, 0, sizeof(sa));
+        sa.sa_handler = SIG_IGN;
+
+        if ((sigaction(ignore[i], &sa, NULL) < 0))
+            return -1;
+    }
+
+    return 0;
+}
+
+#endif
+
+static int fd_nonblock(int fd) {
+    int i;
+    assert(fd >= 0);
+
+    if ((i = fcntl(fd, F_GETFL, 0)) < 0)
+        return -1;
+
+    if (i & O_NONBLOCK)
+        return 0;
+
+    return fcntl(fd, F_SETFL, i | O_NONBLOCK);
+}
+
+static int fd_cloexec(int fd) {
+    int v;
+    assert(fd >= 0);
+
+    if ((v = fcntl(fd, F_GETFD, 0)) < 0)
+        return -1;
+
+    if (v & FD_CLOEXEC)
+        return 0;
+
+    return fcntl(fd, F_SETFD, v | FD_CLOEXEC);
+}
+
+static int send_died(int out_fd) {
+    rheader_t rh;
+    assert(out_fd > 0);
+
+    memset(&rh, 0, sizeof(rh));
+    rh.type = RESPONSE_DIED;
+    rh.id = 0;
+    rh.length = sizeof(rh);
+
+    return send(out_fd, &rh, rh.length, MSG_NOSIGNAL);
+}
+
+static void *serialize_addrinfo(void *p, const struct addrinfo *ai, size_t *length, size_t maxlength) {
+    addrinfo_serialization_t s;
+    size_t cnl, l;
+    assert(p);
+    assert(ai);
+    assert(length);
+    assert(*length <= maxlength);
+
+    cnl = (ai->ai_canonname ? strlen(ai->ai_canonname)+1 : 0);
+    l = sizeof(addrinfo_serialization_t) + ai->ai_addrlen + cnl;
+
+    if (*length + l > maxlength)
+        return NULL;
+
+    s.ai_flags = ai->ai_flags;
+    s.ai_family = ai->ai_family;
+    s.ai_socktype = ai->ai_socktype;
+    s.ai_protocol = ai->ai_protocol;
+    s.ai_addrlen = ai->ai_addrlen;
+    s.canonname_len = cnl;
+
+    memcpy((uint8_t*) p, &s, sizeof(addrinfo_serialization_t));
+    memcpy((uint8_t*) p + sizeof(addrinfo_serialization_t), ai->ai_addr, ai->ai_addrlen);
+
+    if (ai->ai_canonname)
+        strcpy((char*) p + sizeof(addrinfo_serialization_t) + ai->ai_addrlen, ai->ai_canonname);
+
+    *length += l;
+    return (uint8_t*) p + l;
+}
+
+static int send_addrinfo_reply(int out_fd, unsigned id, int ret, struct addrinfo *ai, int _errno, int _h_errno) {
+    addrinfo_response_t data[BUFSIZE/sizeof(addrinfo_response_t) + 1];
+    addrinfo_response_t *resp = data;
+    assert(out_fd >= 0);
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_ADDRINFO;
+    resp->header.id = id;
+    resp->header.length = sizeof(addrinfo_response_t);
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+
+    if (ret == 0 && ai) {
+        void *p = data + 1;
+        struct addrinfo *k;
+
+        for (k = ai; k; k = k->ai_next) {
+
+            if (!(p = serialize_addrinfo(p, k, &resp->header.length, (char*) data + BUFSIZE - (char*) p))) {
+                resp->ret = EAI_MEMORY;
+                break;
+            }
+        }
+    }
+
+    if (ai)
+        freeaddrinfo(ai);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int send_nameinfo_reply(int out_fd, unsigned id, int ret, const char *host, const char *serv, int _errno, int _h_errno) {
+    nameinfo_response_t data[BUFSIZE/sizeof(nameinfo_response_t) + 1];
+    size_t hl, sl;
+    nameinfo_response_t *resp = data;
+
+    assert(out_fd >= 0);
+
+    sl = serv ? strlen(serv)+1 : 0;
+    hl = host ? strlen(host)+1 : 0;
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_NAMEINFO;
+    resp->header.id = id;
+    resp->header.length = sizeof(nameinfo_response_t) + hl + sl;
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+    resp->hostlen = hl;
+    resp->servlen = sl;
+
+    assert(sizeof(data) >= resp->header.length);
+
+    if (host)
+        memcpy((uint8_t *)data + sizeof(nameinfo_response_t), host, hl);
+
+    if (serv)
+        memcpy((uint8_t *)data + sizeof(nameinfo_response_t) + hl, serv, sl);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int send_res_reply(int out_fd, unsigned id, const unsigned char *answer, int ret, int _errno, int _h_errno) {
+    res_response_t data[BUFSIZE/sizeof(res_response_t) + 1];
+    res_response_t *resp = data;
+
+    assert(out_fd >= 0);
+
+    memset(data, 0, sizeof(data));
+    resp->header.type = RESPONSE_RES;
+    resp->header.id = id;
+    resp->header.length = sizeof(res_response_t) + (ret < 0 ? 0 : ret);
+    resp->ret = ret;
+    resp->_errno = _errno;
+    resp->_h_errno = _h_errno;
+
+    assert(sizeof(data) >= resp->header.length);
+
+    if (ret > 0)
+        memcpy((uint8_t *)data + sizeof(res_response_t), answer, ret);
+
+    return send(out_fd, resp, resp->header.length, MSG_NOSIGNAL);
+}
+
+static int handle_request(int out_fd, const rheader_t *req, size_t length) {
+    assert(out_fd >= 0);
+    assert(req);
+    assert(length >= sizeof(rheader_t));
+    assert(length == req->length);
+
+    switch (req->type) {
+        case REQUEST_ADDRINFO: {
+            struct addrinfo ai, *result = NULL;
+            const addrinfo_request_t *ai_req = (const addrinfo_request_t*) req;
+            const char *node, *service;
+            int ret;
+
+            assert(length >= sizeof(addrinfo_request_t));
+            assert(length == sizeof(addrinfo_request_t) + ai_req->node_len + ai_req->service_len);
+
+            memset(&ai, 0, sizeof(ai));
+            ai.ai_flags = ai_req->ai_flags;
+            ai.ai_family = ai_req->ai_family;
+            ai.ai_socktype = ai_req->ai_socktype;
+            ai.ai_protocol = ai_req->ai_protocol;
+
+            node = ai_req->node_len ? (const char*) req + sizeof(addrinfo_request_t) : NULL;
+            service = ai_req->service_len ? (const char*) req + sizeof(addrinfo_request_t) + ai_req->node_len : NULL;
+
+            ret = getaddrinfo(node, service,
+                              ai_req->hints_is_null ? NULL : &ai,
+                              &result);
+
+            /* send_addrinfo_reply() frees result */
+            return send_addrinfo_reply(out_fd, req->id, ret, result, errno, h_errno);
+        }
+
+        case REQUEST_NAMEINFO: {
+            int ret;
+            const nameinfo_request_t *ni_req = (const nameinfo_request_t*) req;
+            char hostbuf[NI_MAXHOST], servbuf[NI_MAXSERV];
+            struct sockaddr_storage sa;
+
+            assert(length >= sizeof(nameinfo_request_t));
+            assert(length == sizeof(nameinfo_request_t) + ni_req->sockaddr_len);
+
+            memcpy(&sa, (const uint8_t *)req + sizeof(nameinfo_request_t), ni_req->sockaddr_len);
+
+            ret = getnameinfo((struct sockaddr *)&sa, ni_req->sockaddr_len,
+                              ni_req->gethost ? hostbuf : NULL, ni_req->gethost ? sizeof(hostbuf) : 0,
+                              ni_req->getserv ? servbuf : NULL, ni_req->getserv ? sizeof(servbuf) : 0,
+                              ni_req->flags);
+
+            return send_nameinfo_reply(out_fd, req->id, ret,
+                                       ret == 0 && ni_req->gethost ? hostbuf : NULL,
+                                       ret == 0 && ni_req->getserv ? servbuf : NULL,
+                                       errno, h_errno);
+        }
+
+        case REQUEST_RES_QUERY:
+        case REQUEST_RES_SEARCH: {
+            int ret;
+            HEADER answer[BUFSIZE/sizeof(HEADER) + 1];
+            const res_request_t *res_req = (const res_request_t *)req;
+            const char *dname;
+
+            assert(length >= sizeof(res_request_t));
+            assert(length == sizeof(res_request_t) + res_req->dname_len);
+
+            dname = (const char *) req + sizeof(res_request_t);
+
+            if (req->type == REQUEST_RES_QUERY)
+                ret = res_query(dname, res_req->class, res_req->type, (unsigned char *) answer, BUFSIZE);
+            else
+                ret = res_search(dname, res_req->class, res_req->type, (unsigned char *) answer, BUFSIZE);
+
+            return send_res_reply(out_fd, req->id, (unsigned char *) answer, ret, errno, h_errno);
+        }
+
+        case REQUEST_TERMINATE:
+            /* Quit */
+            return -1;
+
+        default:
+            ;
+    }
+
+    return 0;
+}
+
+#ifndef HAVE_PTHREAD
+
+static int process_worker(int in_fd, int out_fd) {
+    int have_death_sig = 0;
+    int good_fds[3];
+    int ret = 1;
+
+    const int ignore_sigs[] = {
+        SIGINT,
+        SIGHUP,
+        SIGPIPE,
+        SIGUSR1,
+        SIGUSR2,
+        -1
+    };
+
+    assert(in_fd > 2);
+    assert(out_fd > 2);
+
+    close(0);
+    close(1);
+    close(2);
+
+    if (open("/dev/null", O_RDONLY) != 0)
+        goto fail;
+
+    if (open("/dev/null", O_WRONLY) != 1)
+        goto fail;
+
+    if (open("/dev/null", O_WRONLY) != 2)
+        goto fail;
+
+    if (chdir("/") < 0)
+        goto fail;
+
+    if (geteuid() == 0) {
+        struct passwd *pw;
+        int r;
+
+        if ((pw = getpwnam("nobody"))) {
+#ifdef HAVE_SETRESUID
+            r = setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid);
+#elif HAVE_SETREUID
+            r = setreuid(pw->pw_uid, pw->pw_uid);
+#else
+            if ((r = setuid(pw->pw_uid)) >= 0)
+                r = seteuid(pw->pw_uid);
+#endif
+            if (r < 0)
+                goto fail;
+        }
+    }
+
+    if (reset_sigsv(ignore_sigs) < 0)
+        goto fail;
+
+    if (ignore_sigsv(ignore_sigs) < 0)
+        goto fail;
+
+    good_fds[0] = in_fd; good_fds[1] = out_fd; good_fds[2] = -1;
+    if (close_allv(good_fds) < 0)
+        goto fail;
+
+#ifdef PR_SET_PDEATHSIG
+    if (prctl(PR_SET_PDEATHSIG, SIGTERM) >= 0)
+        have_death_sig = 1;
+#endif
+
+    if (!have_death_sig)
+        fd_nonblock(in_fd);
+
+    while (getppid() > 1) { /* if the parent PID is 1 our parent process died. */
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t length;
+
+        if (!have_death_sig) {
+            fd_set fds;
+            struct timeval tv = { 0, 500000 };
+
+            FD_ZERO(&fds);
+            FD_SET(in_fd, &fds);
+
+            if (select(in_fd+1, &fds, NULL, NULL, &tv) < 0)
+                break;
+
+            if (getppid() == 1)
+                break;
+        }
+
+        if ((length = recv(in_fd, buf, sizeof(buf), 0)) <= 0) {
+
+            if (length < 0 &&
+                (errno == EAGAIN || errno == EINTR))
+                continue;
+
+            break;
+        }
+
+        if (handle_request(out_fd, buf, (size_t) length) < 0)
+            break;
+    }
+
+    ret = 0;
+
+fail:
+    send_died(out_fd);
+
+    return ret;
+}
+
+#else
+
+static void* thread_worker(void *p) {
+    _g_asyncns_t *asyncns = p;
+    sigset_t fullset;
+
+    /* No signals in this thread please */
+    sigfillset(&fullset);
+    pthread_sigmask(SIG_BLOCK, &fullset, NULL);
+
+    while (!asyncns->dead) {
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t length;
+
+        if ((length = recv(asyncns->fds[REQUEST_RECV_FD], buf, sizeof(buf), 0)) <= 0) {
+
+            if (length < 0 &&
+                (errno == EAGAIN || errno == EINTR))
+                continue;
+
+            break;
+        }
+
+        if (asyncns->dead)
+            break;
+
+        if (handle_request(asyncns->fds[RESPONSE_SEND_FD], buf, (size_t) length) < 0)
+            break;
+    }
+
+    send_died(asyncns->fds[RESPONSE_SEND_FD]);
+
+    return NULL;
+}
+
+#endif
+
+_g_asyncns_t* _g_asyncns_new(unsigned n_proc) {
+    _g_asyncns_t *asyncns = NULL;
+    int i;
+    assert(n_proc >= 1);
+
+    if (n_proc > MAX_WORKERS)
+        n_proc = MAX_WORKERS;
+
+    if (!(asyncns = malloc(sizeof(_g_asyncns_t)))) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    asyncns->dead = 0;
+    asyncns->valid_workers = 0;
+
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        asyncns->fds[i] = -1;
+
+    memset(asyncns->queries, 0, sizeof(asyncns->queries));
+
+    if (socketpair(PF_UNIX, SOCK_DGRAM, 0, asyncns->fds) < 0 ||
+        socketpair(PF_UNIX, SOCK_DGRAM, 0, asyncns->fds+2) < 0)
+        goto fail;
+
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        fd_cloexec(asyncns->fds[i]);
+
+    for (asyncns->valid_workers = 0; asyncns->valid_workers < n_proc; asyncns->valid_workers++) {
+
+#ifndef HAVE_PTHREAD
+        if ((asyncns->workers[asyncns->valid_workers] = fork()) < 0)
+            goto fail;
+        else if (asyncns->workers[asyncns->valid_workers] == 0) {
+            int ret;
+
+            close(asyncns->fds[REQUEST_SEND_FD]);
+            close(asyncns->fds[RESPONSE_RECV_FD]);
+            ret = process_worker(asyncns->fds[REQUEST_RECV_FD], asyncns->fds[RESPONSE_SEND_FD]);
+            close(asyncns->fds[REQUEST_RECV_FD]);
+            close(asyncns->fds[RESPONSE_SEND_FD]);
+            _exit(ret);
+        }
+#else
+        int r;
+
+        if ((r = pthread_create(&asyncns->workers[asyncns->valid_workers], NULL, thread_worker, asyncns)) != 0) {
+            errno = r;
+            goto fail;
+        }
+#endif
+    }
+
+#ifndef HAVE_PTHREAD
+    close(asyncns->fds[REQUEST_RECV_FD]);
+    close(asyncns->fds[RESPONSE_SEND_FD]);
+    asyncns->fds[REQUEST_RECV_FD] = asyncns->fds[RESPONSE_SEND_FD] = -1;
+#endif
+
+    asyncns->current_index = asyncns->current_id = 0;
+    asyncns->done_head = asyncns->done_tail = NULL;
+    asyncns->n_queries = 0;
+
+    fd_nonblock(asyncns->fds[RESPONSE_RECV_FD]);
+
+    return asyncns;
+
+fail:
+    if (asyncns)
+        _g_asyncns_free(asyncns);
+
+    return NULL;
+}
+
+void _g_asyncns_free(_g_asyncns_t *asyncns) {
+    int i;
+    int saved_errno = errno;
+    unsigned p;
+
+    assert(asyncns);
+
+    asyncns->dead = 1;
+
+    if (asyncns->fds[REQUEST_SEND_FD] >= 0) {
+        rheader_t req;
+
+        memset(&req, 0, sizeof(req));
+        req.type = REQUEST_TERMINATE;
+        req.length = sizeof(req);
+        req.id = 0;
+
+        /* Send one termination packet for each worker */
+        for (p = 0; p < asyncns->valid_workers; p++)
+            send(asyncns->fds[REQUEST_SEND_FD], &req, req.length, MSG_NOSIGNAL);
+    }
+
+    /* Now terminate them and wait until they are gone. */
+    for (p = 0; p < asyncns->valid_workers; p++) {
+#ifndef HAVE_PTHREAD
+        kill(asyncns->workers[p], SIGTERM);
+        for (;;) {
+            if (waitpid(asyncns->workers[p], NULL, 0) >= 0 || errno != EINTR)
+                break;
+        }
+#else
+        for (;;) {
+            if (pthread_join(asyncns->workers[p], NULL) != EINTR)
+                break;
+        }
+#endif
+    }
+
+    /* Close all communication channels */
+    for (i = 0; i < MESSAGE_FD_MAX; i++)
+        if (asyncns->fds[i] >= 0)
+            close(asyncns->fds[i]);
+
+    for (p = 0; p < MAX_QUERIES; p++)
+        if (asyncns->queries[p])
+            _g_asyncns_cancel(asyncns, asyncns->queries[p]);
+
+    free(asyncns);
+
+    errno = saved_errno;
+}
+
+int _g_asyncns_fd(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+
+    return asyncns->fds[RESPONSE_RECV_FD];
+}
+
+static _g_asyncns_query_t *lookup_query(_g_asyncns_t *asyncns, unsigned id) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+
+    if ((q = asyncns->queries[id % MAX_QUERIES]))
+        if (q->id == id)
+            return q;
+
+    return NULL;
+}
+
+static void complete_query(_g_asyncns_t *asyncns, _g_asyncns_query_t *q) {
+    assert(asyncns);
+    assert(q);
+    assert(!q->done);
+
+    q->done = 1;
+
+    if ((q->done_prev = asyncns->done_tail))
+        asyncns->done_tail->done_next = q;
+    else
+        asyncns->done_head = q;
+
+    asyncns->done_tail = q;
+    q->done_next = NULL;
+}
+
+static void *unserialize_addrinfo(void *p, struct addrinfo **ret_ai, size_t *length) {
+    addrinfo_serialization_t s;
+    size_t l;
+    struct addrinfo *ai;
+    assert(p);
+    assert(ret_ai);
+    assert(length);
+
+    if (*length < sizeof(addrinfo_serialization_t))
+        return NULL;
+
+    memcpy(&s, p, sizeof(s));
+
+    l = sizeof(addrinfo_serialization_t) + s.ai_addrlen + s.canonname_len;
+    if (*length < l)
+        return NULL;
+
+    if (!(ai = malloc(sizeof(struct addrinfo))))
+        goto fail;
+
+    ai->ai_addr = NULL;
+    ai->ai_canonname = NULL;
+    ai->ai_next = NULL;
+
+    if (s.ai_addrlen && !(ai->ai_addr = malloc(s.ai_addrlen)))
+        goto fail;
+
+    if (s.canonname_len && !(ai->ai_canonname = malloc(s.canonname_len)))
+        goto fail;
+
+    ai->ai_flags = s.ai_flags;
+    ai->ai_family = s.ai_family;
+    ai->ai_socktype = s.ai_socktype;
+    ai->ai_protocol = s.ai_protocol;
+    ai->ai_addrlen = s.ai_addrlen;
+
+    if (ai->ai_addr)
+        memcpy(ai->ai_addr, (uint8_t*) p + sizeof(addrinfo_serialization_t), s.ai_addrlen);
+
+    if (ai->ai_canonname)
+        memcpy(ai->ai_canonname, (uint8_t*) p + sizeof(addrinfo_serialization_t) + s.ai_addrlen, s.canonname_len);
+
+    *length -= l;
+    *ret_ai = ai;
+
+    return (uint8_t*) p + l;
+
+
+fail:
+    if (ai)
+        _g_asyncns_freeaddrinfo(ai);
+
+    return NULL;
+}
+
+static int handle_response(_g_asyncns_t *asyncns, rheader_t *resp, size_t length) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+    assert(resp);
+    assert(length >= sizeof(rheader_t));
+    assert(length == resp->length);
+
+    if (resp->type == RESPONSE_DIED) {
+        asyncns->dead = 1;
+        return 0;
+    }
+
+    if (!(q = lookup_query(asyncns, resp->id)))
+        return 0;
+
+    switch (resp->type) {
+        case RESPONSE_ADDRINFO: {
+            const addrinfo_response_t *ai_resp = (addrinfo_response_t*) resp;
+            void *p;
+            size_t l;
+            struct addrinfo *prev = NULL;
+
+            assert(length >= sizeof(addrinfo_response_t));
+            assert(q->type == REQUEST_ADDRINFO);
+
+            q->ret = ai_resp->ret;
+            q->_errno = ai_resp->_errno;
+            q->_h_errno = ai_resp->_h_errno;
+            l = length - sizeof(addrinfo_response_t);
+            p = (uint8_t*) resp + sizeof(addrinfo_response_t);
+
+            while (l > 0 && p) {
+                struct addrinfo *ai = NULL;
+                p = unserialize_addrinfo(p, &ai, &l);
+
+                if (!p || !ai) {
+                    q->ret = EAI_MEMORY;
+                    break;
+                }
+
+                if (prev)
+                    prev->ai_next = ai;
+                else
+                    q->addrinfo = ai;
+
+                prev = ai;
+            }
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        case RESPONSE_NAMEINFO: {
+            const nameinfo_response_t *ni_resp = (nameinfo_response_t*) resp;
+
+            assert(length >= sizeof(nameinfo_response_t));
+            assert(q->type == REQUEST_NAMEINFO);
+
+            q->ret = ni_resp->ret;
+            q->_errno = ni_resp->_errno;
+            q->_h_errno = ni_resp->_h_errno;
+
+            if (ni_resp->hostlen)
+                if (!(q->host = strndup((const char*) ni_resp + sizeof(nameinfo_response_t), ni_resp->hostlen-1)))
+                    q->ret = EAI_MEMORY;
+
+            if (ni_resp->servlen)
+                if (!(q->serv = strndup((const char*) ni_resp + sizeof(nameinfo_response_t) + ni_resp->hostlen, ni_resp->servlen-1)))
+                    q->ret = EAI_MEMORY;
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        case RESPONSE_RES: {
+            const res_response_t *res_resp = (res_response_t *)resp;
+
+            assert(length >= sizeof(res_response_t));
+            assert(q->type == REQUEST_RES_QUERY || q->type == REQUEST_RES_SEARCH);
+
+            q->ret = res_resp->ret;
+            q->_errno = res_resp->_errno;
+            q->_h_errno = res_resp->_h_errno;
+
+            if (res_resp->ret >= 0)  {
+                if (!(q->serv = malloc(res_resp->ret))) {
+                    q->ret = -1;
+                    q->_errno = ENOMEM;
+                } else
+                    memcpy(q->serv, (char *)resp + sizeof(res_response_t), res_resp->ret);
+            }
+
+            complete_query(asyncns, q);
+            break;
+        }
+
+        default:
+            ;
+    }
+
+    return 0;
+}
+
+int _g_asyncns_wait(_g_asyncns_t *asyncns, int block) {
+    int handled = 0;
+    assert(asyncns);
+
+    for (;;) {
+        rheader_t buf[BUFSIZE/sizeof(rheader_t) + 1];
+        ssize_t l;
+
+        if (asyncns->dead) {
+            errno = ECHILD;
+            return -1;
+        }
+
+        if (((l = recv(asyncns->fds[RESPONSE_RECV_FD], buf, sizeof(buf), 0)) < 0)) {
+            fd_set fds;
+
+            if (errno != EAGAIN)
+                return -1;
+
+            if (!block || handled)
+                return 0;
+
+            FD_ZERO(&fds);
+            FD_SET(asyncns->fds[RESPONSE_RECV_FD], &fds);
+
+            if (select(asyncns->fds[RESPONSE_RECV_FD]+1, &fds, NULL, NULL, NULL) < 0)
+                return -1;
+
+            continue;
+        }
+
+        if (handle_response(asyncns, buf, (size_t) l) < 0)
+            return -1;
+
+        handled = 1;
+    }
+}
+
+static _g_asyncns_query_t *alloc_query(_g_asyncns_t *asyncns) {
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+
+    if (asyncns->n_queries >= MAX_QUERIES) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    while (asyncns->queries[asyncns->current_index]) {
+
+        asyncns->current_index++;
+        asyncns->current_id++;
+
+        while (asyncns->current_index >= MAX_QUERIES)
+            asyncns->current_index -= MAX_QUERIES;
+    }
+
+    if (!(q = asyncns->queries[asyncns->current_index] = malloc(sizeof(_g_asyncns_query_t)))) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    asyncns->n_queries++;
+
+    q->asyncns = asyncns;
+    q->done = 0;
+    q->id = asyncns->current_id;
+    q->done_next = q->done_prev = NULL;
+    q->ret = 0;
+    q->_errno = 0;
+    q->_h_errno = 0;
+    q->addrinfo = NULL;
+    q->userdata = NULL;
+    q->host = q->serv = NULL;
+
+    return q;
+}
+
+_g_asyncns_query_t* _g_asyncns_getaddrinfo(_g_asyncns_t *asyncns, const char *node, const char *service, const struct addrinfo *hints) {
+    addrinfo_request_t data[BUFSIZE/sizeof(addrinfo_request_t) + 1];
+    addrinfo_request_t *req = data;
+    _g_asyncns_query_t *q;
+    assert(asyncns);
+    assert(node || service);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(addrinfo_request_t));
+
+    req->node_len = node ? strlen(node)+1 : 0;
+    req->service_len = service ? strlen(service)+1 : 0;
+
+    req->header.id = q->id;
+    req->header.type = q->type = REQUEST_ADDRINFO;
+    req->header.length = sizeof(addrinfo_request_t) + req->node_len + req->service_len;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    if (!(req->hints_is_null = !hints)) {
+        req->ai_flags = hints->ai_flags;
+        req->ai_family = hints->ai_family;
+        req->ai_socktype = hints->ai_socktype;
+        req->ai_protocol = hints->ai_protocol;
+    }
+
+    if (node)
+        strcpy((char*) req + sizeof(addrinfo_request_t), node);
+
+    if (service)
+        strcpy((char*) req + sizeof(addrinfo_request_t) + req->node_len, service);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+int _g_asyncns_getaddrinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, struct addrinfo **ret_res) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_ADDRINFO);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return EAI_SYSTEM;
+    }
+
+    if (!q->done)
+        return EAI_AGAIN;
+
+    *ret_res = q->addrinfo;
+    q->addrinfo = NULL;
+
+    ret = q->ret;
+
+    if (ret == EAI_SYSTEM)
+        errno = q->_errno;
+
+    if (ret != 0)
+        h_errno = q->_h_errno;
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret;
+}
+
+_g_asyncns_query_t* _g_asyncns_getnameinfo(_g_asyncns_t *asyncns, const struct sockaddr *sa, socklen_t salen, int flags, int gethost, int getserv) {
+    nameinfo_request_t data[BUFSIZE/sizeof(nameinfo_request_t) + 1];
+    nameinfo_request_t *req = data;
+    _g_asyncns_query_t *q;
+
+    assert(asyncns);
+    assert(sa);
+    assert(salen > 0);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(nameinfo_request_t));
+
+    req->header.id = q->id;
+    req->header.type = q->type = REQUEST_NAMEINFO;
+    req->header.length = sizeof(nameinfo_request_t) + salen;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    req->flags = flags;
+    req->sockaddr_len = salen;
+    req->gethost = gethost;
+    req->getserv = getserv;
+
+    memcpy((uint8_t*) req + sizeof(nameinfo_request_t), sa, salen);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+int _g_asyncns_getnameinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, char *ret_host, size_t hostlen, char *ret_serv, size_t servlen) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_NAMEINFO);
+    assert(!ret_host || hostlen);
+    assert(!ret_serv || servlen);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return EAI_SYSTEM;
+    }
+
+    if (!q->done)
+        return EAI_AGAIN;
+
+    if (ret_host && q->host) {
+        strncpy(ret_host, q->host, hostlen);
+        ret_host[hostlen-1] = 0;
+    }
+
+    if (ret_serv && q->serv) {
+        strncpy(ret_serv, q->serv, servlen);
+        ret_serv[servlen-1] = 0;
+    }
+
+    ret = q->ret;
+
+    if (ret == EAI_SYSTEM)
+        errno = q->_errno;
+
+    if (ret != 0)
+        h_errno = q->_h_errno;
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret;
+}
+
+static _g_asyncns_query_t * _g_asyncns_res(_g_asyncns_t *asyncns, query_type_t qtype, const char *dname, int class, int type) {
+    res_request_t data[BUFSIZE/sizeof(res_request_t) + 1];
+    res_request_t *req = data;
+    _g_asyncns_query_t *q;
+
+    assert(asyncns);
+    assert(dname);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return NULL;
+    }
+
+    if (!(q = alloc_query(asyncns)))
+        return NULL;
+
+    memset(req, 0, sizeof(res_request_t));
+
+    req->dname_len = strlen(dname) + 1;
+
+    req->header.id = q->id;
+    req->header.type = q->type = qtype;
+    req->header.length = sizeof(res_request_t) + req->dname_len;
+
+    if (req->header.length > BUFSIZE) {
+        errno = ENOMEM;
+        goto fail;
+    }
+
+    req->class = class;
+    req->type = type;
+
+    strcpy((char*) req + sizeof(res_request_t), dname);
+
+    if (send(asyncns->fds[REQUEST_SEND_FD], req, req->header.length, MSG_NOSIGNAL) < 0)
+        goto fail;
+
+    return q;
+
+fail:
+    if (q)
+        _g_asyncns_cancel(asyncns, q);
+
+    return NULL;
+}
+
+_g_asyncns_query_t* _g_asyncns_res_query(_g_asyncns_t *asyncns, const char *dname, int class, int type) {
+    return _g_asyncns_res(asyncns, REQUEST_RES_QUERY, dname, class, type);
+}
+
+_g_asyncns_query_t* _g_asyncns_res_search(_g_asyncns_t *asyncns, const char *dname, int class, int type) {
+    return _g_asyncns_res(asyncns, REQUEST_RES_SEARCH, dname, class, type);
+}
+
+int _g_asyncns_res_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, unsigned char **answer) {
+    int ret;
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(q->type == REQUEST_RES_QUERY || q->type == REQUEST_RES_SEARCH);
+    assert(answer);
+
+    if (asyncns->dead) {
+        errno = ECHILD;
+        return -ECHILD;
+    }
+
+    if (!q->done) {
+        errno = EAGAIN;
+        return -EAGAIN;
+    }
+
+    *answer = (unsigned char *)q->serv;
+    q->serv = NULL;
+
+    ret = q->ret;
+
+    if (ret < 0) {
+        errno = q->_errno;
+        h_errno = q->_h_errno;
+    }
+
+    _g_asyncns_cancel(asyncns, q);
+
+    return ret < 0 ? -errno : ret;
+}
+
+_g_asyncns_query_t* _g_asyncns_getnext(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+    return asyncns->done_head;
+}
+
+int _g_asyncns_getnqueries(_g_asyncns_t *asyncns) {
+    assert(asyncns);
+    return asyncns->n_queries;
+}
+
+void _g_asyncns_cancel(_g_asyncns_t *asyncns, _g_asyncns_query_t* q) {
+    int i;
+    int saved_errno = errno;
+
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+    assert(asyncns->n_queries > 0);
+
+    if (q->done) {
+
+        if (q->done_prev)
+            q->done_prev->done_next = q->done_next;
+        else
+            asyncns->done_head = q->done_next;
+
+        if (q->done_next)
+            q->done_next->done_prev = q->done_prev;
+        else
+            asyncns->done_tail = q->done_prev;
+    }
+
+    i = q->id % MAX_QUERIES;
+    assert(asyncns->queries[i] == q);
+    asyncns->queries[i] = NULL;
+
+    _g_asyncns_freeaddrinfo(q->addrinfo);
+    free(q->host);
+    free(q->serv);
+
+    asyncns->n_queries--;
+    free(q);
+
+    errno = saved_errno;
+}
+
+void _g_asyncns_freeaddrinfo(struct addrinfo *ai) {
+    int saved_errno = errno;
+
+    while (ai) {
+        struct addrinfo *next = ai->ai_next;
+
+        free(ai->ai_addr);
+        free(ai->ai_canonname);
+        free(ai);
+
+        ai = next;
+    }
+
+    errno = saved_errno;
+}
+
+void _g_asyncns_freeanswer(unsigned char *answer) {
+    int saved_errno = errno;
+
+    if (!answer)
+        return;
+
+    /* Please note that this function is new in libasyncns 0.4. In
+     * older versions you were supposed to free the answer directly
+     * with free(). Hence, if this function is changed to do more than
+     * just a simple free() this must be considered ABI/API breakage! */
+
+    free(answer);
+
+    errno = saved_errno;
+}
+
+int _g_asyncns_isdone(_g_asyncns_t *asyncns, _g_asyncns_query_t*q) {
+    assert(asyncns);
+    assert(q);
+    assert(q->asyncns == asyncns);
+
+    return q->done;
+}
+
+void _g_asyncns_setuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q, void *userdata) {
+    assert(q);
+    assert(asyncns);
+    assert(q->asyncns = asyncns);
+
+    q->userdata = userdata;
+}
+
+void* _g_asyncns_getuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q) {
+    assert(q);
+    assert(asyncns);
+    assert(q->asyncns = asyncns);
+
+    return q->userdata;
+}
diff --git a/gio/libasyncns/asyncns.h b/gio/libasyncns/asyncns.h
new file mode 100644
index 0000000..b3d49ff
--- /dev/null
+++ b/gio/libasyncns/asyncns.h
@@ -0,0 +1,163 @@
+#ifndef fooasyncnshfoo
+#define fooasyncnshfoo
+
+/***
+  This file is part of libasyncns.
+
+  Copyright 2005-2008 Lennart Poettering
+
+  libasyncns is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation, either version 2.1 of the
+  License, or (at your option) any later version.
+
+  libasyncns is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with libasyncns. If not, see
+  <http://www.gnu.org/licenses/>.
+***/
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+
+/** \mainpage
+ *
+ * \section moo Method of operation
+ *
+ * To use libasyncns allocate an _g_asyncns_t object with
+ * _g_asyncns_new(). This will spawn a number of worker threads (or processes, depending on what is available) which
+ * are subsequently used to process the queries the controlling
+ * program issues via _g_asyncns_getaddrinfo() and
+ * _g_asyncns_getnameinfo(). Use _g_asyncns_free() to shut down the worker
+ * threads/processes.
+ *
+ * Since libasyncns may fork off new processes you have to make sure that
+ * your program is not irritated by spurious SIGCHLD signals.
+ */
+
+/** \example asyncns-test.c
+ * An example program */
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/** An opaque libasyncns session structure */
+typedef struct asyncns _g_asyncns_t;
+
+/** An opaque libasyncns query structure */
+typedef struct _g_asyncns_query _g_asyncns_query_t;
+
+/** Allocate a new libasyncns session with n_proc worker processes/threads */
+_g_asyncns_t* _g_asyncns_new(unsigned n_proc);
+
+/** Free a libasyncns session. This destroys all attached
+ * _g_asyncns_query_t objects automatically */
+void _g_asyncns_free(_g_asyncns_t *asyncns);
+
+/** Return the UNIX file descriptor to select() for readability
+ * on. Use this function to integrate libasyncns with your custom main
+ * loop. */
+int _g_asyncns_fd(_g_asyncns_t *asyncns);
+
+/** Process pending responses. After this function is called you can
+ * get the next completed query object(s) using _g_asyncns_getnext(). If
+ * block is non-zero wait until at least one response has been
+ * processed. If block is zero, process all pending responses and
+ * return. */
+int _g_asyncns_wait(_g_asyncns_t *asyncns, int block);
+
+/** Issue a name to address query on the specified session. The
+ * arguments are compatible with the ones of libc's
+ * getaddrinfo(3). The function returns a new query object. When the
+ * query is completed you may retrieve the results using
+ * _g_asyncns_getaddrinfo_done().*/
+_g_asyncns_query_t* _g_asyncns_getaddrinfo(_g_asyncns_t *asyncns, const char *node, const char *service, const struct addrinfo *hints);
+
+/** Retrieve the results of a preceding _g_asyncns_getaddrinfo()
+ * call. Returns a addrinfo structure and a return value compatible
+ * with libc's getaddrinfo(3). The query object q is destroyed by this
+ * call and may not be used any further. Make sure to free the
+ * returned addrinfo structure with _g_asyncns_freeaddrinfo() and not
+ * libc's freeaddrinfo(3)! If the query is not completed yet EAI_AGAIN
+ * is returned.*/
+int _g_asyncns_getaddrinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, struct addrinfo **ret_res);
+
+/** Issue an address to name query on the specified session. The
+ * arguments are compatible with the ones of libc's
+ * getnameinfo(3). The function returns a new query object. When the
+ * query is completed you may retrieve the results using
+ * _g_asyncns_getnameinfo_done(). Set gethost (resp. getserv) to non-zero
+ * if you want to query the hostname (resp. the service name). */
+_g_asyncns_query_t* _g_asyncns_getnameinfo(_g_asyncns_t *asyncns, const struct sockaddr *sa, socklen_t salen, int flags, int gethost, int getserv);
+
+/** Retrieve the results of a preceding _g_asyncns_getnameinfo()
+ * call. Returns the hostname and the service name in ret_host and
+ * ret_serv. The query object q is destroyed by this call and may not
+ * be used any further. If the query is not completed yet EAI_AGAIN is
+ * returned. */
+int _g_asyncns_getnameinfo_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, char *ret_host, size_t hostlen, char *ret_serv, size_t servlen);
+
+/** Issue a resolver query on the specified session. The arguments are
+ * compatible with the ones of libc's res_query(3). The function returns a new
+ * query object. When the query is completed you may retrieve the results using
+ * _g_asyncns_res_done().  */
+_g_asyncns_query_t* _g_asyncns_res_query(_g_asyncns_t *asyncns, const char *dname, int class, int type);
+
+/** Issue an resolver query on the specified session. The arguments are
+ * compatible with the ones of libc's res_search(3). The function returns a new
+ * query object. When the query is completed you may retrieve the results using
+ * _g_asyncns_res_done().  */
+_g_asyncns_query_t* _g_asyncns_res_search(_g_asyncns_t *asyncns, const char *dname, int class, int type);
+
+/** Retrieve the results of a preceding _g_asyncns_res_query() or
+ * _g_asyncns_res_search call.  The query object q is destroyed by this
+ * call and may not be used any further. Returns a pointer to the
+ * answer of the res_query call. If the query is not completed yet
+ * -EAGAIN is returned, on failure -errno is returned, otherwise the
+ * length of answer is returned. Make sure to free the answer is a
+ * call to _g_asyncns_freeanswer(). */
+int _g_asyncns_res_done(_g_asyncns_t *asyncns, _g_asyncns_query_t* q, unsigned char **answer);
+
+/** Return the next completed query object. If no query has been
+ * completed yet, return NULL. Please note that you need to run
+ * _g_asyncns_wait() before this function will return sensible data.  */
+_g_asyncns_query_t* _g_asyncns_getnext(_g_asyncns_t *asyncns);
+
+/** Return the number of query objects (completed or not) attached to
+ * this session */
+int _g_asyncns_getnqueries(_g_asyncns_t *asyncns);
+
+/** Cancel a currently running query. q is is destroyed by this call
+ * and may not be used any futher. */
+void _g_asyncns_cancel(_g_asyncns_t *asyncns, _g_asyncns_query_t* q);
+
+/** Free the addrinfo structure as returned by
+ * _g_asyncns_getaddrinfo_done(). Make sure to use this functions instead
+ * of the libc's freeaddrinfo()! */
+void _g_asyncns_freeaddrinfo(struct addrinfo *ai);
+
+/** Free the answer data as returned by _g_asyncns_res_done().*/
+void _g_asyncns_freeanswer(unsigned char *answer);
+
+/** Returns non-zero when the query operation specified by q has been completed */
+int _g_asyncns_isdone(_g_asyncns_t *asyncns, _g_asyncns_query_t*q);
+
+/** Assign some opaque userdata with a query object */
+void _g_asyncns_setuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q, void *userdata);
+
+/** Return userdata assigned to a query object. Use
+ * _g_asyncns_setuserdata() to set this data. If no data has been set
+ * prior to this call it returns NULL. */
+void* _g_asyncns_getuserdata(_g_asyncns_t *asyncns, _g_asyncns_query_t *q);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gio/libasyncns/g-asyncns.h b/gio/libasyncns/g-asyncns.h
new file mode 100644
index 0000000..a40fadb
--- /dev/null
+++ b/gio/libasyncns/g-asyncns.h
@@ -0,0 +1,28 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __G_ASYNCNS_H__
+
+#include "config.h"
+
+#define _GNU_SOURCE
+#undef HAVE_PTHREAD
+
+#include "asyncns.h"
+
+#endif
diff --git a/gio/libasyncns/update.sh b/gio/libasyncns/update.sh
new file mode 100644
index 0000000..4c43ca5
--- /dev/null
+++ b/gio/libasyncns/update.sh
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+if test $# = 1 ; then 
+  ORIGINAL=$1
+else
+  echo "Usage: update.sh /path/to/libasyncns" 1>&2
+  exit 1
+fi
+
+if test -f $ORIGINAL/libasyncns/asyncns.c ; then : ; else
+  echo "Usage: update.sh /path/to/libasyncns" 1>&2
+  exit 1
+fi
+
+for i in asyncns.c asyncns.h ; do
+  sed -e 's/\([^a-z]\)asyncns_/\1_g_asyncns_/g' \
+      -e 's/^asyncns_/_g_asyncns_/' \
+      -e 's/<config\.h>/"g-asyncns\.h"/' \
+    $ORIGINAL/libasyncns/$i > $i
+done
diff --git a/gio/pltcheck.sh b/gio/pltcheck.sh
index e09a587..be29be8 100755
--- a/gio/pltcheck.sh
+++ b/gio/pltcheck.sh
@@ -9,7 +9,7 @@ if ! which readelf 2>/dev/null >/dev/null; then
 	exit 0
 fi
 
-SKIP='\<g_access\|\<g_array_\|\<g_ascii\|\<g_list_\|\<g_assertion_message\|\<g_warn_message\|\<g_atomic\|\<g_build_filename\|\<g_byte_array\|\<g_child_watch\|\<g_convert\|\<g_dir_\|\<g_error_\|\<g_clear_error\|\<g_file_error_quark\|\<g_file_get_contents\|\<g_file_set_contents\|\<g_file_test\|\<g_file_read_link\|\<g_filename_\|\<g_find_program_in_path\|\<g_free\|\<g_get_\|\<g_getenv\|\<g_hash_table_\|\<g_idle_\|\<g_intern_static_string\|\<g_io_channel_\|\<g_key_file_\|\<g_listenv\|\<g_locale_to_utf8\|\<g_log\|\<g_main_context_wakeup\|\<g_malloc\|\<g_markup_\|\<g_mkdir_\|\<g_mkstemp\|\<g_module_\|\<g_object_\|\<g_once_\|\<g_param_spec_\|\<g_path_\|\<g_printerr\|\<g_propagate_error\|\<g_ptr_array_\|\<g_qsort_\|\<g_quark_\|\<g_queue_\|\<g_realloc\|\<g_return_if_fail\|\<g_set_error\|\<g_shell_\|\<g_signal_\|\<g_slice_\|\<g_slist_\|\<g_snprintf\|\<g_source_\|\<g_spawn_\|\<g_static_\|\<g_str\|\<g_thread_pool_\|\<g_time_val_add\|\<g_timeout_\|\<g_type_\|\<g_unlink\|\<g_uri_\|\<g_utf8_\|\<g_value_\|\<g_enum_\|\<g_flags_\|\<g_checksum\|\<g_io_add_watch\|\<g_bit_\|\<g_poll\|\<g_boxed'
+SKIP='\<g_access\|\<g_array_\|\<g_ascii\|\<g_list_\|\<g_assertion_message\|\<g_warn_message\|\<g_atomic\|\<g_bit_\|\<g_boxed\|\<g_build_filename\|\<g_byte_array\|\<g_checksum\|\<g_child_watch\|\<g_clear_error\|\<g_convert\|\<g_dir_\|\<g_enum_\|\<g_error_\|\<g_file_error_quark\|\<g_file_get_contents\|\<g_file_set_contents\|\<g_file_test\|\<g_file_read_link\|\<g_filename_\|\<g_find_program_in_path\|\<g_flags_\|\<g_free\|\<g_get_\|\<g_getenv\|\<g_hash_table_\|\<g_hostname_\|\<g_idle_\|\<g_intern_static_string\|\<g_io_add_watch\|\<g_io_channel_\|\<g_key_file_\|\<g_listenv\|\<g_locale_to_utf8\|\<g_log\|\<g_main_context_wakeup\|\<g_malloc\|\<g_markup_\|\<g_mkdir_\|\<g_mkstemp\|\<g_module_\|\<g_object_\|\<g_once_\|\<g_param_spec_\|\<g_path_\|\<g_poll\|\<g_printerr\|\<g_propagate_error\|\<g_ptr_array_\|\<g_qsort_\|\<g_quark_\|\<g_queue_\|\<g_random_int_range\|\<g_realloc\|\<g_return_if_fail\|\<g_set_error\|\<g_shell_\|\<g_signal_\|\<g_slice_\|\<g_slist_\|\<g_snprintf\|\<g_source_\|\<g_spawn_\|\<g_static_\|\<g_str\|\<g_thread_pool_\|\<g_time_val_add\|\<g_timeout_\|\<g_type_\|\<g_unlink\|\<g_uri_\|\<g_utf8_\|\<g_value_'
 
 for so in .libs/lib*.so; do
 	echo Checking $so for local PLT entries
diff --git a/gio/tests/Makefile.am b/gio/tests/Makefile.am
index 70a9ae8..eddaaa2 100644
--- a/gio/tests/Makefile.am
+++ b/gio/tests/Makefile.am
@@ -9,7 +9,7 @@ INCLUDES = 			\
 	-I$(top_srcdir)/gio 	\
 	$(GLIB_DEBUG_FLAGS)
 
-noinst_PROGRAMS = $(TEST_PROGS)
+noinst_PROGRAMS = $(TEST_PROGS) $(SAMPLE_PROGS)
 progs_ldadd     = 					\
 	$(top_builddir)/glib/libglib-2.0.la 		\
 	$(top_builddir)/gobject/libgobject-2.0.la	\
@@ -29,6 +29,8 @@ TEST_PROGS +=	 		\
 	filter-streams		\
 	simple-async-result
 
+SAMPLE_PROGS = resolver
+
 if OS_UNIX
 TEST_PROGS += live-g-file unix-streams desktop-app-info
 endif
@@ -76,4 +78,8 @@ sleepy_stream_LDADD		= $(progs_ldadd)
 filter_streams_SOURCES		= filter-streams.c
 filter_streams_LDADD		= $(progs_ldadd)
 
+resolver_SOURCES	  = resolver.c
+resolver_LDADD		  = $(progs_ldadd) \
+	$(top_builddir)/gthread/libgthread-2.0.la
+
 DISTCLEAN_FILES = applications/mimeinfo.cache
diff --git a/gio/tests/resolver.c b/gio/tests/resolver.c
new file mode 100644
index 0000000..4f0b71b
--- /dev/null
+++ b/gio/tests/resolver.c
@@ -0,0 +1,502 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include <glib.h>
+#include "glibintl.h"
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <gio/gio.h>
+
+static GResolver *resolver;
+static GCancellable *cancellable;
+static GMainLoop *loop;
+static int nlookups = 0;
+
+static void
+usage (void)
+{
+	fprintf (stderr, "Usage: resolver [-t] [-s] [hostname | IP | service/protocol/domain ] ...\n");
+	fprintf (stderr, "       resolver [-t] [-s] -c [hostname | IP | service/protocol/domain ]\n");
+	fprintf (stderr, "       Use -t to enable threading.\n");
+	fprintf (stderr, "       Use -s to do synchronous lookups.\n");
+	fprintf (stderr, "       Both together will result in simultaneous lookups in multiple threads\n");
+	fprintf (stderr, "       Use -c (and only a single resolvable argument) to test GSocketConnectable.\n");
+	exit (1);
+}
+
+G_LOCK_DEFINE_STATIC (response);
+
+static void
+done_lookup (void)
+{
+  nlookups--;
+  if (nlookups == 0)
+    {
+      /* In the sync case we need to make sure we don't call
+       * g_main_loop_quit before the loop is actually running...
+       */
+      g_idle_add ((GSourceFunc)g_main_loop_quit, loop);
+    }
+}
+
+static void
+print_resolved_name (const char *phys,
+                     char       *name,
+                     GError     *error)
+{
+  G_LOCK (response);
+  printf ("Address: %s\n", phys);
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      printf ("Name:    %s\n", name);
+      g_free (name);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+print_resolved_addresses (const char *name,
+                          GList      *addresses,
+			  GError     *error)
+{
+  char *phys;
+  GList *a;
+
+  G_LOCK (response);
+  printf ("Name:    %s\n", name);
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      for (a = addresses; a; a = a->next)
+	{
+	  phys = g_inet_address_to_string (a->data);
+	  printf ("Address: %s\n", phys);
+	  g_free (phys);
+          g_object_unref (a->data);
+	}
+      g_list_free (addresses);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+print_resolved_service (const char *service,
+                        GList      *targets,
+			GError     *error)
+{
+  GList *t;  
+
+  G_LOCK (response);
+  printf ("Service: %s\n", service);
+  if (error)
+    {
+      printf ("Error: %s\n", error->message);
+      g_error_free (error);
+    }
+  else
+    {
+      for (t = targets; t; t = t->next)
+	{
+	  printf ("%s:%u (pri %u, weight %u)\n",
+		  g_srv_target_get_hostname (t->data),
+		  g_srv_target_get_port (t->data),
+		  g_srv_target_get_priority (t->data),
+		  g_srv_target_get_weight (t->data));
+          g_srv_target_free (t->data);
+	}
+      g_list_free (targets);
+    }
+  printf ("\n");
+
+  done_lookup ();
+  G_UNLOCK (response);
+}
+
+static void
+lookup_one_sync (const char *arg)
+{
+  GError *error = NULL;
+
+  if (strchr (arg, '/'))
+    {
+      GList *targets;
+      /* service/protocol/domain */
+      char **parts = g_strsplit (arg, "/", 3);
+
+      if (!parts || !parts[2])
+	usage ();
+
+      targets = g_resolver_lookup_service (resolver,
+                                           parts[0], parts[1], parts[2],
+                                           cancellable, &error);
+      print_resolved_service (arg, targets, error);
+    }
+  else if (g_hostname_is_ip_address (arg))
+    {
+      GInetAddress *addr = g_inet_address_new_from_string (arg);
+      char *name;
+
+      name = g_resolver_lookup_by_address (resolver, addr, cancellable, &error);
+      print_resolved_name (arg, name, error);
+      g_object_unref (addr);
+    }
+  else
+    {
+      GList *addresses;
+
+      addresses = g_resolver_lookup_by_name (resolver, arg, cancellable, &error);
+      print_resolved_addresses (arg, addresses, error);
+    }
+}
+
+static gpointer
+lookup_thread (gpointer arg)
+{
+  lookup_one_sync (arg);
+  return NULL;
+}
+
+static void
+start_threaded_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    g_thread_create (lookup_thread, argv[i], FALSE, NULL);
+}
+
+static void
+start_sync_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    lookup_one_sync (argv[i]);
+}
+
+static void
+lookup_by_addr_callback (GObject *source, GAsyncResult *result,
+                         gpointer user_data)
+{
+  const char *phys = user_data;
+  GError *error = NULL;
+  char *name;
+
+  name = g_resolver_lookup_by_address_finish (resolver, result, &error);
+  print_resolved_name (phys, name, error);
+}
+
+static void
+lookup_by_name_callback (GObject *source, GAsyncResult *result,
+                         gpointer user_data)
+{
+  const char *name = user_data;
+  GError *error = NULL;
+  GList *addresses;
+
+  addresses = g_resolver_lookup_by_name_finish (resolver, result, &error);
+  print_resolved_addresses (name, addresses, error);
+}
+
+static void
+lookup_service_callback (GObject *source, GAsyncResult *result,
+			 gpointer user_data)
+{
+  const char *service = user_data;
+  GError *error = NULL;
+  GList *targets;
+
+  targets = g_resolver_lookup_service_finish (resolver, result, &error);
+  print_resolved_service (service, targets, error);
+}
+
+static void
+start_async_lookups (char **argv, int argc)
+{
+  int i;
+
+  for (i = 0; i < argc; i++)
+    {
+      if (strchr (argv[i], '/'))
+	{
+	  /* service/protocol/domain */
+	  char **parts = g_strsplit (argv[i], "/", 3);
+
+	  if (!parts || !parts[2])
+	    usage ();
+
+	  g_resolver_lookup_service_async (resolver,
+					   parts[0], parts[1], parts[2],
+					   cancellable,
+					   lookup_service_callback, argv[i]);
+	}
+      else if (g_hostname_is_ip_address (argv[i]))
+	{
+          GInetAddress *addr = g_inet_address_new_from_string (argv[i]);
+
+	  g_resolver_lookup_by_address_async (resolver, addr, cancellable,
+                                              lookup_by_addr_callback, argv[i]);
+	  g_object_unref (addr);
+	}
+      else
+	{
+	  g_resolver_lookup_by_name_async (resolver, argv[i], cancellable,
+                                           lookup_by_name_callback,
+                                           argv[i]);
+	}
+    }
+}
+
+static void
+print_connectable_sockaddr (GSocketAddress *sockaddr,
+                            GError         *error)
+{
+  char *phys;
+
+  if (error)
+    {
+      printf ("Error:   %s\n", error->message);
+      g_error_free (error);
+    }
+  else if (!G_IS_INET_SOCKET_ADDRESS (sockaddr))
+    {
+      printf ("Error:   Unexpected sockaddr type '%s'\n", g_type_name_from_instance ((GTypeInstance *)sockaddr));
+      g_object_unref (sockaddr);
+    }
+  else
+    {
+      GInetSocketAddress *isa = G_INET_SOCKET_ADDRESS (sockaddr);
+      phys = g_inet_address_to_string (g_inet_socket_address_get_address (isa));
+      printf ("Address: %s%s%s:%d\n",
+              strchr (phys, ':') ? "[" : "", phys, strchr (phys, ':') ? "]" : "",
+              g_inet_socket_address_get_port (isa));
+      g_free (phys);
+      g_object_unref (sockaddr);
+    }
+}
+
+static void
+do_sync_connectable (GSocketConnectable *connectable)
+{
+  GSocketAddress *sockaddr;
+  GError *error = NULL;
+
+  while ((sockaddr = g_socket_connectable_get_next (connectable, cancellable, &error)))
+    print_connectable_sockaddr (sockaddr, error);
+
+  g_object_unref (connectable);
+  done_lookup ();
+}
+
+static void do_async_connectable (GSocketConnectable *connectable);
+
+static void
+got_next_async (GObject *source, GAsyncResult *result, gpointer user_data)
+{
+  GSocketConnectable *connectable = G_SOCKET_CONNECTABLE (source);
+  GSocketAddress *sockaddr;
+  GError *error = NULL;
+
+  sockaddr = g_socket_connectable_get_next_finish (connectable, result, &error);
+  if (sockaddr || error)
+    print_connectable_sockaddr (sockaddr, error);
+  if (sockaddr)
+    do_async_connectable (connectable);
+  else
+    {
+      g_object_unref (connectable);
+      done_lookup ();
+    }
+}
+
+static void
+do_async_connectable (GSocketConnectable *connectable)
+{
+  g_socket_connectable_get_next_async (connectable, cancellable,
+                                       got_next_async, NULL);
+}
+
+static void
+do_connectable (const char *arg, gboolean synchronous)
+{
+  char **parts;
+  GSocketConnectable *connectable;
+
+  if (strchr (arg, '/'))
+    {
+      /* service/protocol/domain */
+      parts = g_strsplit (arg, "/", 3);
+      if (!parts || !parts[2])
+	usage ();
+
+      connectable = g_network_service_new (parts[0], parts[1], parts[2]);
+    }
+  else
+    {
+      guint16 port;
+
+      parts = g_strsplit (arg, ":", 2);
+      if (parts && parts[1])
+	{
+	  arg = parts[0];
+	  port = strtoul (parts[1], NULL, 10);
+	}
+      else
+	port = 0;
+
+      if (g_hostname_is_ip_address (arg))
+	{
+	  GInetAddress *addr = g_inet_address_new_from_string (arg);
+	  GSocketAddress *sockaddr = g_inet_socket_address_new (addr, port);
+
+	  g_object_unref (addr);
+	  connectable = G_SOCKET_CONNECTABLE (sockaddr);
+	}
+      else
+        connectable = g_network_address_new (arg, port);
+    }
+
+  if (synchronous)
+    do_sync_connectable (connectable);
+  else
+    do_async_connectable (connectable);
+}
+
+#ifdef G_OS_UNIX
+static int cancel_fds[2];
+
+static void
+interrupted (int sig)
+{
+  signal (SIGINT, SIG_DFL);
+  write (cancel_fds[1], "x", 1);
+}
+
+static gboolean
+async_cancel (GIOChannel *source, GIOCondition cond, gpointer cancellable)
+{
+  g_cancellable_cancel (cancellable);
+  return FALSE;
+}
+#endif
+
+int
+main (int argc, char **argv)
+{
+  gboolean threaded = FALSE, synchronous = FALSE;
+  gboolean use_connectable = FALSE;
+#ifdef G_OS_UNIX
+  GIOChannel *chan;
+  guint watch;
+#endif
+
+  /* We can't use GOptionContext because we use the arguments to
+   * decide whether or not to call g_thread_init().
+   */
+  while (argc >= 2 && argv[1][0] == '-')
+    {
+      if (!strcmp (argv[1], "-t"))
+        {
+          g_thread_init (NULL);
+          threaded = TRUE;
+        }
+      else if (!strcmp (argv[1], "-s"))
+        synchronous = TRUE;
+      else if (!strcmp (argv[1], "-c"))
+        use_connectable = TRUE;
+      else
+        usage ();
+
+      argv++;
+      argc--;
+    }
+  g_type_init ();
+
+  if (argc < 2 || (argc > 2 && use_connectable))
+    usage ();
+
+  resolver = g_resolver_get_default ();
+
+  cancellable = g_cancellable_new ();
+
+#ifdef G_OS_UNIX
+  /* Set up cancellation; we want to cancel if the user ^C's the
+   * program, but we can't cancel directly from an interrupt.
+   */
+  signal (SIGINT, interrupted);
+
+  if (pipe (cancel_fds) == -1)
+    {
+      perror ("pipe");
+      exit (1);
+    }
+  chan = g_io_channel_unix_new (cancel_fds[0]);
+  watch = g_io_add_watch (chan, G_IO_IN, async_cancel, cancellable);
+  g_io_channel_unref (chan);
+#endif
+
+  nlookups = argc - 1;
+  loop = g_main_loop_new (NULL, TRUE);
+
+  if (use_connectable)
+    do_connectable (argv[1], synchronous);
+  else
+    {
+      if (threaded && synchronous)
+        start_threaded_lookups (argv + 1, argc - 1);
+      else if (synchronous)
+        start_sync_lookups (argv + 1, argc - 1);
+      else
+        start_async_lookups (argv + 1, argc - 1);
+    }
+
+  g_main_run (loop);
+  g_main_loop_unref (loop);
+
+#ifdef G_OS_UNIX
+  g_source_remove (watch);
+#endif
+  g_object_unref (cancellable);
+
+  return 0;
+}
diff --git a/glib/Makefile.am b/glib/Makefile.am
index c6f20bb..eb220e6 100644
--- a/glib/Makefile.am
+++ b/glib/Makefile.am
@@ -116,6 +116,7 @@ libglib_2_0_la_SOURCES = 	\
 	gfileutils.c		\
 	ghash.c			\
 	ghook.c			\
+	ghostutils.c		\
 	giochannel.c    	\
 	gkeyfile.c        	\
 	glibintl.h		\
@@ -199,6 +200,7 @@ glibsubinclude_HEADERS =   \
 	gfileutils.h	\
 	ghash.h		\
 	ghook.h		\
+	ghostutils.h	\
 	gi18n.h		\
 	gi18n-lib.h	\
 	giochannel.h	\
diff --git a/glib/ghostutils.c b/glib/ghostutils.c
new file mode 100644
index 0000000..63e1dff
--- /dev/null
+++ b/glib/ghostutils.c
@@ -0,0 +1,758 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include "glib.h"
+#include "glibintl.h"
+
+#include <string.h>
+
+#include "galias.h"
+
+/**
+ * SECTION:ghostutils
+ * @short_description: Internet hostname utilities
+ * @include: glib.h
+ *
+ * Functions for manipulating internet hostnames; in particular, for
+ * converting between Unicode and ASCII-encoded forms of
+ * Internationalized Domain Names (IDNs).
+ *
+ * The <ulink
+ * link="http://www.ietf.org/rfc/rfc3490.txt">Internationalized Domain
+ * Names for Applications (IDNA)</ulink> standards allow for the use
+ * of Unicode domain names in applications, while providing
+ * backward-compatibility with the old ASCII-only DNS, by defining an
+ * ASCII-Compatible Encoding of any given Unicode name, which can be
+ * used with non-IDN-aware applications and protocols. (For example,
+ * ".org" maps to "xn--4wa8awb4637h.org".)
+ **/
+
+#define IDNA_ACE_PREFIX     "xn--"
+#define IDNA_ACE_PREFIX_LEN 4
+
+/* Punycode constants, from RFC 3492. */
+
+#define PUNYCODE_BASE          36
+#define PUNYCODE_TMIN           1
+#define PUNYCODE_TMAX          26
+#define PUNYCODE_SKEW          38
+#define PUNYCODE_DAMP         700
+#define PUNYCODE_INITIAL_BIAS  72
+#define PUNYCODE_INITIAL_N   0x80
+
+#define PUNYCODE_IS_BASIC(cp) ((guint)(cp) < 0x80)
+
+/* Encode/decode a single base-36 digit */
+static inline gchar
+encode_digit (guint dig)
+{
+  if (dig < 26)
+    return dig + 'a';
+  else
+    return dig - 26 + '0';
+}
+
+static inline guint
+decode_digit (gchar dig)
+{
+  if (dig >= 'A' && dig <= 'Z')
+    return dig - 'A';
+  else if (dig >= 'a' && dig <= 'z')
+    return dig - 'a';
+  else if (dig >= '0' && dig <= '9')
+    return dig - '0' + 26;
+  else
+    return G_MAXUINT;
+}
+
+/* Punycode bias adaptation algorithm, RFC 3492 section 6.1 */
+static guint
+adapt (guint    delta,
+       guint    numpoints,
+       gboolean firsttime)
+{
+  guint k;
+
+  delta = firsttime ? delta / PUNYCODE_DAMP : delta / 2;
+  delta += delta / numpoints;
+
+  k = 0;
+  while (delta > ((PUNYCODE_BASE - PUNYCODE_TMIN) * PUNYCODE_TMAX) / 2)
+    {
+      delta /= PUNYCODE_BASE - PUNYCODE_TMIN;
+      k += PUNYCODE_BASE;
+    }
+
+  return k + ((PUNYCODE_BASE - PUNYCODE_TMIN + 1) * delta /
+	      (delta + PUNYCODE_SKEW));
+}
+
+/* Punycode encoder, RFC 3492 section 6.3. The algorithm is
+ * sufficiently bizarre that it's not really worth trying to explain
+ * here.
+ */
+static gboolean
+punycode_encode (const gchar *input_utf8,
+                 gsize        input_utf8_length,
+		 GString     *output)
+{
+  guint delta, handled_chars, num_basic_chars, bias, j, q, k, t, digit;
+  gunichar n, m, *input;
+  glong input_length;
+  gboolean success = FALSE;
+
+  /* Convert from UTF-8 to Unicode code points */
+  input = g_utf8_to_ucs4 (input_utf8, input_utf8_length, NULL,
+			  &input_length, NULL);
+  if (!input)
+    return FALSE;
+
+  /* Copy basic chars */
+  for (j = num_basic_chars = 0; j < input_length; j++)
+    {
+      if (PUNYCODE_IS_BASIC (input[j]))
+	{
+	  g_string_append_c (output, g_ascii_tolower (input[j]));
+	  num_basic_chars++;
+	}
+    }
+  if (num_basic_chars)
+    g_string_append_c (output, '-');
+
+  handled_chars = num_basic_chars;
+
+  /* Encode non-basic chars */
+  delta = 0;
+  bias = PUNYCODE_INITIAL_BIAS;
+  n = PUNYCODE_INITIAL_N;
+  while (handled_chars < input_length)
+    {
+      /* let m = the minimum {non-basic} code point >= n in the input */
+      for (m = G_MAXUINT, j = 0; j < input_length; j++)
+	{
+	  if (input[j] >= n && input[j] < m)
+	    m = input[j];
+	}
+
+      if (m - n > (G_MAXUINT - delta) / (handled_chars + 1))
+	goto fail;
+      delta += (m - n) * (handled_chars + 1);
+      n = m;
+
+      for (j = 0; j < input_length; j++)
+	{
+	  if (input[j] < n)
+	    {
+	      if (++delta == 0)
+		goto fail;
+	    }
+	  else if (input[j] == n)
+	    {
+	      q = delta;
+	      for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
+		{
+		  if (k <= bias)
+		    t = PUNYCODE_TMIN;
+		  else if (k >= bias + PUNYCODE_TMAX)
+		    t = PUNYCODE_TMAX;
+		  else
+		    t = k - bias;
+		  if (q < t)
+		    break;
+		  digit = t + (q - t) % (PUNYCODE_BASE - t);
+		  g_string_append_c (output, encode_digit (digit));
+		  q = (q - t) / (PUNYCODE_BASE - t);
+		}
+
+	      g_string_append_c (output, encode_digit (q));
+	      bias = adapt (delta, handled_chars + 1, handled_chars == num_basic_chars);
+	      delta = 0;
+	      handled_chars++;
+	    }
+	}
+
+      delta++;
+      n++;
+    }
+
+  success = TRUE;
+
+ fail:
+  g_free (input);
+  return success;
+}
+
+/* From RFC 3454, Table B.1 */
+#define idna_is_junk(ch) ((ch) == 0x00AD || (ch) == 0x1806 || (ch) == 0x200B || (ch) == 0x2060 || (ch) == 0xFEFF || (ch) == 0x034F || (ch) == 0x180B || (ch) == 0x180C || (ch) == 0x180D || (ch) == 0x200C || (ch) == 0x200D || ((ch) >= 0xFE00 && (ch) <= 0xFE0F))
+
+/* Scan @str for "junk" and return a cleaned-up string if any junk
+ * is found. Else return %NULL.
+ */
+static gchar *
+remove_junk (const gchar *str,
+             gint         len)
+{
+  GString *cleaned = NULL;
+  const gchar *p;
+  gunichar ch;
+
+  for (p = str; len == -1 ? *p : p < str + len; p = g_utf8_next_char (p))
+    {
+      ch = g_utf8_get_char (p);
+      if (idna_is_junk (ch))
+	{
+	  if (!cleaned)
+	    {
+	      cleaned = g_string_new (NULL);
+	      g_string_append_len (cleaned, str, p - str);
+	    }
+	}
+      else if (cleaned)
+	g_string_append_unichar (cleaned, ch);
+    }
+
+  if (cleaned)
+    return g_string_free (cleaned, FALSE);
+  else
+    return NULL;
+}
+
+static inline gboolean
+contains_uppercase_letters (const gchar *str,
+                            gint         len)
+{
+  const gchar *p;
+
+  for (p = str; len == -1 ? *p : p < str + len; p = g_utf8_next_char (p))
+    {
+      if (g_unichar_isupper (g_utf8_get_char (p)))
+	return TRUE;
+    }
+  return FALSE;
+}
+
+static inline gboolean
+contains_non_ascii (const gchar *str,
+                    gint         len)
+{
+  const gchar *p;
+
+  for (p = str; len == -1 ? *p : p < str + len; p++)
+    {
+      if ((guchar)*p > 0x80)
+	return TRUE;
+    }
+  return FALSE;
+}
+
+/* RFC 3454, Appendix C. ish. */
+static inline gboolean
+idna_is_prohibited (gunichar ch)
+{
+  switch (g_unichar_type (ch))
+    {
+    case G_UNICODE_CONTROL:
+    case G_UNICODE_FORMAT:
+    case G_UNICODE_UNASSIGNED:
+    case G_UNICODE_PRIVATE_USE:
+    case G_UNICODE_SURROGATE:
+    case G_UNICODE_LINE_SEPARATOR:
+    case G_UNICODE_PARAGRAPH_SEPARATOR:
+    case G_UNICODE_SPACE_SEPARATOR:
+      return TRUE;
+
+    case G_UNICODE_OTHER_SYMBOL:
+      if (ch == 0xFFFC || ch == 0xFFFD ||
+	  (ch >= 0x2FF0 && ch <= 0x2FFB))
+	return TRUE;
+      return FALSE;
+
+    case G_UNICODE_NON_SPACING_MARK:
+      if (ch == 0x0340 || ch == 0x0341)
+	return TRUE;
+      return FALSE;
+
+    default:
+      return FALSE;
+    }
+}
+
+/* RFC 3491 IDN cleanup algorithm. */
+static gchar *
+nameprep (const gchar *hostname,
+          gint         len)
+{
+  gchar *name, *tmp = NULL, *p;
+
+  /* It would be nice if we could do this without repeatedly
+   * allocating strings and converting back and forth between
+   * gunichars and UTF-8... The code does at least avoid doing most of
+   * the sub-operations when they would just be equivalent to a
+   * g_strdup().
+   */
+
+  /* Remove presentation-only characters */
+  name = remove_junk (hostname, len);
+  if (name)
+    {
+      tmp = name;
+      len = -1;
+    }
+  else
+    name = (gchar *)hostname;
+
+  /* Convert to lowercase */
+  if (contains_uppercase_letters (name, len))
+    {
+      name = g_utf8_strdown (name, len);
+      g_free (tmp);
+      tmp = name;
+      len = -1;
+    }
+
+  /* If there are no UTF8 characters, we're done. */
+  if (!contains_non_ascii (name, len))
+    {
+      if (name == (gchar *)hostname)
+        return len == -1 ? g_strdup (hostname) : g_strndup (hostname, len);
+      else
+        return name;
+    }
+
+  /* Normalize */
+  name = g_utf8_normalize (name, len, G_NORMALIZE_NFKC);
+  g_free (tmp);
+  tmp = name;
+
+  /* KC normalization may have created more capital letters (eg,
+   * angstrom -> capital A with ring). So we have to lowercasify a
+   * second time. (This is more-or-less how the nameprep algorithm
+   * does it. If tolower(nfkc(tolower(X))) is guaranteed to be the
+   * same as tolower(nfkc(X)), then we could skip the first tolower,
+   * but I'm not sure it is.)
+   */
+  if (contains_uppercase_letters (name, -1))
+    {
+      name = g_utf8_strdown (name, -1);
+      g_free (tmp);
+      tmp = name;
+    }
+
+  /* Check for prohibited characters */
+  for (p = name; *p; p = g_utf8_next_char (p))
+    {
+      if (idna_is_prohibited (g_utf8_get_char (p)))
+	{
+	  name = NULL;
+          g_free (tmp);
+	  goto done;
+	}
+    }
+
+  /* FIXME: We're supposed to verify certain constraints on bidi
+   * characters, but glib does not appear to have that information.
+   */
+
+ done:
+  return name;
+}
+
+/**
+ * g_hostname_to_ascii:
+ * @hostname: a valid UTF-8 or ASCII hostname
+ *
+ * Converts @hostname to its canonical ASCII form; an ASCII-only
+ * string containing no uppercase letters and not ending with a
+ * trailing dot.
+ *
+ * Return value: an ASCII hostname, which must be freed, or %NULL if
+ * @hostname is in some way invalid.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_hostname_to_ascii (const gchar *hostname)
+{
+  gchar *name, *label, *p;
+  GString *out;
+  gssize llen, oldlen;
+  gboolean unicode;
+
+  out = g_string_new (NULL);
+  label = name = nameprep (hostname, -1);
+
+  do
+    {
+      unicode = FALSE;
+      for (p = label; *p && *p != '.'; p++)
+	{
+	  if ((guchar)*p > 0x80)
+	    unicode = TRUE;
+	}
+
+      oldlen = out->len;
+      llen = p - label;
+      if (unicode)
+	{
+          if (!strncmp (label, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+            goto fail;
+
+	  g_string_append (out, IDNA_ACE_PREFIX);
+	  if (!punycode_encode (label, llen, out))
+	    goto fail;
+	}
+      else
+        g_string_append_len (out, label, llen);
+
+      if (out->len - oldlen > 63)
+	goto fail;
+
+      label += llen;
+      if (*label && *++label)
+        g_string_append_c (out, '.');
+    }
+  while (*label);
+
+  g_free (name);
+  return g_string_free (out, FALSE);
+
+ fail:
+  g_free (name);
+  g_string_free (out, TRUE);
+  return NULL;
+}
+
+/**
+ * g_hostname_is_non_ascii:
+ * @hostname: a hostname
+ *
+ * Tests if @hostname contains Unicode characters. If this returns
+ * %TRUE, you need to encode the hostname with g_hostname_to_ascii()
+ * before using it in non-IDN-aware contexts.
+ *
+ * Note that a hostname might contain a mix of encoded and unencoded
+ * segments, and so it is possible for g_hostname_is_non_ascii() and
+ * g_hostname_is_ascii_encoded() to both return %TRUE for a name.
+ *
+ * Return value: %TRUE if @hostname contains any non-ASCII characters
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_non_ascii (const gchar *hostname)
+{
+  return contains_non_ascii (hostname, -1);
+}
+
+/* Punycode decoder, RFC 3492 section 6.2. As with punycode_encode(),
+ * read the RFC if you want to understand what this is actually doing.
+ */
+static gboolean
+punycode_decode (const gchar *input,
+                 gsize        input_length,
+                 GString     *output)
+{
+  GArray *output_chars;
+  gunichar n;
+  guint i, bias;
+  guint oldi, w, k, digit, t;
+  const gchar *split;
+
+  n = PUNYCODE_INITIAL_N;
+  i = 0;
+  bias = PUNYCODE_INITIAL_BIAS;
+
+  split = input + input_length - 1;
+  while (split > input && *split != '-')
+    split--;
+  if (split > input)
+    {
+      output_chars = g_array_sized_new (FALSE, FALSE, sizeof (gunichar),
+					split - input);
+      input_length -= (split - input) + 1;
+      while (input < split)
+	{
+	  gunichar ch = (gunichar)*input++;
+	  if (!PUNYCODE_IS_BASIC (ch))
+	    goto fail;
+	  g_array_append_val (output_chars, ch);
+	}
+      input++;
+    }
+  else
+    output_chars = g_array_new (FALSE, FALSE, sizeof (gunichar));
+
+  while (input_length)
+    {
+      oldi = i;
+      w = 1;
+      for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
+	{
+	  if (!input_length--)
+	    goto fail;
+	  digit = decode_digit (*input++);
+	  if (digit >= PUNYCODE_BASE)
+	    goto fail;
+	  if (digit > (G_MAXUINT - i) / w)
+	    goto fail;
+	  i += digit * w;
+	  if (k <= bias)
+	    t = PUNYCODE_TMIN;
+	  else if (k >= bias + PUNYCODE_TMAX)
+	    t = PUNYCODE_TMAX;
+	  else
+	    t = k - bias;
+	  if (digit < t)
+	    break;
+	  if (w > G_MAXUINT / (PUNYCODE_BASE - t))
+	    goto fail;
+	  w *= (PUNYCODE_BASE - t);
+	}
+
+      bias = adapt (i - oldi, output_chars->len + 1, oldi == 0);
+
+      if (i / (output_chars->len + 1) > G_MAXUINT - n)
+	goto fail;
+      n += i / (output_chars->len + 1);
+      i %= (output_chars->len + 1);
+
+      g_array_insert_val (output_chars, i++, n);
+    }
+
+  for (i = 0; i < output_chars->len; i++)
+    g_string_append_unichar (output, g_array_index (output_chars, gunichar, i));
+  g_array_free (output_chars, TRUE);
+  return TRUE;
+
+ fail:
+  g_array_free (output_chars, TRUE);
+  return FALSE;
+}
+
+/**
+ * g_hostname_to_unicode:
+ * @hostname: a valid UTF-8 or ASCII hostname
+ *
+ * Converts @hostname to its canonical presentation form; a UTF-8
+ * string in Unicode normalization form C, containing no uppercase
+ * letters, no forbidden characters, and no ASCII-encoded segments,
+ * and not ending with a trailing dot.
+ *
+ * Of course if @hostname is not an internationalized hostname, then
+ * the canonical presentation form will be entirely ASCII.
+ *
+ * Return value: a UTF-8 hostname, which must be freed, or %NULL if
+ * @hostname is in some way invalid.
+ *
+ * Since: 2.20
+ **/
+gchar *
+g_hostname_to_unicode (const gchar *hostname)
+{
+  GString *out;
+  gssize llen;
+
+  out = g_string_new (NULL);
+
+  do
+    {
+      llen = strcspn (hostname, ".");
+      if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+	{
+	  hostname += IDNA_ACE_PREFIX_LEN;
+	  llen -= IDNA_ACE_PREFIX_LEN;
+	  if (!punycode_decode (hostname, llen, out))
+	    {
+	      g_string_free (out, TRUE);
+	      return NULL;
+	    }
+	}
+      else
+        {
+          gchar *canonicalized = nameprep (hostname, llen);
+
+          g_string_append (out, canonicalized);
+          g_free (canonicalized);
+        }
+
+      hostname += llen;
+      if (*hostname && *++hostname)
+        g_string_append_c (out, '.');
+    }
+  while (*hostname);
+
+  return g_string_free (out, FALSE);
+}
+
+/**
+ * g_hostname_is_ascii_encoded:
+ * @hostname: a hostname
+ *
+ * Tests if @hostname contains segments with an ASCII-compatible
+ * encoding of an Internationalized Domain Name. If this returns
+ * %TRUE, you should decode the hostname with g_hostname_to_unicode()
+ * before displaying it to the user.
+ *
+ * Note that a hostname might contain a mix of encoded and unencoded
+ * segments, and so it is possible for g_hostname_is_non_ascii() and
+ * g_hostname_is_ascii_encoded() to both return %TRUE for a name.
+ *
+ * Return value: %TRUE if @hostname contains any ASCII-encoded
+ * segments.
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_ascii_encoded (const gchar *hostname)
+{
+  while (1)
+    {
+      if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
+	return TRUE;
+      hostname = strchr (hostname, '.');
+      if (!hostname++)
+	return FALSE;
+    }
+}
+
+/**
+ * g_hostname_is_ip_address:
+ * @hostname: a hostname (or IP address in string form)
+ *
+ * Tests if @hostname is the string form of an IPv4 or IPv6 address.
+ * (Eg, "192.168.0.1".)
+ *
+ * Return value: %TRUE if @hostname is an IP address
+ *
+ * Since: 2.20
+ **/
+gboolean
+g_hostname_is_ip_address (const gchar *hostname)
+{
+  gchar *p, *end;
+  gint nsegments, octet;
+
+  /* On Linux we could implement this using inet_pton, but the Windows
+   * equivalent of that requires linking against winsock, so we just
+   * figure this out ourselves. Tested by tests/hostutils.c.
+   */
+
+  p = (char *)hostname;
+
+  if (strchr (p, ':'))
+    {
+      gboolean skipped;
+
+      /* If it contains a ':', it's an IPv6 address (assuming it's an
+       * IP address at all). This consists of eight ':'-separated
+       * segments, each containing a 1-4 digit hex number, except that
+       * optionally: (a) the last two segments can be replaced by an
+       * IPv4 address, and (b) a single span of 1 to 8 "0000" segments
+       * can be replaced with just "::".
+       */
+
+      nsegments = 0;
+      skipped = FALSE;
+      while (*p && nsegments < 8)
+        {
+          /* Each segment after the first must be preceded by a ':'.
+           * (We also handle half of the "string starts with ::" case
+           * here.)
+           */
+          if (p != (char *)hostname || (p[0] == ':' && p[1] == ':'))
+            {
+              if (*p != ':')
+                return FALSE;
+              p++;
+            }
+
+          /* If there's another ':', it means we're skipping some segments */
+          if (*p == ':' && !skipped)
+            {
+              skipped = TRUE;
+              nsegments++;
+
+              /* Handle the "string ends with ::" case */
+              if (!p[1])
+                p++;
+
+              continue;
+            }
+
+          /* Read the segment, make sure it's valid. */
+          for (end = p; g_ascii_isxdigit (*end); end++)
+            ;
+          if (end == p || end > p + 4)
+            return FALSE;
+
+          if (*end == '.')
+            {
+              if ((nsegments == 6 && !skipped) || (nsegments <= 6 && skipped))
+                goto parse_ipv4;
+              else
+                return FALSE;
+            }
+
+          nsegments++;
+          p = end;
+        }
+
+      return !*p && (nsegments == 8 || skipped);
+    }
+
+ parse_ipv4:
+
+  /* Parse IPv4: N.N.N.N, where each N <= 255 and doesn't have leading 0s. */
+  for (nsegments = 0; nsegments < 4; nsegments++)
+    {
+      if (nsegments != 0)
+        {
+          if (*p != '.')
+            return FALSE;
+          p++;
+        }
+
+      /* Check the segment; a little tricker than the IPv6 case since
+       * we can't allow extra leading 0s, and we can't assume that all
+       * strings of valid length are within range.
+       */
+      octet = 0;
+      if (*p == '0')
+        end = p + 1;
+      else
+        {
+          for (end = p; g_ascii_isdigit (*end); end++)
+            octet = 10 * octet + (*end - '0');
+        }
+      if (end == p || end > p + 3 || octet > 255)
+        return FALSE;
+
+      p = end;
+    }
+
+  /* If there's nothing left to parse, then it's ok. */
+  return !*p;
+}
+
+#define __G_HOST_UTILS_C__
+#include "galiasdef.c"
diff --git a/glib/ghostutils.h b/glib/ghostutils.h
new file mode 100644
index 0000000..0349da3
--- /dev/null
+++ b/glib/ghostutils.h
@@ -0,0 +1,40 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 2008 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
+#error "Only <glib.h> can be included directly."
+#endif
+
+#ifndef __G_HOST_UTILS_H__
+#define __G_HOST_UTILS_H__
+
+#include <glib/gtypes.h>
+
+G_BEGIN_DECLS
+
+gboolean  g_hostname_is_non_ascii     (const gchar *hostname);
+gboolean  g_hostname_is_ascii_encoded (const gchar *hostname);
+gboolean  g_hostname_is_ip_address    (const gchar *hostname);
+
+gchar    *g_hostname_to_ascii         (const gchar *hostname);
+gchar    *g_hostname_to_unicode       (const gchar *hostname);
+
+G_END_DECLS
+
+#endif /* __G_HOST_UTILS_H__ */
diff --git a/glib/glib.h b/glib/glib.h
index 000d417..f8acdd2 100644
--- a/glib/glib.h
+++ b/glib/glib.h
@@ -47,6 +47,7 @@
 #include <glib/gfileutils.h>
 #include <glib/ghash.h>
 #include <glib/ghook.h>
+#include <glib/ghostutils.h>
 #include <glib/giochannel.h>
 #include <glib/gkeyfile.h>
 #include <glib/glist.h>
diff --git a/glib/glib.symbols b/glib/glib.symbols
index 333164f..061a693 100644
--- a/glib/glib.symbols
+++ b/glib/glib.symbols
@@ -1637,6 +1637,16 @@ g_win32_locale_filename_from_utf8
 #endif
 #endif
 
+#if IN_HEADER(__G_HOST_UTILS_H__)
+#if IN_FILE(__G_HOST_UTILS_C__)
+g_hostname_is_non_ascii
+g_hostname_is_ascii_encoded
+g_hostname_is_ip_address
+g_hostname_to_ascii
+g_hostname_to_unicode
+#endif
+#endif
+
 #ifdef INCLUDE_VARIABLES
 g_ascii_table
 g_utf8_skip
diff --git a/glib/tests/Makefile.am b/glib/tests/Makefile.am
index 3d497ac..673d338 100644
--- a/glib/tests/Makefile.am
+++ b/glib/tests/Makefile.am
@@ -44,6 +44,9 @@ markup_subparser_LDADD    = $(progs_ldadd)
 TEST_PROGS         += array-test
 array_test_LDADD    = $(progs_ldadd)
 
+TEST_PROGS         += hostutils
+hostutils_LDADD     = $(progs_ldadd)
+
 if OS_UNIX
 
 # some testing of gtester funcitonality
diff --git a/glib/tests/hostutils.c b/glib/tests/hostutils.c
new file mode 100644
index 0000000..515145a
--- /dev/null
+++ b/glib/tests/hostutils.c
@@ -0,0 +1,267 @@
+/* 
+ * Copyright (C) 2008 Red Hat, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <glib/glib.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+static const struct {
+  const gchar *ascii_name, *unicode_name;
+} idn_test_domains[] = {
+  /* "example.test" in various languages */
+  { "xn--mgbh0fb.xn--kgbechtv", "\xd9\x85\xd8\xab\xd8\xa7\xd9\x84.\xd8\xa5\xd8\xae\xd8\xaa\xd8\xa8\xd8\xa7\xd8\xb1" },
+  { "xn--fsqu00a.xn--0zwm56d", "\xe4\xbe\x8b\xe5\xad\x90.\xe6\xb5\x8b\xe8\xaf\x95" },
+  { "xn--fsqu00a.xn--g6w251d", "\xe4\xbe\x8b\xe5\xad\x90.\xe6\xb8\xac\xe8\xa9\xa6" },
+  { "xn--hxajbheg2az3al.xn--jxalpdlp", "\xcf\x80\xce\xb1\xcf\x81\xce\xac\xce\xb4\xce\xb5\xce\xb9\xce\xb3\xce\xbc\xce\xb1.\xce\xb4\xce\xbf\xce\xba\xce\xb9\xce\xbc\xce\xae" },
+  { "xn--p1b6ci4b4b3a.xn--11b5bs3a9aj6g", "\xe0\xa4\x89\xe0\xa4\xa6\xe0\xa4\xbe\xe0\xa4\xb9\xe0\xa4\xb0\xe0\xa4\xa3.\xe0\xa4\xaa\xe0\xa4\xb0\xe0\xa5\x80\xe0\xa4\x95\xe0\xa5\x8d\xe0\xa4\xb7\xe0\xa4\xbe" },
+  { "xn--r8jz45g.xn--zckzah", "\xe4\xbe\x8b\xe3\x81\x88.\xe3\x83\x86\xe3\x82\xb9\xe3\x83\x88" },
+  { "xn--9n2bp8q.xn--9t4b11yi5a", "\xec\x8b\xa4\xeb\xa1\x80.\xed\x85\x8c\xec\x8a\xa4\xed\x8a\xb8" },
+  { "xn--mgbh0fb.xn--hgbk6aj7f53bba", "\xd9\x85\xd8\xab\xd8\xa7\xd9\x84.\xd8\xa2\xd8\xb2\xd9\x85\xd8\xa7\xdb\x8c\xd8\xb4\xdb\x8c" },
+  { "xn--e1afmkfd.xn--80akhbyknj4f", "\xd0\xbf\xd1\x80\xd0\xb8\xd0\xbc\xd0\xb5\xd1\x80.\xd0\xb8\xd1\x81\xd0\xbf\xd1\x8b\xd1\x82\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5" },
+  { "xn--zkc6cc5bi7f6e.xn--hlcj6aya9esc7a", "\xe0\xae\x89\xe0\xae\xa4\xe0\xae\xbe\xe0\xae\xb0\xe0\xae\xa3\xe0\xae\xae\xe0\xaf\x8d.\xe0\xae\xaa\xe0\xae\xb0\xe0\xae\xbf\xe0\xae\x9f\xe0\xaf\x8d\xe0\xae\x9a\xe0\xaf\x88" },
+  { "xn--fdbk5d8ap9b8a8d.xn--deba0ad", "\xd7\x91\xd7\xb2\xd6\xb7\xd7\xa9\xd7\xa4\xd6\xbc\xd7\x99\xd7\x9c.\xd7\x98\xd7\xa2\xd7\xa1\xd7\x98" },
+
+  /* further examples without their own IDN-ized TLD */
+  { "xn--1xd0bwwra.idn.icann.org", "\xe1\x8a\xa0\xe1\x88\x9b\xe1\x88\xad\xe1\x8a\x9b.idn.icann.org" },
+  { "xn--54b7fta0cc.idn.icann.org", "\xe0\xa6\xac\xe0\xa6\xbe\xe0\xa6\x82\xe0\xa6\xb2\xe0\xa6\xbe.idn.icann.org" },
+  { "xn--5dbqzzl.idn.icann.org", "\xd7\xa2\xd7\x91\xd7\xa8\xd7\x99\xd7\xaa.idn.icann.org" },
+  { "xn--j2e7beiw1lb2hqg.idn.icann.org", "\xe1\x9e\x97\xe1\x9e\xb6\xe1\x9e\x9f\xe1\x9e\xb6\xe1\x9e\x81\xe1\x9f\x92\xe1\x9e\x98\xe1\x9f\x82\xe1\x9e\x9a.idn.icann.org" },
+  { "xn--o3cw4h.idn.icann.org", "\xe0\xb9\x84\xe0\xb8\x97\xe0\xb8\xa2.idn.icann.org" },
+  { "xn--mgbqf7g.idn.icann.org", "\xd8\xa7\xd8\xb1\xd8\xaf\xd9\x88.idn.icann.org" }
+};
+static const gint num_idn_test_domains = G_N_ELEMENTS (idn_test_domains);
+
+static void
+test_to_ascii (void)
+{
+  gint i;
+  gchar *ascii;
+
+  for (i = 0; i < num_idn_test_domains; i++)
+    {
+      g_assert (g_hostname_is_non_ascii (idn_test_domains[i].unicode_name));
+      ascii = g_hostname_to_ascii (idn_test_domains[i].unicode_name);
+      g_assert_cmpstr (idn_test_domains[i].ascii_name, ==, ascii);
+      g_free (ascii);
+
+      ascii = g_hostname_to_ascii (idn_test_domains[i].ascii_name);
+      g_assert_cmpstr (idn_test_domains[i].ascii_name, ==, ascii);
+      g_free (ascii);
+    }
+}
+
+static void
+test_to_unicode (void)
+{
+  gint i;
+  gchar *unicode;
+
+  for (i = 0; i < num_idn_test_domains; i++)
+    {
+      g_assert (g_hostname_is_ascii_encoded (idn_test_domains[i].ascii_name));
+      unicode = g_hostname_to_unicode (idn_test_domains[i].ascii_name);
+      g_assert_cmpstr (idn_test_domains[i].unicode_name, ==, unicode);
+      g_free (unicode);
+
+      unicode = g_hostname_to_unicode (idn_test_domains[i].unicode_name);
+      g_assert_cmpstr (idn_test_domains[i].unicode_name, ==, unicode);
+      g_free (unicode);
+    }
+}
+
+static const struct {
+  const gchar *addr;
+  gboolean is_addr;
+} ip_addr_tests[] = {
+  /* IPv6 tests */
+
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+
+  { "0123:4567:89AB:cdef:3210:7654:ba98::", TRUE },
+  { "0123:4567:89AB:cdef:3210:7654::", TRUE },
+  { "0123:4567:89AB:cdef:3210::", TRUE },
+  { "0123:4567:89AB:cdef::", TRUE },
+  { "0123:4567:89AB::", TRUE },
+  { "0123:4567::", TRUE },
+  { "0123::", TRUE },
+
+  { "::4567:89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "::3210:7654:ba98:FeDc", TRUE },
+  { "::7654:ba98:FeDc", TRUE },
+  { "::ba98:FeDc", TRUE },
+  { "::FeDc", TRUE },
+
+  { "0123::89AB:cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210:7654::FeDc", TRUE },
+
+  { "0123::cdef:3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef:3210::FeDc", TRUE },
+
+  { "0123::3210:7654:ba98:FeDc", TRUE },
+  { "0123:4567::7654:ba98:FeDc", TRUE },
+  { "0123:4567:89AB::ba98:FeDc", TRUE },
+  { "0123:4567:89AB:cdef::FeDc", TRUE },
+
+  { "0123::7654:ba98:FeDc", TRUE },
+  { "0123:4567::ba98:FeDc", TRUE },
+  { "0123:4567:89AB::FeDc", TRUE },
+
+  { "0123::ba98:FeDc", TRUE },
+  { "0123:4567::FeDc", TRUE },
+
+  { "0123::FeDc", TRUE },
+
+  { "::", TRUE },
+
+  { "0:12:345:6789:a:bc:def::", TRUE },
+
+  { "0123:4567:89AB:cdef:3210:7654:123.45.67.89", TRUE },
+  { "0123:4567:89AB:cdef:3210::123.45.67.89", TRUE },
+  { "0123:4567:89AB:cdef::123.45.67.89", TRUE },
+  { "0123:4567:89AB::123.45.67.89", TRUE },
+  { "0123:4567::123.45.67.89", TRUE },
+  { "0123::123.45.67.89", TRUE },
+  { "::123.45.67.89", TRUE },
+
+  /* Contain non-hex chars */
+  { "012x:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:45x7:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:8xAB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:xdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:321;:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:76*4:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:b-98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:+eDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc and some trailing junk", FALSE },
+  { " 123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "012 :4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123: 567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeD ", FALSE },
+
+  /* Contains too-long/out-of-range segments */
+  { "00123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:04567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:189AB:cdef:3210:7654:ba98:FeDc", FALSE },
+
+  /* Too short */
+  { "0123:4567:89AB:cdef:3210:7654:ba98", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654", FALSE },
+  { "0123:4567:89AB:cdef:3210", FALSE },
+  { "0123", FALSE },
+  { "", FALSE },
+
+  /* Too long */
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc:9999", FALSE },
+  { "0123::4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567::89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB::cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef::3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210::7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654::ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98::FeDc", FALSE },
+
+  /* Invalid use of ":"s */
+  { "0123::89AB::3210:7654:ba98:FeDc", FALSE },
+  { "::4567:89AB:cdef:3210:7654::FeDc", FALSE },
+  { "0123::89AB:cdef:3210:7654:ba98::", FALSE },
+  { ":4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:", FALSE },
+  { "0123:::cdef:3210:7654:ba98:FeDc", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654:ba98:FeDc:", FALSE },
+  { ":0123:4567:89AB:cdef:3210:7654:ba98:FeDc", FALSE },
+  { ":::", FALSE },
+
+  /* IPv4 address at wrong place */
+  { "0123:4567:89AB:cdef:3210:123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:3210:7654::123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:123.45.67.89", FALSE },
+  { "0123:4567:89AB:cdef:3210:123.45.67.89:FeDc", FALSE },
+
+
+  /* IPv4 tests */
+
+  { "123.45.67.89", TRUE },
+  { "1.2.3.4", TRUE },
+  { "1.2.3.0", TRUE },
+
+  { "023.045.067.089", FALSE },
+  { "1234.5.67.89", FALSE },
+  { "123.45.67.00", FALSE },
+  { " 1.2.3.4", FALSE },
+  { "1 .2.3.4", FALSE },
+  { "1. 2.3.4", FALSE },
+  { "1.2.3.4 ", FALSE },
+  { "1.2.3", FALSE },
+  { "1.2.3.4.5", FALSE },
+  { "1.b.3.4", FALSE },
+  { "1.2.3:4", FALSE },
+  { "1.2.3.4, etc", FALSE },
+  { "1,2,3,4", FALSE },
+  { "1.2.3.com", FALSE },
+  { "1.2.3.4.", FALSE },
+  { "1.2.3.", FALSE },
+  { ".1.2.3.4", FALSE },
+  { ".2.3.4", FALSE },
+  { "1..2.3.4", FALSE },
+  { "1..3.4", FALSE }
+};
+static const gint num_ip_addr_tests = G_N_ELEMENTS (ip_addr_tests);
+
+static void
+test_is_ip_addr (void)
+{
+  gint i;
+
+  for (i = 0; i < num_ip_addr_tests; i++)
+    {
+      if (g_hostname_is_ip_address (ip_addr_tests[i].addr) != ip_addr_tests[i].is_addr)
+	{
+	  char *msg = g_strdup_printf ("g_hostname_is_ip_address (\"%s\") == %s",
+				       ip_addr_tests[i].addr,
+				       ip_addr_tests[i].is_addr ? "TRUE" : "FALSE");
+	  g_assertion_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
+	}
+    }
+}
+
+/* FIXME: test names with both unicode and ACE-encoded labels */
+/* FIXME: test invalid unicode names */
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_test_init (&argc, &argv, NULL);
+  
+  g_test_add_func ("/hostutils/to_ascii", test_to_ascii);
+  g_test_add_func ("/hostutils/to_unicode", test_to_unicode);
+  g_test_add_func ("/hostutils/is_ip_addr", test_is_ip_addr);
+
+  return g_test_run ();
+}
diff --git a/glibconfig.h.win32.in b/glibconfig.h.win32.in
index 92e8964..f10fa32 100644
--- a/glibconfig.h.win32.in
+++ b/glibconfig.h.win32.in
@@ -250,6 +250,9 @@ union _GSystemThread
  */
 typedef void * GPid;
 
+#define GLIB_SYSDEF_AF_INET 2
+#define GLIB_SYSDEF_AF_INET6 23
+
 G_END_DECLS
 
 #endif /* GLIBCONFIG_H */
